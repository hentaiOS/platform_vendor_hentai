// Signature format: 2.0
package android.system {

  public final class ErrnoException extends java.lang.Exception {
    ctor public ErrnoException(String, int);
    ctor public ErrnoException(String, int, Throwable);
    method @NonNull public java.io.IOException rethrowAsIOException() throws java.io.IOException;
    method @NonNull public java.net.SocketException rethrowAsSocketException() throws java.net.SocketException;
    field public final int errno;
  }

  public class Int64Ref {
    ctor public Int64Ref(long);
    field public long value;
  }

  public final class Os {
    method public static java.io.FileDescriptor accept(java.io.FileDescriptor, java.net.InetSocketAddress) throws android.system.ErrnoException, java.net.SocketException;
    method public static boolean access(String, int) throws android.system.ErrnoException;
    method public static void bind(java.io.FileDescriptor, java.net.InetAddress, int) throws android.system.ErrnoException, java.net.SocketException;
    method public static void bind(@NonNull java.io.FileDescriptor, @NonNull java.net.SocketAddress) throws android.system.ErrnoException, java.net.SocketException;
    method public static void chmod(String, int) throws android.system.ErrnoException;
    method public static void chown(String, int, int) throws android.system.ErrnoException;
    method public static void close(java.io.FileDescriptor) throws android.system.ErrnoException;
    method public static void connect(java.io.FileDescriptor, java.net.InetAddress, int) throws android.system.ErrnoException, java.net.SocketException;
    method public static void connect(@NonNull java.io.FileDescriptor, @NonNull java.net.SocketAddress) throws android.system.ErrnoException, java.net.SocketException;
    method public static java.io.FileDescriptor dup(java.io.FileDescriptor) throws android.system.ErrnoException;
    method public static java.io.FileDescriptor dup2(java.io.FileDescriptor, int) throws android.system.ErrnoException;
    method public static String[] environ();
    method public static void execv(String, String[]) throws android.system.ErrnoException;
    method public static void execve(String, String[], String[]) throws android.system.ErrnoException;
    method public static void fchmod(java.io.FileDescriptor, int) throws android.system.ErrnoException;
    method public static void fchown(java.io.FileDescriptor, int, int) throws android.system.ErrnoException;
    method public static int fcntlInt(@NonNull java.io.FileDescriptor, int, int) throws android.system.ErrnoException;
    method public static void fdatasync(java.io.FileDescriptor) throws android.system.ErrnoException;
    method public static android.system.StructStat fstat(java.io.FileDescriptor) throws android.system.ErrnoException;
    method public static android.system.StructStatVfs fstatvfs(java.io.FileDescriptor) throws android.system.ErrnoException;
    method public static void fsync(java.io.FileDescriptor) throws android.system.ErrnoException;
    method public static void ftruncate(java.io.FileDescriptor, long) throws android.system.ErrnoException;
    method public static String gai_strerror(int);
    method public static int getegid();
    method public static String getenv(String);
    method public static int geteuid();
    method public static int getgid();
    method public static java.net.SocketAddress getpeername(java.io.FileDescriptor) throws android.system.ErrnoException;
    method public static int getpid();
    method public static int getppid();
    method public static java.net.SocketAddress getsockname(java.io.FileDescriptor) throws android.system.ErrnoException;
    method @NonNull public static android.system.StructTimeval getsockoptTimeval(@NonNull java.io.FileDescriptor, int, int) throws android.system.ErrnoException;
    method public static int gettid();
    method public static int getuid();
    method public static byte[] getxattr(String, String) throws android.system.ErrnoException;
    method public static String if_indextoname(int);
    method public static int if_nametoindex(String);
    method public static java.net.InetAddress inet_pton(int, String);
    method public static boolean isatty(java.io.FileDescriptor);
    method public static void kill(int, int) throws android.system.ErrnoException;
    method public static void lchown(String, int, int) throws android.system.ErrnoException;
    method public static void link(String, String) throws android.system.ErrnoException;
    method public static void listen(java.io.FileDescriptor, int) throws android.system.ErrnoException;
    method public static String[] listxattr(String) throws android.system.ErrnoException;
    method public static long lseek(java.io.FileDescriptor, long, int) throws android.system.ErrnoException;
    method public static android.system.StructStat lstat(String) throws android.system.ErrnoException;
    method @NonNull public static java.io.FileDescriptor memfd_create(@NonNull String, int) throws android.system.ErrnoException;
    method public static void mincore(long, long, byte[]) throws android.system.ErrnoException;
    method public static void mkdir(String, int) throws android.system.ErrnoException;
    method public static void mkfifo(String, int) throws android.system.ErrnoException;
    method public static void mlock(long, long) throws android.system.ErrnoException;
    method public static long mmap(long, long, int, int, java.io.FileDescriptor, long) throws android.system.ErrnoException;
    method public static void msync(long, long, int) throws android.system.ErrnoException;
    method public static void munlock(long, long) throws android.system.ErrnoException;
    method public static void munmap(long, long) throws android.system.ErrnoException;
    method public static java.io.FileDescriptor open(String, int, int) throws android.system.ErrnoException;
    method public static java.io.FileDescriptor[] pipe() throws android.system.ErrnoException;
    method public static int poll(android.system.StructPollfd[], int) throws android.system.ErrnoException;
    method public static void posix_fallocate(java.io.FileDescriptor, long, long) throws android.system.ErrnoException;
    method public static int prctl(int, long, long, long, long) throws android.system.ErrnoException;
    method public static int pread(java.io.FileDescriptor, java.nio.ByteBuffer, long) throws android.system.ErrnoException, java.io.InterruptedIOException;
    method public static int pread(java.io.FileDescriptor, byte[], int, int, long) throws android.system.ErrnoException, java.io.InterruptedIOException;
    method public static int pwrite(java.io.FileDescriptor, java.nio.ByteBuffer, long) throws android.system.ErrnoException, java.io.InterruptedIOException;
    method public static int pwrite(java.io.FileDescriptor, byte[], int, int, long) throws android.system.ErrnoException, java.io.InterruptedIOException;
    method public static int read(java.io.FileDescriptor, java.nio.ByteBuffer) throws android.system.ErrnoException, java.io.InterruptedIOException;
    method public static int read(java.io.FileDescriptor, byte[], int, int) throws android.system.ErrnoException, java.io.InterruptedIOException;
    method public static String readlink(String) throws android.system.ErrnoException;
    method public static int readv(java.io.FileDescriptor, Object[], int[], int[]) throws android.system.ErrnoException, java.io.InterruptedIOException;
    method public static int recvfrom(java.io.FileDescriptor, java.nio.ByteBuffer, int, java.net.InetSocketAddress) throws android.system.ErrnoException, java.net.SocketException;
    method public static int recvfrom(java.io.FileDescriptor, byte[], int, int, int, java.net.InetSocketAddress) throws android.system.ErrnoException, java.net.SocketException;
    method public static int recvmsg(@NonNull java.io.FileDescriptor, @NonNull android.system.StructMsghdr, int) throws android.system.ErrnoException, java.net.SocketException;
    method public static void remove(String) throws android.system.ErrnoException;
    method public static void removexattr(String, String) throws android.system.ErrnoException;
    method public static void rename(String, String) throws android.system.ErrnoException;
    method public static long sendfile(java.io.FileDescriptor, java.io.FileDescriptor, android.system.Int64Ref, long) throws android.system.ErrnoException;
    method public static int sendmsg(@NonNull java.io.FileDescriptor, @NonNull android.system.StructMsghdr, int) throws android.system.ErrnoException, java.net.SocketException;
    method public static int sendto(java.io.FileDescriptor, java.nio.ByteBuffer, int, java.net.InetAddress, int) throws android.system.ErrnoException, java.net.SocketException;
    method public static int sendto(java.io.FileDescriptor, byte[], int, int, int, java.net.InetAddress, int) throws android.system.ErrnoException, java.net.SocketException;
    method public static int sendto(@NonNull java.io.FileDescriptor, @NonNull byte[], int, int, int, @Nullable java.net.SocketAddress) throws android.system.ErrnoException, java.net.SocketException;
    method @Deprecated public static void setegid(int) throws android.system.ErrnoException;
    method public static void setenv(String, String, boolean) throws android.system.ErrnoException;
    method @Deprecated public static void seteuid(int) throws android.system.ErrnoException;
    method @Deprecated public static void setgid(int) throws android.system.ErrnoException;
    method public static int setsid() throws android.system.ErrnoException;
    method public static void setsockoptInt(java.io.FileDescriptor, int, int, int) throws android.system.ErrnoException;
    method public static void setsockoptTimeval(@NonNull java.io.FileDescriptor, int, int, @NonNull android.system.StructTimeval) throws android.system.ErrnoException;
    method @Deprecated public static void setuid(int) throws android.system.ErrnoException;
    method public static void setxattr(String, String, byte[], int) throws android.system.ErrnoException;
    method public static void shutdown(java.io.FileDescriptor, int) throws android.system.ErrnoException;
    method public static java.io.FileDescriptor socket(int, int, int) throws android.system.ErrnoException;
    method public static void socketpair(int, int, int, java.io.FileDescriptor, java.io.FileDescriptor) throws android.system.ErrnoException;
    method public static android.system.StructStat stat(String) throws android.system.ErrnoException;
    method public static android.system.StructStatVfs statvfs(String) throws android.system.ErrnoException;
    method public static String strerror(int);
    method public static String strsignal(int);
    method public static void symlink(String, String) throws android.system.ErrnoException;
    method public static long sysconf(int);
    method public static void tcdrain(java.io.FileDescriptor) throws android.system.ErrnoException;
    method public static void tcsendbreak(java.io.FileDescriptor, int) throws android.system.ErrnoException;
    method public static int umask(int);
    method public static android.system.StructUtsname uname();
    method public static void unsetenv(String) throws android.system.ErrnoException;
    method public static int write(java.io.FileDescriptor, java.nio.ByteBuffer) throws android.system.ErrnoException, java.io.InterruptedIOException;
    method public static int write(java.io.FileDescriptor, byte[], int, int) throws android.system.ErrnoException, java.io.InterruptedIOException;
    method public static int writev(java.io.FileDescriptor, Object[], int[], int[]) throws android.system.ErrnoException, java.io.InterruptedIOException;
  }

  public final class OsConstants {
    method public static boolean S_ISBLK(int);
    method public static boolean S_ISCHR(int);
    method public static boolean S_ISDIR(int);
    method public static boolean S_ISFIFO(int);
    method public static boolean S_ISLNK(int);
    method public static boolean S_ISREG(int);
    method public static boolean S_ISSOCK(int);
    method public static boolean WCOREDUMP(int);
    method public static int WEXITSTATUS(int);
    method public static boolean WIFEXITED(int);
    method public static boolean WIFSIGNALED(int);
    method public static boolean WIFSTOPPED(int);
    method public static int WSTOPSIG(int);
    method public static int WTERMSIG(int);
    method public static String errnoName(int);
    method public static String gaiName(int);
    field public static final int AF_INET;
    field public static final int AF_INET6;
    field public static final int AF_NETLINK;
    field public static final int AF_PACKET;
    field public static final int AF_UNIX;
    field public static final int AF_UNSPEC;
    field public static final int AF_VSOCK;
    field public static final int AI_ADDRCONFIG;
    field public static final int AI_ALL;
    field public static final int AI_CANONNAME;
    field public static final int AI_NUMERICHOST;
    field public static final int AI_NUMERICSERV;
    field public static final int AI_PASSIVE;
    field public static final int AI_V4MAPPED;
    field public static final int ARPHRD_ETHER;
    field public static final int CAP_AUDIT_CONTROL;
    field public static final int CAP_AUDIT_WRITE;
    field public static final int CAP_BLOCK_SUSPEND;
    field public static final int CAP_CHOWN;
    field public static final int CAP_DAC_OVERRIDE;
    field public static final int CAP_DAC_READ_SEARCH;
    field public static final int CAP_FOWNER;
    field public static final int CAP_FSETID;
    field public static final int CAP_IPC_LOCK;
    field public static final int CAP_IPC_OWNER;
    field public static final int CAP_KILL;
    field public static final int CAP_LAST_CAP;
    field public static final int CAP_LEASE;
    field public static final int CAP_LINUX_IMMUTABLE;
    field public static final int CAP_MAC_ADMIN;
    field public static final int CAP_MAC_OVERRIDE;
    field public static final int CAP_MKNOD;
    field public static final int CAP_NET_ADMIN;
    field public static final int CAP_NET_BIND_SERVICE;
    field public static final int CAP_NET_BROADCAST;
    field public static final int CAP_NET_RAW;
    field public static final int CAP_SETFCAP;
    field public static final int CAP_SETGID;
    field public static final int CAP_SETPCAP;
    field public static final int CAP_SETUID;
    field public static final int CAP_SYSLOG;
    field public static final int CAP_SYS_ADMIN;
    field public static final int CAP_SYS_BOOT;
    field public static final int CAP_SYS_CHROOT;
    field public static final int CAP_SYS_MODULE;
    field public static final int CAP_SYS_NICE;
    field public static final int CAP_SYS_PACCT;
    field public static final int CAP_SYS_PTRACE;
    field public static final int CAP_SYS_RAWIO;
    field public static final int CAP_SYS_RESOURCE;
    field public static final int CAP_SYS_TIME;
    field public static final int CAP_SYS_TTY_CONFIG;
    field public static final int CAP_WAKE_ALARM;
    field public static final int E2BIG;
    field public static final int EACCES;
    field public static final int EADDRINUSE;
    field public static final int EADDRNOTAVAIL;
    field public static final int EAFNOSUPPORT;
    field public static final int EAGAIN;
    field public static final int EAI_AGAIN;
    field public static final int EAI_BADFLAGS;
    field public static final int EAI_FAIL;
    field public static final int EAI_FAMILY;
    field public static final int EAI_MEMORY;
    field public static final int EAI_NODATA;
    field public static final int EAI_NONAME;
    field public static final int EAI_OVERFLOW;
    field public static final int EAI_SERVICE;
    field public static final int EAI_SOCKTYPE;
    field public static final int EAI_SYSTEM;
    field public static final int EALREADY;
    field public static final int EBADF;
    field public static final int EBADMSG;
    field public static final int EBUSY;
    field public static final int ECANCELED;
    field public static final int ECHILD;
    field public static final int ECONNABORTED;
    field public static final int ECONNREFUSED;
    field public static final int ECONNRESET;
    field public static final int EDEADLK;
    field public static final int EDESTADDRREQ;
    field public static final int EDOM;
    field public static final int EDQUOT;
    field public static final int EEXIST;
    field public static final int EFAULT;
    field public static final int EFBIG;
    field public static final int EHOSTUNREACH;
    field public static final int EIDRM;
    field public static final int EILSEQ;
    field public static final int EINPROGRESS;
    field public static final int EINTR;
    field public static final int EINVAL;
    field public static final int EIO;
    field public static final int EISCONN;
    field public static final int EISDIR;
    field public static final int ELOOP;
    field public static final int EMFILE;
    field public static final int EMLINK;
    field public static final int EMSGSIZE;
    field public static final int EMULTIHOP;
    field public static final int ENAMETOOLONG;
    field public static final int ENETDOWN;
    field public static final int ENETRESET;
    field public static final int ENETUNREACH;
    field public static final int ENFILE;
    field public static final int ENOBUFS;
    field public static final int ENODATA;
    field public static final int ENODEV;
    field public static final int ENOENT;
    field public static final int ENOEXEC;
    field public static final int ENOLCK;
    field public static final int ENOLINK;
    field public static final int ENOMEM;
    field public static final int ENOMSG;
    field public static final int ENONET;
    field public static final int ENOPROTOOPT;
    field public static final int ENOSPC;
    field public static final int ENOSR;
    field public static final int ENOSTR;
    field public static final int ENOSYS;
    field public static final int ENOTCONN;
    field public static final int ENOTDIR;
    field public static final int ENOTEMPTY;
    field public static final int ENOTSOCK;
    field public static final int ENOTSUP;
    field public static final int ENOTTY;
    field public static final int ENXIO;
    field public static final int EOPNOTSUPP;
    field public static final int EOVERFLOW;
    field public static final int EPERM;
    field public static final int EPIPE;
    field public static final int EPROTO;
    field public static final int EPROTONOSUPPORT;
    field public static final int EPROTOTYPE;
    field public static final int ERANGE;
    field public static final int EROFS;
    field public static final int ESPIPE;
    field public static final int ESRCH;
    field public static final int ESTALE;
    field public static final int ETH_P_ALL;
    field public static final int ETH_P_ARP;
    field public static final int ETH_P_IP;
    field public static final int ETH_P_IPV6;
    field public static final int ETIME;
    field public static final int ETIMEDOUT;
    field public static final int ETXTBSY;
    field public static final int EXDEV;
    field public static final int EXIT_FAILURE;
    field public static final int EXIT_SUCCESS;
    field public static final int FD_CLOEXEC;
    field public static final int FIONREAD;
    field public static final int F_DUPFD;
    field public static final int F_DUPFD_CLOEXEC;
    field public static final int F_GETFD;
    field public static final int F_GETFL;
    field public static final int F_GETLK;
    field public static final int F_GETLK64;
    field public static final int F_GETOWN;
    field public static final int F_OK;
    field public static final int F_RDLCK;
    field public static final int F_SETFD;
    field public static final int F_SETFL;
    field public static final int F_SETLK;
    field public static final int F_SETLK64;
    field public static final int F_SETLKW;
    field public static final int F_SETLKW64;
    field public static final int F_SETOWN;
    field public static final int F_UNLCK;
    field public static final int F_WRLCK;
    field public static final int ICMP6_ECHO_REPLY;
    field public static final int ICMP6_ECHO_REQUEST;
    field public static final int ICMP_ECHO;
    field public static final int ICMP_ECHOREPLY;
    field public static final int IFA_F_DADFAILED;
    field public static final int IFA_F_DEPRECATED;
    field public static final int IFA_F_HOMEADDRESS;
    field public static final int IFA_F_MANAGETEMPADDR;
    field public static final int IFA_F_NODAD;
    field public static final int IFA_F_NOPREFIXROUTE;
    field public static final int IFA_F_OPTIMISTIC;
    field public static final int IFA_F_PERMANENT;
    field public static final int IFA_F_SECONDARY;
    field public static final int IFA_F_TEMPORARY;
    field public static final int IFA_F_TENTATIVE;
    field public static final int IFF_ALLMULTI;
    field public static final int IFF_AUTOMEDIA;
    field public static final int IFF_BROADCAST;
    field public static final int IFF_DEBUG;
    field public static final int IFF_DYNAMIC;
    field public static final int IFF_LOOPBACK;
    field public static final int IFF_MASTER;
    field public static final int IFF_MULTICAST;
    field public static final int IFF_NOARP;
    field public static final int IFF_NOTRAILERS;
    field public static final int IFF_POINTOPOINT;
    field public static final int IFF_PORTSEL;
    field public static final int IFF_PROMISC;
    field public static final int IFF_RUNNING;
    field public static final int IFF_SLAVE;
    field public static final int IFF_UP;
    field @FlaggedApi("com.android.libcore.v_apis") public static final int IPPROTO_ESP;
    field public static final int IPPROTO_ICMP;
    field public static final int IPPROTO_ICMPV6;
    field public static final int IPPROTO_IP;
    field public static final int IPPROTO_IPV6;
    field public static final int IPPROTO_RAW;
    field public static final int IPPROTO_TCP;
    field public static final int IPPROTO_UDP;
    field public static final int IPV6_CHECKSUM;
    field public static final int IPV6_MULTICAST_HOPS;
    field public static final int IPV6_MULTICAST_IF;
    field public static final int IPV6_MULTICAST_LOOP;
    field @FlaggedApi("com.android.libcore.v_apis") public static final int IPV6_PKTINFO;
    field public static final int IPV6_RECVDSTOPTS;
    field public static final int IPV6_RECVHOPLIMIT;
    field public static final int IPV6_RECVHOPOPTS;
    field public static final int IPV6_RECVPKTINFO;
    field public static final int IPV6_RECVRTHDR;
    field public static final int IPV6_RECVTCLASS;
    field public static final int IPV6_TCLASS;
    field public static final int IPV6_UNICAST_HOPS;
    field public static final int IPV6_V6ONLY;
    field public static final int IP_MULTICAST_IF;
    field public static final int IP_MULTICAST_LOOP;
    field public static final int IP_MULTICAST_TTL;
    field public static final int IP_TOS;
    field public static final int IP_TTL;
    field public static final int MAP_ANONYMOUS;
    field public static final int MAP_FIXED;
    field public static final int MAP_PRIVATE;
    field public static final int MAP_SHARED;
    field public static final int MCAST_BLOCK_SOURCE;
    field public static final int MCAST_JOIN_GROUP;
    field public static final int MCAST_JOIN_SOURCE_GROUP;
    field public static final int MCAST_LEAVE_GROUP;
    field public static final int MCAST_LEAVE_SOURCE_GROUP;
    field public static final int MCAST_UNBLOCK_SOURCE;
    field public static final int MCL_CURRENT;
    field public static final int MCL_FUTURE;
    field public static final int MFD_CLOEXEC;
    field public static final int MSG_CTRUNC;
    field public static final int MSG_DONTROUTE;
    field public static final int MSG_EOR;
    field public static final int MSG_OOB;
    field public static final int MSG_PEEK;
    field public static final int MSG_TRUNC;
    field public static final int MSG_WAITALL;
    field public static final int MS_ASYNC;
    field public static final int MS_INVALIDATE;
    field public static final int MS_SYNC;
    field public static final int NETLINK_INET_DIAG;
    field public static final int NETLINK_NETFILTER;
    field public static final int NETLINK_ROUTE;
    field @FlaggedApi("com.android.libcore.v_apis") public static final int NETLINK_XFRM;
    field public static final int NI_DGRAM;
    field public static final int NI_NAMEREQD;
    field public static final int NI_NOFQDN;
    field public static final int NI_NUMERICHOST;
    field public static final int NI_NUMERICSERV;
    field public static final int O_ACCMODE;
    field public static final int O_APPEND;
    field public static final int O_CLOEXEC;
    field public static final int O_CREAT;
    field public static final int O_DSYNC;
    field public static final int O_EXCL;
    field public static final int O_NOCTTY;
    field public static final int O_NOFOLLOW;
    field public static final int O_NONBLOCK;
    field public static final int O_RDONLY;
    field public static final int O_RDWR;
    field public static final int O_SYNC;
    field public static final int O_TRUNC;
    field public static final int O_WRONLY;
    field @FlaggedApi("com.android.libcore.v_apis") public static final int PACKET_IGNORE_OUTGOING;
    field public static final int POLLERR;
    field public static final int POLLHUP;
    field public static final int POLLIN;
    field public static final int POLLNVAL;
    field public static final int POLLOUT;
    field public static final int POLLPRI;
    field public static final int POLLRDBAND;
    field public static final int POLLRDNORM;
    field public static final int POLLWRBAND;
    field public static final int POLLWRNORM;
    field public static final int PROT_EXEC;
    field public static final int PROT_NONE;
    field public static final int PROT_READ;
    field public static final int PROT_WRITE;
    field public static final int PR_GET_DUMPABLE;
    field public static final int PR_SET_DUMPABLE;
    field public static final int PR_SET_NO_NEW_PRIVS;
    field public static final int RTMGRP_NEIGH;
    field public static final int RT_SCOPE_HOST;
    field public static final int RT_SCOPE_LINK;
    field public static final int RT_SCOPE_NOWHERE;
    field public static final int RT_SCOPE_SITE;
    field public static final int RT_SCOPE_UNIVERSE;
    field public static final int R_OK;
    field public static final int SEEK_CUR;
    field public static final int SEEK_END;
    field public static final int SEEK_SET;
    field public static final int SHUT_RD;
    field public static final int SHUT_RDWR;
    field public static final int SHUT_WR;
    field public static final int SIGABRT;
    field public static final int SIGALRM;
    field public static final int SIGBUS;
    field public static final int SIGCHLD;
    field public static final int SIGCONT;
    field public static final int SIGFPE;
    field public static final int SIGHUP;
    field public static final int SIGILL;
    field public static final int SIGINT;
    field public static final int SIGIO;
    field public static final int SIGKILL;
    field public static final int SIGPIPE;
    field public static final int SIGPROF;
    field public static final int SIGPWR;
    field public static final int SIGQUIT;
    field public static final int SIGRTMAX;
    field public static final int SIGRTMIN;
    field public static final int SIGSEGV;
    field public static final int SIGSTKFLT;
    field public static final int SIGSTOP;
    field public static final int SIGSYS;
    field public static final int SIGTERM;
    field public static final int SIGTRAP;
    field public static final int SIGTSTP;
    field public static final int SIGTTIN;
    field public static final int SIGTTOU;
    field public static final int SIGURG;
    field public static final int SIGUSR1;
    field public static final int SIGUSR2;
    field public static final int SIGVTALRM;
    field public static final int SIGWINCH;
    field public static final int SIGXCPU;
    field public static final int SIGXFSZ;
    field public static final int SIOCGIFADDR;
    field public static final int SIOCGIFBRDADDR;
    field public static final int SIOCGIFDSTADDR;
    field public static final int SIOCGIFNETMASK;
    field public static final int SOCK_CLOEXEC;
    field public static final int SOCK_DGRAM;
    field public static final int SOCK_NONBLOCK;
    field public static final int SOCK_RAW;
    field public static final int SOCK_SEQPACKET;
    field public static final int SOCK_STREAM;
    field @FlaggedApi("com.android.libcore.v_apis") public static final int SOL_PACKET;
    field public static final int SOL_SOCKET;
    field public static final int SOL_UDP;
    field public static final int SO_BINDTODEVICE;
    field public static final int SO_BROADCAST;
    field public static final int SO_DEBUG;
    field public static final int SO_DONTROUTE;
    field public static final int SO_ERROR;
    field public static final int SO_KEEPALIVE;
    field public static final int SO_LINGER;
    field public static final int SO_OOBINLINE;
    field public static final int SO_PASSCRED;
    field public static final int SO_PEERCRED;
    field public static final int SO_RCVBUF;
    field public static final int SO_RCVLOWAT;
    field public static final int SO_RCVTIMEO;
    field public static final int SO_REUSEADDR;
    field public static final int SO_SNDBUF;
    field public static final int SO_SNDLOWAT;
    field public static final int SO_SNDTIMEO;
    field public static final int SO_TYPE;
    field public static final int STDERR_FILENO;
    field public static final int STDIN_FILENO;
    field public static final int STDOUT_FILENO;
    field public static final int ST_MANDLOCK;
    field public static final int ST_NOATIME;
    field public static final int ST_NODEV;
    field public static final int ST_NODIRATIME;
    field public static final int ST_NOEXEC;
    field public static final int ST_NOSUID;
    field public static final int ST_RDONLY;
    field public static final int ST_RELATIME;
    field public static final int ST_SYNCHRONOUS;
    field public static final int S_IFBLK;
    field public static final int S_IFCHR;
    field public static final int S_IFDIR;
    field public static final int S_IFIFO;
    field public static final int S_IFLNK;
    field public static final int S_IFMT;
    field public static final int S_IFREG;
    field public static final int S_IFSOCK;
    field public static final int S_IRGRP;
    field public static final int S_IROTH;
    field public static final int S_IRUSR;
    field public static final int S_IRWXG;
    field public static final int S_IRWXO;
    field public static final int S_IRWXU;
    field public static final int S_ISGID;
    field public static final int S_ISUID;
    field public static final int S_ISVTX;
    field public static final int S_IWGRP;
    field public static final int S_IWOTH;
    field public static final int S_IWUSR;
    field public static final int S_IXGRP;
    field public static final int S_IXOTH;
    field public static final int S_IXUSR;
    field public static final int TCP_NODELAY;
    field public static final int TCP_USER_TIMEOUT;
    field public static final int UDP_GRO;
    field public static final int UDP_SEGMENT;
    field public static final int VMADDR_CID_ANY;
    field public static final int VMADDR_CID_HOST;
    field public static final int VMADDR_CID_LOCAL;
    field public static final int VMADDR_PORT_ANY;
    field public static final int WCONTINUED;
    field public static final int WEXITED;
    field public static final int WNOHANG;
    field public static final int WNOWAIT;
    field public static final int WSTOPPED;
    field public static final int WUNTRACED;
    field public static final int W_OK;
    field public static final int X_OK;
    field public static final int _SC_2_CHAR_TERM;
    field public static final int _SC_2_C_BIND;
    field public static final int _SC_2_C_DEV;
    field public static final int _SC_2_C_VERSION;
    field public static final int _SC_2_FORT_DEV;
    field public static final int _SC_2_FORT_RUN;
    field public static final int _SC_2_LOCALEDEF;
    field public static final int _SC_2_SW_DEV;
    field public static final int _SC_2_UPE;
    field public static final int _SC_2_VERSION;
    field public static final int _SC_AIO_LISTIO_MAX;
    field public static final int _SC_AIO_MAX;
    field public static final int _SC_AIO_PRIO_DELTA_MAX;
    field public static final int _SC_ARG_MAX;
    field public static final int _SC_ASYNCHRONOUS_IO;
    field public static final int _SC_ATEXIT_MAX;
    field public static final int _SC_AVPHYS_PAGES;
    field public static final int _SC_BC_BASE_MAX;
    field public static final int _SC_BC_DIM_MAX;
    field public static final int _SC_BC_SCALE_MAX;
    field public static final int _SC_BC_STRING_MAX;
    field public static final int _SC_CHILD_MAX;
    field public static final int _SC_CLK_TCK;
    field public static final int _SC_COLL_WEIGHTS_MAX;
    field public static final int _SC_DELAYTIMER_MAX;
    field public static final int _SC_EXPR_NEST_MAX;
    field public static final int _SC_FSYNC;
    field public static final int _SC_GETGR_R_SIZE_MAX;
    field public static final int _SC_GETPW_R_SIZE_MAX;
    field public static final int _SC_IOV_MAX;
    field public static final int _SC_JOB_CONTROL;
    field public static final int _SC_LINE_MAX;
    field public static final int _SC_LOGIN_NAME_MAX;
    field public static final int _SC_MAPPED_FILES;
    field public static final int _SC_MEMLOCK;
    field public static final int _SC_MEMLOCK_RANGE;
    field public static final int _SC_MEMORY_PROTECTION;
    field public static final int _SC_MESSAGE_PASSING;
    field public static final int _SC_MQ_OPEN_MAX;
    field public static final int _SC_MQ_PRIO_MAX;
    field public static final int _SC_NGROUPS_MAX;
    field public static final int _SC_NPROCESSORS_CONF;
    field public static final int _SC_NPROCESSORS_ONLN;
    field public static final int _SC_OPEN_MAX;
    field public static final int _SC_PAGESIZE;
    field public static final int _SC_PAGE_SIZE;
    field public static final int _SC_PASS_MAX;
    field public static final int _SC_PHYS_PAGES;
    field public static final int _SC_PRIORITIZED_IO;
    field public static final int _SC_PRIORITY_SCHEDULING;
    field public static final int _SC_REALTIME_SIGNALS;
    field public static final int _SC_RE_DUP_MAX;
    field public static final int _SC_RTSIG_MAX;
    field public static final int _SC_SAVED_IDS;
    field public static final int _SC_SEMAPHORES;
    field public static final int _SC_SEM_NSEMS_MAX;
    field public static final int _SC_SEM_VALUE_MAX;
    field public static final int _SC_SHARED_MEMORY_OBJECTS;
    field public static final int _SC_SIGQUEUE_MAX;
    field public static final int _SC_STREAM_MAX;
    field public static final int _SC_SYNCHRONIZED_IO;
    field public static final int _SC_THREADS;
    field public static final int _SC_THREAD_ATTR_STACKADDR;
    field public static final int _SC_THREAD_ATTR_STACKSIZE;
    field public static final int _SC_THREAD_DESTRUCTOR_ITERATIONS;
    field public static final int _SC_THREAD_KEYS_MAX;
    field public static final int _SC_THREAD_PRIORITY_SCHEDULING;
    field public static final int _SC_THREAD_PRIO_INHERIT;
    field public static final int _SC_THREAD_PRIO_PROTECT;
    field public static final int _SC_THREAD_SAFE_FUNCTIONS;
    field public static final int _SC_THREAD_STACK_MIN;
    field public static final int _SC_THREAD_THREADS_MAX;
    field public static final int _SC_TIMERS;
    field public static final int _SC_TIMER_MAX;
    field public static final int _SC_TTY_NAME_MAX;
    field public static final int _SC_TZNAME_MAX;
    field public static final int _SC_VERSION;
    field public static final int _SC_XBS5_ILP32_OFF32;
    field public static final int _SC_XBS5_ILP32_OFFBIG;
    field public static final int _SC_XBS5_LP64_OFF64;
    field public static final int _SC_XBS5_LPBIG_OFFBIG;
    field public static final int _SC_XOPEN_CRYPT;
    field public static final int _SC_XOPEN_ENH_I18N;
    field public static final int _SC_XOPEN_LEGACY;
    field public static final int _SC_XOPEN_REALTIME;
    field public static final int _SC_XOPEN_REALTIME_THREADS;
    field public static final int _SC_XOPEN_SHM;
    field public static final int _SC_XOPEN_UNIX;
    field public static final int _SC_XOPEN_VERSION;
    field public static final int _SC_XOPEN_XCU_VERSION;
  }

  public final class StructCmsghdr {
    ctor public StructCmsghdr(int, int, short);
    ctor public StructCmsghdr(int, int, @NonNull byte[]);
    field @NonNull public final byte[] cmsg_data;
    field public final int cmsg_level;
    field public final int cmsg_type;
  }

  public final class StructMsghdr {
    ctor public StructMsghdr(@Nullable java.net.SocketAddress, @NonNull java.nio.ByteBuffer[], @Nullable android.system.StructCmsghdr[], int);
    field @Nullable public android.system.StructCmsghdr[] msg_control;
    field public int msg_flags;
    field @NonNull public final java.nio.ByteBuffer[] msg_iov;
    field @Nullable public java.net.SocketAddress msg_name;
  }

  public final class StructPollfd {
    ctor public StructPollfd();
    field public short events;
    field public java.io.FileDescriptor fd;
    field public short revents;
    field public Object userData;
  }

  public final class StructStat {
    ctor public StructStat(long, long, int, long, int, int, long, long, long, long, long, long, long);
    ctor public StructStat(long, long, int, long, int, int, long, long, android.system.StructTimespec, android.system.StructTimespec, android.system.StructTimespec, long, long);
    field public final android.system.StructTimespec st_atim;
    field public final long st_atime;
    field public final long st_blksize;
    field public final long st_blocks;
    field public final android.system.StructTimespec st_ctim;
    field public final long st_ctime;
    field public final long st_dev;
    field public final int st_gid;
    field public final long st_ino;
    field public final int st_mode;
    field public final android.system.StructTimespec st_mtim;
    field public final long st_mtime;
    field public final long st_nlink;
    field public final long st_rdev;
    field public final long st_size;
    field public final int st_uid;
  }

  public final class StructStatVfs {
    ctor public StructStatVfs(long, long, long, long, long, long, long, long, long, long, long);
    field public final long f_bavail;
    field public final long f_bfree;
    field public final long f_blocks;
    field public final long f_bsize;
    field public final long f_favail;
    field public final long f_ffree;
    field public final long f_files;
    field public final long f_flag;
    field public final long f_frsize;
    field public final long f_fsid;
    field public final long f_namemax;
  }

  public final class StructTimespec implements java.lang.Comparable<android.system.StructTimespec> {
    ctor public StructTimespec(long, long);
    method public int compareTo(android.system.StructTimespec);
    field public final long tv_nsec;
    field public final long tv_sec;
  }

  public final class StructTimeval {
    method @NonNull public static android.system.StructTimeval fromMillis(long);
    method public long toMillis();
    field public final long tv_sec;
    field public final long tv_usec;
  }

  public final class StructUtsname {
    ctor public StructUtsname(String, String, String, String, String);
    field public final String machine;
    field public final String nodename;
    field public final String release;
    field public final String sysname;
    field public final String version;
  }

  public final class SystemCleaner {
    method @NonNull public static java.lang.ref.Cleaner cleaner();
  }

  public final class VmSocketAddress extends java.net.SocketAddress {
    ctor public VmSocketAddress(int, int);
    method public int getSvmCid();
    method public int getSvmPort();
  }

}

package dalvik.annotation {

  @Deprecated @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) @java.lang.annotation.Target({java.lang.annotation.ElementType.ANNOTATION_TYPE}) public @interface TestTarget {
    method @Deprecated public abstract String conceptName() default "";
    method @Deprecated public abstract Class<?>[] methodArgs() default {};
    method @Deprecated public abstract String methodName() default "";
  }

  @Deprecated @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) @java.lang.annotation.Target({java.lang.annotation.ElementType.TYPE}) public @interface TestTargetClass {
    method @Deprecated public abstract Class<?> value();
  }

}

package dalvik.annotation.optimization {

  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) @java.lang.annotation.Target(java.lang.annotation.ElementType.METHOD) public @interface CriticalNative {
  }

  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) @java.lang.annotation.Target(java.lang.annotation.ElementType.METHOD) public @interface FastNative {
  }

}

package dalvik.bytecode {

  public final class OpcodeInfo {
    field public static final int MAXIMUM_PACKED_VALUE;
    field public static final int MAXIMUM_VALUE;
  }

  public interface Opcodes {
    field public static final int OP_ADD_DOUBLE = 171; // 0xab
    field public static final int OP_ADD_DOUBLE_2ADDR = 203; // 0xcb
    field public static final int OP_ADD_FLOAT = 166; // 0xa6
    field public static final int OP_ADD_FLOAT_2ADDR = 198; // 0xc6
    field public static final int OP_ADD_INT = 144; // 0x90
    field public static final int OP_ADD_INT_2ADDR = 176; // 0xb0
    field public static final int OP_ADD_INT_LIT16 = 208; // 0xd0
    field public static final int OP_ADD_INT_LIT8 = 216; // 0xd8
    field public static final int OP_ADD_LONG = 155; // 0x9b
    field public static final int OP_ADD_LONG_2ADDR = 187; // 0xbb
    field public static final int OP_AGET = 68; // 0x44
    field public static final int OP_AGET_BOOLEAN = 71; // 0x47
    field public static final int OP_AGET_BYTE = 72; // 0x48
    field public static final int OP_AGET_CHAR = 73; // 0x49
    field public static final int OP_AGET_OBJECT = 70; // 0x46
    field public static final int OP_AGET_SHORT = 74; // 0x4a
    field public static final int OP_AGET_WIDE = 69; // 0x45
    field public static final int OP_AND_INT = 149; // 0x95
    field public static final int OP_AND_INT_2ADDR = 181; // 0xb5
    field public static final int OP_AND_INT_LIT16 = 213; // 0xd5
    field public static final int OP_AND_INT_LIT8 = 221; // 0xdd
    field public static final int OP_AND_LONG = 160; // 0xa0
    field public static final int OP_AND_LONG_2ADDR = 192; // 0xc0
    field public static final int OP_APUT = 75; // 0x4b
    field public static final int OP_APUT_BOOLEAN = 78; // 0x4e
    field public static final int OP_APUT_BYTE = 79; // 0x4f
    field public static final int OP_APUT_CHAR = 80; // 0x50
    field public static final int OP_APUT_OBJECT = 77; // 0x4d
    field public static final int OP_APUT_SHORT = 81; // 0x51
    field public static final int OP_APUT_WIDE = 76; // 0x4c
    field public static final int OP_ARRAY_LENGTH = 33; // 0x21
    field @Deprecated public static final int OP_BREAKPOINT = 236; // 0xec
    field public static final int OP_CHECK_CAST = 31; // 0x1f
    field public static final int OP_CHECK_CAST_JUMBO = 511; // 0x1ff
    field public static final int OP_CMPG_DOUBLE = 48; // 0x30
    field public static final int OP_CMPG_FLOAT = 46; // 0x2e
    field public static final int OP_CMPL_DOUBLE = 47; // 0x2f
    field public static final int OP_CMPL_FLOAT = 45; // 0x2d
    field public static final int OP_CMP_LONG = 49; // 0x31
    field public static final int OP_CONST = 20; // 0x14
    field public static final int OP_CONST_16 = 19; // 0x13
    field public static final int OP_CONST_4 = 18; // 0x12
    field public static final int OP_CONST_CLASS = 28; // 0x1c
    field public static final int OP_CONST_CLASS_JUMBO = 255; // 0xff
    field public static final int OP_CONST_HIGH16 = 21; // 0x15
    field public static final int OP_CONST_METHOD_HANDLE = 254; // 0xfe
    field public static final int OP_CONST_METHOD_TYPE = 255; // 0xff
    field public static final int OP_CONST_STRING = 26; // 0x1a
    field public static final int OP_CONST_STRING_JUMBO = 27; // 0x1b
    field public static final int OP_CONST_WIDE = 24; // 0x18
    field public static final int OP_CONST_WIDE_16 = 22; // 0x16
    field public static final int OP_CONST_WIDE_32 = 23; // 0x17
    field public static final int OP_CONST_WIDE_HIGH16 = 25; // 0x19
    field public static final int OP_DIV_DOUBLE = 174; // 0xae
    field public static final int OP_DIV_DOUBLE_2ADDR = 206; // 0xce
    field public static final int OP_DIV_FLOAT = 169; // 0xa9
    field public static final int OP_DIV_FLOAT_2ADDR = 201; // 0xc9
    field public static final int OP_DIV_INT = 147; // 0x93
    field public static final int OP_DIV_INT_2ADDR = 179; // 0xb3
    field public static final int OP_DIV_INT_LIT16 = 211; // 0xd3
    field public static final int OP_DIV_INT_LIT8 = 219; // 0xdb
    field public static final int OP_DIV_LONG = 158; // 0x9e
    field public static final int OP_DIV_LONG_2ADDR = 190; // 0xbe
    field public static final int OP_DOUBLE_TO_FLOAT = 140; // 0x8c
    field public static final int OP_DOUBLE_TO_INT = 138; // 0x8a
    field public static final int OP_DOUBLE_TO_LONG = 139; // 0x8b
    field @Deprecated public static final int OP_EXECUTE_INLINE = 238; // 0xee
    field @Deprecated public static final int OP_EXECUTE_INLINE_RANGE = 239; // 0xef
    field public static final int OP_FILLED_NEW_ARRAY = 36; // 0x24
    field public static final int OP_FILLED_NEW_ARRAY_JUMBO = 1535; // 0x5ff
    field public static final int OP_FILLED_NEW_ARRAY_RANGE = 37; // 0x25
    field public static final int OP_FILL_ARRAY_DATA = 38; // 0x26
    field public static final int OP_FLOAT_TO_DOUBLE = 137; // 0x89
    field public static final int OP_FLOAT_TO_INT = 135; // 0x87
    field public static final int OP_FLOAT_TO_LONG = 136; // 0x88
    field public static final int OP_GOTO = 40; // 0x28
    field public static final int OP_GOTO_16 = 41; // 0x29
    field public static final int OP_GOTO_32 = 42; // 0x2a
    field public static final int OP_IF_EQ = 50; // 0x32
    field public static final int OP_IF_EQZ = 56; // 0x38
    field public static final int OP_IF_GE = 53; // 0x35
    field public static final int OP_IF_GEZ = 59; // 0x3b
    field public static final int OP_IF_GT = 54; // 0x36
    field public static final int OP_IF_GTZ = 60; // 0x3c
    field public static final int OP_IF_LE = 55; // 0x37
    field public static final int OP_IF_LEZ = 61; // 0x3d
    field public static final int OP_IF_LT = 52; // 0x34
    field public static final int OP_IF_LTZ = 58; // 0x3a
    field public static final int OP_IF_NE = 51; // 0x33
    field public static final int OP_IF_NEZ = 57; // 0x39
    field public static final int OP_IGET = 82; // 0x52
    field public static final int OP_IGET_BOOLEAN = 85; // 0x55
    field public static final int OP_IGET_BOOLEAN_JUMBO = 2559; // 0x9ff
    field public static final int OP_IGET_BYTE = 86; // 0x56
    field public static final int OP_IGET_BYTE_JUMBO = 2815; // 0xaff
    field public static final int OP_IGET_CHAR = 87; // 0x57
    field public static final int OP_IGET_CHAR_JUMBO = 3071; // 0xbff
    field public static final int OP_IGET_JUMBO = 1791; // 0x6ff
    field public static final int OP_IGET_OBJECT = 84; // 0x54
    field public static final int OP_IGET_OBJECT_JUMBO = 2303; // 0x8ff
    field @Deprecated public static final int OP_IGET_OBJECT_QUICK = 244; // 0xf4
    field @Deprecated public static final int OP_IGET_QUICK = 242; // 0xf2
    field public static final int OP_IGET_SHORT = 88; // 0x58
    field public static final int OP_IGET_SHORT_JUMBO = 3327; // 0xcff
    field public static final int OP_IGET_WIDE = 83; // 0x53
    field public static final int OP_IGET_WIDE_JUMBO = 2047; // 0x7ff
    field @Deprecated public static final int OP_IGET_WIDE_QUICK = 243; // 0xf3
    field @Deprecated public static final int OP_IGET_WIDE_VOLATILE = 232; // 0xe8
    field public static final int OP_INSTANCE_OF = 32; // 0x20
    field public static final int OP_INSTANCE_OF_JUMBO = 767; // 0x2ff
    field public static final int OP_INT_TO_BYTE = 141; // 0x8d
    field public static final int OP_INT_TO_CHAR = 142; // 0x8e
    field public static final int OP_INT_TO_DOUBLE = 131; // 0x83
    field public static final int OP_INT_TO_FLOAT = 130; // 0x82
    field public static final int OP_INT_TO_LONG = 129; // 0x81
    field public static final int OP_INT_TO_SHORT = 143; // 0x8f
    field public static final int OP_INVOKE_CUSTOM = 252; // 0xfc
    field public static final int OP_INVOKE_CUSTOM_RANGE = 253; // 0xfd
    field public static final int OP_INVOKE_DIRECT = 112; // 0x70
    field @Deprecated public static final int OP_INVOKE_DIRECT_EMPTY = 240; // 0xf0
    field public static final int OP_INVOKE_DIRECT_JUMBO = 9471; // 0x24ff
    field public static final int OP_INVOKE_DIRECT_RANGE = 118; // 0x76
    field public static final int OP_INVOKE_INTERFACE = 114; // 0x72
    field public static final int OP_INVOKE_INTERFACE_JUMBO = 9983; // 0x26ff
    field public static final int OP_INVOKE_INTERFACE_RANGE = 120; // 0x78
    field public static final int OP_INVOKE_POLYMORPHIC = 250; // 0xfa
    field public static final int OP_INVOKE_POLYMORPHIC_RANGE = 251; // 0xfb
    field public static final int OP_INVOKE_STATIC = 113; // 0x71
    field public static final int OP_INVOKE_STATIC_JUMBO = 9727; // 0x25ff
    field public static final int OP_INVOKE_STATIC_RANGE = 119; // 0x77
    field public static final int OP_INVOKE_SUPER = 111; // 0x6f
    field public static final int OP_INVOKE_SUPER_JUMBO = 9215; // 0x23ff
    field @Deprecated public static final int OP_INVOKE_SUPER_QUICK = 250; // 0xfa
    field @Deprecated public static final int OP_INVOKE_SUPER_QUICK_RANGE = 251; // 0xfb
    field public static final int OP_INVOKE_SUPER_RANGE = 117; // 0x75
    field public static final int OP_INVOKE_VIRTUAL = 110; // 0x6e
    field public static final int OP_INVOKE_VIRTUAL_JUMBO = 8959; // 0x22ff
    field @Deprecated public static final int OP_INVOKE_VIRTUAL_QUICK = 248; // 0xf8
    field @Deprecated public static final int OP_INVOKE_VIRTUAL_QUICK_RANGE = 249; // 0xf9
    field public static final int OP_INVOKE_VIRTUAL_RANGE = 116; // 0x74
    field public static final int OP_IPUT = 89; // 0x59
    field public static final int OP_IPUT_BOOLEAN = 92; // 0x5c
    field public static final int OP_IPUT_BOOLEAN_JUMBO = 4351; // 0x10ff
    field public static final int OP_IPUT_BYTE = 93; // 0x5d
    field public static final int OP_IPUT_BYTE_JUMBO = 4607; // 0x11ff
    field public static final int OP_IPUT_CHAR = 94; // 0x5e
    field public static final int OP_IPUT_CHAR_JUMBO = 4863; // 0x12ff
    field public static final int OP_IPUT_JUMBO = 3583; // 0xdff
    field public static final int OP_IPUT_OBJECT = 91; // 0x5b
    field public static final int OP_IPUT_OBJECT_JUMBO = 4095; // 0xfff
    field @Deprecated public static final int OP_IPUT_OBJECT_QUICK = 247; // 0xf7
    field @Deprecated public static final int OP_IPUT_QUICK = 245; // 0xf5
    field public static final int OP_IPUT_SHORT = 95; // 0x5f
    field public static final int OP_IPUT_SHORT_JUMBO = 5119; // 0x13ff
    field public static final int OP_IPUT_WIDE = 90; // 0x5a
    field public static final int OP_IPUT_WIDE_JUMBO = 3839; // 0xeff
    field @Deprecated public static final int OP_IPUT_WIDE_QUICK = 246; // 0xf6
    field @Deprecated public static final int OP_IPUT_WIDE_VOLATILE = 233; // 0xe9
    field public static final int OP_LONG_TO_DOUBLE = 134; // 0x86
    field public static final int OP_LONG_TO_FLOAT = 133; // 0x85
    field public static final int OP_LONG_TO_INT = 132; // 0x84
    field public static final int OP_MONITOR_ENTER = 29; // 0x1d
    field public static final int OP_MONITOR_EXIT = 30; // 0x1e
    field public static final int OP_MOVE = 1; // 0x1
    field public static final int OP_MOVE_16 = 3; // 0x3
    field public static final int OP_MOVE_EXCEPTION = 13; // 0xd
    field public static final int OP_MOVE_FROM16 = 2; // 0x2
    field public static final int OP_MOVE_OBJECT = 7; // 0x7
    field public static final int OP_MOVE_OBJECT_16 = 9; // 0x9
    field public static final int OP_MOVE_OBJECT_FROM16 = 8; // 0x8
    field public static final int OP_MOVE_RESULT = 10; // 0xa
    field public static final int OP_MOVE_RESULT_OBJECT = 12; // 0xc
    field public static final int OP_MOVE_RESULT_WIDE = 11; // 0xb
    field public static final int OP_MOVE_WIDE = 4; // 0x4
    field public static final int OP_MOVE_WIDE_16 = 6; // 0x6
    field public static final int OP_MOVE_WIDE_FROM16 = 5; // 0x5
    field public static final int OP_MUL_DOUBLE = 173; // 0xad
    field public static final int OP_MUL_DOUBLE_2ADDR = 205; // 0xcd
    field public static final int OP_MUL_FLOAT = 168; // 0xa8
    field public static final int OP_MUL_FLOAT_2ADDR = 200; // 0xc8
    field public static final int OP_MUL_INT = 146; // 0x92
    field public static final int OP_MUL_INT_2ADDR = 178; // 0xb2
    field public static final int OP_MUL_INT_LIT16 = 210; // 0xd2
    field public static final int OP_MUL_INT_LIT8 = 218; // 0xda
    field public static final int OP_MUL_LONG = 157; // 0x9d
    field public static final int OP_MUL_LONG_2ADDR = 189; // 0xbd
    field public static final int OP_NEG_DOUBLE = 128; // 0x80
    field public static final int OP_NEG_FLOAT = 127; // 0x7f
    field public static final int OP_NEG_INT = 123; // 0x7b
    field public static final int OP_NEG_LONG = 125; // 0x7d
    field public static final int OP_NEW_ARRAY = 35; // 0x23
    field public static final int OP_NEW_ARRAY_JUMBO = 1279; // 0x4ff
    field public static final int OP_NEW_INSTANCE = 34; // 0x22
    field public static final int OP_NEW_INSTANCE_JUMBO = 1023; // 0x3ff
    field public static final int OP_NOP = 0; // 0x0
    field public static final int OP_NOT_INT = 124; // 0x7c
    field public static final int OP_NOT_LONG = 126; // 0x7e
    field public static final int OP_OR_INT = 150; // 0x96
    field public static final int OP_OR_INT_2ADDR = 182; // 0xb6
    field public static final int OP_OR_INT_LIT16 = 214; // 0xd6
    field public static final int OP_OR_INT_LIT8 = 222; // 0xde
    field public static final int OP_OR_LONG = 161; // 0xa1
    field public static final int OP_OR_LONG_2ADDR = 193; // 0xc1
    field public static final int OP_PACKED_SWITCH = 43; // 0x2b
    field public static final int OP_REM_DOUBLE = 175; // 0xaf
    field public static final int OP_REM_DOUBLE_2ADDR = 207; // 0xcf
    field public static final int OP_REM_FLOAT = 170; // 0xaa
    field public static final int OP_REM_FLOAT_2ADDR = 202; // 0xca
    field public static final int OP_REM_INT = 148; // 0x94
    field public static final int OP_REM_INT_2ADDR = 180; // 0xb4
    field public static final int OP_REM_INT_LIT16 = 212; // 0xd4
    field public static final int OP_REM_INT_LIT8 = 220; // 0xdc
    field public static final int OP_REM_LONG = 159; // 0x9f
    field public static final int OP_REM_LONG_2ADDR = 191; // 0xbf
    field public static final int OP_RETURN = 15; // 0xf
    field public static final int OP_RETURN_OBJECT = 17; // 0x11
    field public static final int OP_RETURN_VOID = 14; // 0xe
    field public static final int OP_RETURN_WIDE = 16; // 0x10
    field public static final int OP_RSUB_INT = 209; // 0xd1
    field public static final int OP_RSUB_INT_LIT8 = 217; // 0xd9
    field public static final int OP_SGET = 96; // 0x60
    field public static final int OP_SGET_BOOLEAN = 99; // 0x63
    field public static final int OP_SGET_BOOLEAN_JUMBO = 6143; // 0x17ff
    field public static final int OP_SGET_BYTE = 100; // 0x64
    field public static final int OP_SGET_BYTE_JUMBO = 6399; // 0x18ff
    field public static final int OP_SGET_CHAR = 101; // 0x65
    field public static final int OP_SGET_CHAR_JUMBO = 6655; // 0x19ff
    field public static final int OP_SGET_JUMBO = 5375; // 0x14ff
    field public static final int OP_SGET_OBJECT = 98; // 0x62
    field public static final int OP_SGET_OBJECT_JUMBO = 5887; // 0x16ff
    field public static final int OP_SGET_SHORT = 102; // 0x66
    field public static final int OP_SGET_SHORT_JUMBO = 6911; // 0x1aff
    field public static final int OP_SGET_WIDE = 97; // 0x61
    field public static final int OP_SGET_WIDE_JUMBO = 5631; // 0x15ff
    field @Deprecated public static final int OP_SGET_WIDE_VOLATILE = 234; // 0xea
    field public static final int OP_SHL_INT = 152; // 0x98
    field public static final int OP_SHL_INT_2ADDR = 184; // 0xb8
    field public static final int OP_SHL_INT_LIT8 = 224; // 0xe0
    field public static final int OP_SHL_LONG = 163; // 0xa3
    field public static final int OP_SHL_LONG_2ADDR = 195; // 0xc3
    field public static final int OP_SHR_INT = 153; // 0x99
    field public static final int OP_SHR_INT_2ADDR = 185; // 0xb9
    field public static final int OP_SHR_INT_LIT8 = 225; // 0xe1
    field public static final int OP_SHR_LONG = 164; // 0xa4
    field public static final int OP_SHR_LONG_2ADDR = 196; // 0xc4
    field public static final int OP_SPARSE_SWITCH = 44; // 0x2c
    field public static final int OP_SPUT = 103; // 0x67
    field public static final int OP_SPUT_BOOLEAN = 106; // 0x6a
    field public static final int OP_SPUT_BOOLEAN_JUMBO = 7935; // 0x1eff
    field public static final int OP_SPUT_BYTE = 107; // 0x6b
    field public static final int OP_SPUT_BYTE_JUMBO = 8191; // 0x1fff
    field public static final int OP_SPUT_CHAR = 108; // 0x6c
    field public static final int OP_SPUT_CHAR_JUMBO = 8447; // 0x20ff
    field public static final int OP_SPUT_JUMBO = 7167; // 0x1bff
    field public static final int OP_SPUT_OBJECT = 105; // 0x69
    field public static final int OP_SPUT_OBJECT_JUMBO = 7679; // 0x1dff
    field public static final int OP_SPUT_SHORT = 109; // 0x6d
    field public static final int OP_SPUT_SHORT_JUMBO = 8703; // 0x21ff
    field public static final int OP_SPUT_WIDE = 104; // 0x68
    field public static final int OP_SPUT_WIDE_JUMBO = 7423; // 0x1cff
    field @Deprecated public static final int OP_SPUT_WIDE_VOLATILE = 235; // 0xeb
    field public static final int OP_SUB_DOUBLE = 172; // 0xac
    field public static final int OP_SUB_DOUBLE_2ADDR = 204; // 0xcc
    field public static final int OP_SUB_FLOAT = 167; // 0xa7
    field public static final int OP_SUB_FLOAT_2ADDR = 199; // 0xc7
    field public static final int OP_SUB_INT = 145; // 0x91
    field public static final int OP_SUB_INT_2ADDR = 177; // 0xb1
    field public static final int OP_SUB_LONG = 156; // 0x9c
    field public static final int OP_SUB_LONG_2ADDR = 188; // 0xbc
    field public static final int OP_THROW = 39; // 0x27
    field @Deprecated public static final int OP_THROW_VERIFICATION_ERROR = 237; // 0xed
    field public static final int OP_USHR_INT = 154; // 0x9a
    field public static final int OP_USHR_INT_2ADDR = 186; // 0xba
    field public static final int OP_USHR_INT_LIT8 = 226; // 0xe2
    field public static final int OP_USHR_LONG = 165; // 0xa5
    field public static final int OP_USHR_LONG_2ADDR = 197; // 0xc5
    field public static final int OP_XOR_INT = 151; // 0x97
    field public static final int OP_XOR_INT_2ADDR = 183; // 0xb7
    field public static final int OP_XOR_INT_LIT16 = 215; // 0xd7
    field public static final int OP_XOR_INT_LIT8 = 223; // 0xdf
    field public static final int OP_XOR_LONG = 162; // 0xa2
    field public static final int OP_XOR_LONG_2ADDR = 194; // 0xc2
  }

}

package dalvik.system {

  public final class ApplicationRuntime {
    method @NonNull public static dalvik.system.DexFile.OptimizationInfo getBaseApkOptimizationInfo();
  }

  public class BaseDexClassLoader extends java.lang.ClassLoader {
    ctor public BaseDexClassLoader(String, java.io.File, String, ClassLoader);
    method public String findLibrary(String);
    method protected java.util.Enumeration<java.net.URL> findResources(String);
  }

  public final class DelegateLastClassLoader extends dalvik.system.PathClassLoader {
    ctor public DelegateLastClassLoader(String, ClassLoader);
    ctor public DelegateLastClassLoader(String, String, ClassLoader);
    ctor public DelegateLastClassLoader(@NonNull String, @Nullable String, @Nullable ClassLoader, boolean);
  }

  public class DexClassLoader extends dalvik.system.BaseDexClassLoader {
    ctor public DexClassLoader(String, String, String, ClassLoader);
  }

  public final class DexFile {
    ctor @Deprecated public DexFile(java.io.File) throws java.io.IOException;
    ctor @Deprecated public DexFile(String) throws java.io.IOException;
    method @Deprecated public void close() throws java.io.IOException;
    method @Deprecated public java.util.Enumeration<java.lang.String> entries();
    method @Deprecated public String getName();
    method @Deprecated public static boolean isDexOptNeeded(String) throws java.io.FileNotFoundException, java.io.IOException;
    method @Deprecated public Class loadClass(String, ClassLoader);
    method @Deprecated public static dalvik.system.DexFile loadDex(String, String, int) throws java.io.IOException;
  }

  public static final class DexFile.OptimizationInfo {
    method public boolean isFullyCompiled();
    method public boolean isOptimized();
    method public boolean isVerified();
  }

  public final class InMemoryDexClassLoader extends dalvik.system.BaseDexClassLoader {
    ctor public InMemoryDexClassLoader(@NonNull java.nio.ByteBuffer[], @Nullable String, @Nullable ClassLoader);
    ctor public InMemoryDexClassLoader(@NonNull java.nio.ByteBuffer[], @Nullable ClassLoader);
    ctor public InMemoryDexClassLoader(@NonNull java.nio.ByteBuffer, @Nullable ClassLoader);
  }

  public class PathClassLoader extends dalvik.system.BaseDexClassLoader {
    ctor public PathClassLoader(String, ClassLoader);
    ctor public PathClassLoader(String, String, ClassLoader);
  }

  public final class ZipPathValidator {
    method public static void clearCallback();
    method public static void setCallback(@NonNull dalvik.system.ZipPathValidator.Callback);
  }

  public static interface ZipPathValidator.Callback {
    method public default void onZipEntryAccess(@NonNull String) throws java.util.zip.ZipException;
  }

}

package java.awt.font {

  public final class NumericShaper implements java.io.Serializable {
    method public static java.awt.font.NumericShaper getContextualShaper(int);
    method public static java.awt.font.NumericShaper getContextualShaper(java.util.Set<java.awt.font.NumericShaper.Range>);
    method public static java.awt.font.NumericShaper getContextualShaper(int, int);
    method public static java.awt.font.NumericShaper getContextualShaper(java.util.Set<java.awt.font.NumericShaper.Range>, java.awt.font.NumericShaper.Range);
    method public java.util.Set<java.awt.font.NumericShaper.Range> getRangeSet();
    method public int getRanges();
    method public static java.awt.font.NumericShaper getShaper(int);
    method public static java.awt.font.NumericShaper getShaper(java.awt.font.NumericShaper.Range);
    method public boolean isContextual();
    method public void shape(char[], int, int);
    method public void shape(char[], int, int, int);
    method public void shape(char[], int, int, java.awt.font.NumericShaper.Range);
    field public static final int ALL_RANGES = 524287; // 0x7ffff
    field public static final int ARABIC = 2; // 0x2
    field public static final int BENGALI = 16; // 0x10
    field public static final int DEVANAGARI = 8; // 0x8
    field public static final int EASTERN_ARABIC = 4; // 0x4
    field public static final int ETHIOPIC = 65536; // 0x10000
    field public static final int EUROPEAN = 1; // 0x1
    field public static final int GUJARATI = 64; // 0x40
    field public static final int GURMUKHI = 32; // 0x20
    field public static final int KANNADA = 1024; // 0x400
    field public static final int KHMER = 131072; // 0x20000
    field public static final int LAO = 8192; // 0x2000
    field public static final int MALAYALAM = 2048; // 0x800
    field public static final int MONGOLIAN = 262144; // 0x40000
    field public static final int MYANMAR = 32768; // 0x8000
    field public static final int ORIYA = 128; // 0x80
    field public static final int TAMIL = 256; // 0x100
    field public static final int TELUGU = 512; // 0x200
    field public static final int THAI = 4096; // 0x1000
    field public static final int TIBETAN = 16384; // 0x4000
  }

  public enum NumericShaper.Range {
    enum_constant public static final java.awt.font.NumericShaper.Range ARABIC;
    enum_constant public static final java.awt.font.NumericShaper.Range BALINESE;
    enum_constant public static final java.awt.font.NumericShaper.Range BENGALI;
    enum_constant public static final java.awt.font.NumericShaper.Range CHAM;
    enum_constant public static final java.awt.font.NumericShaper.Range DEVANAGARI;
    enum_constant public static final java.awt.font.NumericShaper.Range EASTERN_ARABIC;
    enum_constant public static final java.awt.font.NumericShaper.Range ETHIOPIC;
    enum_constant public static final java.awt.font.NumericShaper.Range EUROPEAN;
    enum_constant public static final java.awt.font.NumericShaper.Range GUJARATI;
    enum_constant public static final java.awt.font.NumericShaper.Range GURMUKHI;
    enum_constant public static final java.awt.font.NumericShaper.Range JAVANESE;
    enum_constant public static final java.awt.font.NumericShaper.Range KANNADA;
    enum_constant public static final java.awt.font.NumericShaper.Range KAYAH_LI;
    enum_constant public static final java.awt.font.NumericShaper.Range KHMER;
    enum_constant public static final java.awt.font.NumericShaper.Range LAO;
    enum_constant public static final java.awt.font.NumericShaper.Range LEPCHA;
    enum_constant public static final java.awt.font.NumericShaper.Range LIMBU;
    enum_constant public static final java.awt.font.NumericShaper.Range MALAYALAM;
    enum_constant public static final java.awt.font.NumericShaper.Range MEETEI_MAYEK;
    enum_constant public static final java.awt.font.NumericShaper.Range MONGOLIAN;
    enum_constant public static final java.awt.font.NumericShaper.Range MYANMAR;
    enum_constant public static final java.awt.font.NumericShaper.Range MYANMAR_SHAN;
    enum_constant public static final java.awt.font.NumericShaper.Range NEW_TAI_LUE;
    enum_constant public static final java.awt.font.NumericShaper.Range NKO;
    enum_constant public static final java.awt.font.NumericShaper.Range OL_CHIKI;
    enum_constant public static final java.awt.font.NumericShaper.Range ORIYA;
    enum_constant public static final java.awt.font.NumericShaper.Range SAURASHTRA;
    enum_constant public static final java.awt.font.NumericShaper.Range SUNDANESE;
    enum_constant public static final java.awt.font.NumericShaper.Range TAI_THAM_HORA;
    enum_constant public static final java.awt.font.NumericShaper.Range TAI_THAM_THAM;
    enum_constant public static final java.awt.font.NumericShaper.Range TAMIL;
    enum_constant public static final java.awt.font.NumericShaper.Range TELUGU;
    enum_constant public static final java.awt.font.NumericShaper.Range THAI;
    enum_constant public static final java.awt.font.NumericShaper.Range TIBETAN;
    enum_constant public static final java.awt.font.NumericShaper.Range VAI;
  }

  public final class TextAttribute extends java.text.AttributedCharacterIterator.Attribute {
    ctor protected TextAttribute(String);
    field public static final java.awt.font.TextAttribute BACKGROUND;
    field public static final java.awt.font.TextAttribute BIDI_EMBEDDING;
    field public static final java.awt.font.TextAttribute CHAR_REPLACEMENT;
    field public static final java.awt.font.TextAttribute FAMILY;
    field public static final java.awt.font.TextAttribute FONT;
    field public static final java.awt.font.TextAttribute FOREGROUND;
    field public static final java.awt.font.TextAttribute INPUT_METHOD_HIGHLIGHT;
    field public static final java.awt.font.TextAttribute INPUT_METHOD_UNDERLINE;
    field public static final java.awt.font.TextAttribute JUSTIFICATION;
    field public static final Float JUSTIFICATION_FULL;
    field public static final Float JUSTIFICATION_NONE;
    field public static final java.awt.font.TextAttribute KERNING;
    field public static final Integer KERNING_ON;
    field public static final java.awt.font.TextAttribute LIGATURES;
    field public static final Integer LIGATURES_ON;
    field public static final java.awt.font.TextAttribute NUMERIC_SHAPING;
    field public static final java.awt.font.TextAttribute POSTURE;
    field public static final Float POSTURE_OBLIQUE;
    field public static final Float POSTURE_REGULAR;
    field public static final java.awt.font.TextAttribute RUN_DIRECTION;
    field public static final Boolean RUN_DIRECTION_LTR;
    field public static final Boolean RUN_DIRECTION_RTL;
    field public static final java.awt.font.TextAttribute SIZE;
    field public static final java.awt.font.TextAttribute STRIKETHROUGH;
    field public static final Boolean STRIKETHROUGH_ON;
    field public static final java.awt.font.TextAttribute SUPERSCRIPT;
    field public static final Integer SUPERSCRIPT_SUB;
    field public static final Integer SUPERSCRIPT_SUPER;
    field public static final java.awt.font.TextAttribute SWAP_COLORS;
    field public static final Boolean SWAP_COLORS_ON;
    field public static final java.awt.font.TextAttribute TRACKING;
    field public static final Float TRACKING_LOOSE;
    field public static final Float TRACKING_TIGHT;
    field public static final java.awt.font.TextAttribute TRANSFORM;
    field public static final java.awt.font.TextAttribute UNDERLINE;
    field public static final Integer UNDERLINE_LOW_DASHED;
    field public static final Integer UNDERLINE_LOW_DOTTED;
    field public static final Integer UNDERLINE_LOW_GRAY;
    field public static final Integer UNDERLINE_LOW_ONE_PIXEL;
    field public static final Integer UNDERLINE_LOW_TWO_PIXEL;
    field public static final Integer UNDERLINE_ON;
    field public static final java.awt.font.TextAttribute WEIGHT;
    field public static final Float WEIGHT_BOLD;
    field public static final Float WEIGHT_DEMIBOLD;
    field public static final Float WEIGHT_DEMILIGHT;
    field public static final Float WEIGHT_EXTRABOLD;
    field public static final Float WEIGHT_EXTRA_LIGHT;
    field public static final Float WEIGHT_HEAVY;
    field public static final Float WEIGHT_LIGHT;
    field public static final Float WEIGHT_MEDIUM;
    field public static final Float WEIGHT_REGULAR;
    field public static final Float WEIGHT_SEMIBOLD;
    field public static final Float WEIGHT_ULTRABOLD;
    field public static final java.awt.font.TextAttribute WIDTH;
    field public static final Float WIDTH_CONDENSED;
    field public static final Float WIDTH_EXTENDED;
    field public static final Float WIDTH_REGULAR;
    field public static final Float WIDTH_SEMI_CONDENSED;
    field public static final Float WIDTH_SEMI_EXTENDED;
  }

}

package java.beans {

  public class IndexedPropertyChangeEvent extends java.beans.PropertyChangeEvent {
    ctor public IndexedPropertyChangeEvent(Object, String, Object, Object, int);
    method public int getIndex();
  }

  public class PropertyChangeEvent extends java.util.EventObject {
    ctor public PropertyChangeEvent(Object, String, Object, Object);
    method public Object getNewValue();
    method public Object getOldValue();
    method public Object getPropagationId();
    method public String getPropertyName();
    method public void setPropagationId(Object);
  }

  public interface PropertyChangeListener extends java.util.EventListener {
    method public void propertyChange(java.beans.PropertyChangeEvent);
  }

  public class PropertyChangeListenerProxy extends java.util.EventListenerProxy<java.beans.PropertyChangeListener> implements java.beans.PropertyChangeListener {
    ctor public PropertyChangeListenerProxy(String, java.beans.PropertyChangeListener);
    method public String getPropertyName();
    method public void propertyChange(java.beans.PropertyChangeEvent);
  }

  public class PropertyChangeSupport implements java.io.Serializable {
    ctor public PropertyChangeSupport(Object);
    method public void addPropertyChangeListener(java.beans.PropertyChangeListener);
    method public void addPropertyChangeListener(String, java.beans.PropertyChangeListener);
    method public void fireIndexedPropertyChange(String, int, Object, Object);
    method public void fireIndexedPropertyChange(String, int, int, int);
    method public void fireIndexedPropertyChange(String, int, boolean, boolean);
    method public void firePropertyChange(String, Object, Object);
    method public void firePropertyChange(String, int, int);
    method public void firePropertyChange(String, boolean, boolean);
    method public void firePropertyChange(java.beans.PropertyChangeEvent);
    method public java.beans.PropertyChangeListener[] getPropertyChangeListeners();
    method public java.beans.PropertyChangeListener[] getPropertyChangeListeners(String);
    method public boolean hasListeners(String);
    method public void removePropertyChangeListener(java.beans.PropertyChangeListener);
    method public void removePropertyChangeListener(String, java.beans.PropertyChangeListener);
  }

}

package java.io {

  public class BufferedInputStream extends java.io.FilterInputStream {
    ctor public BufferedInputStream(java.io.InputStream);
    ctor public BufferedInputStream(java.io.InputStream, int);
    field protected volatile byte[] buf;
    field protected int count;
    field protected int marklimit;
    field protected int markpos;
    field protected int pos;
  }

  public class BufferedOutputStream extends java.io.FilterOutputStream {
    ctor public BufferedOutputStream(java.io.OutputStream);
    ctor public BufferedOutputStream(java.io.OutputStream, int);
    field protected byte[] buf;
    field protected int count;
  }

  public class BufferedReader extends java.io.Reader {
    ctor public BufferedReader(java.io.Reader, int);
    ctor public BufferedReader(java.io.Reader);
    method public void close() throws java.io.IOException;
    method public java.util.stream.Stream<java.lang.String> lines();
    method public int read(char[], int, int) throws java.io.IOException;
    method public String readLine() throws java.io.IOException;
  }

  public class BufferedWriter extends java.io.Writer {
    ctor public BufferedWriter(java.io.Writer);
    ctor public BufferedWriter(java.io.Writer, int);
    method public void close() throws java.io.IOException;
    method public void flush() throws java.io.IOException;
    method public void newLine() throws java.io.IOException;
    method public void write(char[], int, int) throws java.io.IOException;
  }

  public class ByteArrayInputStream extends java.io.InputStream {
    ctor public ByteArrayInputStream(byte[]);
    ctor public ByteArrayInputStream(byte[], int, int);
    method public int available();
    method public int read();
    method public int read(byte[], int, int);
    method public byte[] readAllBytes();
    method public int readNBytes(byte[], int, int);
    method public void reset();
    method public long skip(long);
    field protected byte[] buf;
    field protected int count;
    field protected int mark;
    field protected int pos;
  }

  public class ByteArrayOutputStream extends java.io.OutputStream {
    ctor public ByteArrayOutputStream();
    ctor public ByteArrayOutputStream(int);
    method public void reset();
    method public int size();
    method @NonNull public byte[] toByteArray();
    method @NonNull public String toString(@NonNull String) throws java.io.UnsupportedEncodingException;
    method @NonNull public String toString(@NonNull java.nio.charset.Charset);
    method @Deprecated @NonNull public String toString(int);
    method public void write(int);
    method public void write(@NonNull byte[], int, int);
    method public void writeBytes(byte[]);
    method public void writeTo(@NonNull java.io.OutputStream) throws java.io.IOException;
    field @NonNull protected byte[] buf;
    field protected int count;
  }

  public class CharArrayReader extends java.io.Reader {
    ctor public CharArrayReader(char[]);
    ctor public CharArrayReader(char[], int, int);
    method public void close();
    method public int read(char[], int, int) throws java.io.IOException;
    field protected char[] buf;
    field protected int count;
    field protected int markedPos;
    field protected int pos;
  }

  public class CharArrayWriter extends java.io.Writer {
    ctor public CharArrayWriter();
    ctor public CharArrayWriter(int);
    method public java.io.CharArrayWriter append(CharSequence);
    method public java.io.CharArrayWriter append(CharSequence, int, int);
    method public java.io.CharArrayWriter append(char);
    method public void close();
    method public void flush();
    method public void reset();
    method public int size();
    method public char[] toCharArray();
    method public void write(int);
    method public void write(char[], int, int);
    method public void write(String, int, int);
    method public void writeTo(java.io.Writer) throws java.io.IOException;
    field protected char[] buf;
    field protected int count;
  }

  public class CharConversionException extends java.io.IOException {
    ctor public CharConversionException();
    ctor public CharConversionException(String);
  }

  public interface Closeable extends java.lang.AutoCloseable {
    method public void close() throws java.io.IOException;
  }

  public final class Console implements java.io.Flushable {
    method public void flush();
    method public java.io.Console format(String, java.lang.Object...);
    method public java.io.Console printf(String, java.lang.Object...);
    method public String readLine(String, java.lang.Object...);
    method public String readLine();
    method public char[] readPassword(String, java.lang.Object...);
    method public char[] readPassword();
    method public java.io.Reader reader();
    method public java.io.PrintWriter writer();
  }

  public interface DataInput {
    method public boolean readBoolean() throws java.io.IOException;
    method public byte readByte() throws java.io.IOException;
    method public char readChar() throws java.io.IOException;
    method public double readDouble() throws java.io.IOException;
    method public float readFloat() throws java.io.IOException;
    method public void readFully(byte[]) throws java.io.IOException;
    method public void readFully(byte[], int, int) throws java.io.IOException;
    method public int readInt() throws java.io.IOException;
    method public String readLine() throws java.io.IOException;
    method public long readLong() throws java.io.IOException;
    method public short readShort() throws java.io.IOException;
    method public String readUTF() throws java.io.IOException;
    method public int readUnsignedByte() throws java.io.IOException;
    method public int readUnsignedShort() throws java.io.IOException;
    method public int skipBytes(int) throws java.io.IOException;
  }

  public class DataInputStream extends java.io.FilterInputStream implements java.io.DataInput {
    ctor public DataInputStream(java.io.InputStream);
    method public final int read(byte[]) throws java.io.IOException;
    method public final int read(byte[], int, int) throws java.io.IOException;
    method public final boolean readBoolean() throws java.io.IOException;
    method public final byte readByte() throws java.io.IOException;
    method public final char readChar() throws java.io.IOException;
    method public final double readDouble() throws java.io.IOException;
    method public final float readFloat() throws java.io.IOException;
    method public final void readFully(byte[]) throws java.io.IOException;
    method public final void readFully(byte[], int, int) throws java.io.IOException;
    method public final int readInt() throws java.io.IOException;
    method @Deprecated public final String readLine() throws java.io.IOException;
    method public final long readLong() throws java.io.IOException;
    method public final short readShort() throws java.io.IOException;
    method public final String readUTF() throws java.io.IOException;
    method public static final String readUTF(java.io.DataInput) throws java.io.IOException;
    method public final int readUnsignedByte() throws java.io.IOException;
    method public final int readUnsignedShort() throws java.io.IOException;
    method public final int skipBytes(int) throws java.io.IOException;
  }

  public interface DataOutput {
    method public void write(int) throws java.io.IOException;
    method public void write(byte[]) throws java.io.IOException;
    method public void write(byte[], int, int) throws java.io.IOException;
    method public void writeBoolean(boolean) throws java.io.IOException;
    method public void writeByte(int) throws java.io.IOException;
    method public void writeBytes(String) throws java.io.IOException;
    method public void writeChar(int) throws java.io.IOException;
    method public void writeChars(String) throws java.io.IOException;
    method public void writeDouble(double) throws java.io.IOException;
    method public void writeFloat(float) throws java.io.IOException;
    method public void writeInt(int) throws java.io.IOException;
    method public void writeLong(long) throws java.io.IOException;
    method public void writeShort(int) throws java.io.IOException;
    method public void writeUTF(String) throws java.io.IOException;
  }

  public class DataOutputStream extends java.io.FilterOutputStream implements java.io.DataOutput {
    ctor public DataOutputStream(java.io.OutputStream);
    method public final int size();
    method public final void writeBoolean(boolean) throws java.io.IOException;
    method public final void writeByte(int) throws java.io.IOException;
    method public final void writeBytes(String) throws java.io.IOException;
    method public final void writeChar(int) throws java.io.IOException;
    method public final void writeChars(String) throws java.io.IOException;
    method public final void writeDouble(double) throws java.io.IOException;
    method public final void writeFloat(float) throws java.io.IOException;
    method public final void writeInt(int) throws java.io.IOException;
    method public final void writeLong(long) throws java.io.IOException;
    method public final void writeShort(int) throws java.io.IOException;
    method public final void writeUTF(String) throws java.io.IOException;
    field protected int written;
  }

  public class EOFException extends java.io.IOException {
    ctor public EOFException();
    ctor public EOFException(String);
  }

  public interface Externalizable extends java.io.Serializable {
    method public void readExternal(java.io.ObjectInput) throws java.lang.ClassNotFoundException, java.io.IOException;
    method public void writeExternal(java.io.ObjectOutput) throws java.io.IOException;
  }

  public class File implements java.lang.Comparable<java.io.File> java.io.Serializable {
    ctor public File(@NonNull String);
    ctor public File(@Nullable String, @NonNull String);
    ctor public File(@Nullable java.io.File, @NonNull String);
    ctor public File(@NonNull java.net.URI);
    method public boolean canExecute();
    method public boolean canRead();
    method public boolean canWrite();
    method public int compareTo(@NonNull java.io.File);
    method public boolean createNewFile() throws java.io.IOException;
    method @NonNull public static java.io.File createTempFile(@NonNull String, @Nullable String, @Nullable java.io.File) throws java.io.IOException;
    method @NonNull public static java.io.File createTempFile(@NonNull String, @Nullable String) throws java.io.IOException;
    method public boolean delete();
    method public void deleteOnExit();
    method public boolean exists();
    method @NonNull public java.io.File getAbsoluteFile();
    method @NonNull public String getAbsolutePath();
    method @NonNull public java.io.File getCanonicalFile() throws java.io.IOException;
    method @NonNull public String getCanonicalPath() throws java.io.IOException;
    method public long getFreeSpace();
    method @NonNull public String getName();
    method @Nullable public String getParent();
    method @Nullable public java.io.File getParentFile();
    method @NonNull public String getPath();
    method public long getTotalSpace();
    method public long getUsableSpace();
    method public boolean isAbsolute();
    method public boolean isDirectory();
    method public boolean isFile();
    method public boolean isHidden();
    method public long lastModified();
    method public long length();
    method @Nullable public String[] list();
    method @Nullable public String[] list(@Nullable java.io.FilenameFilter);
    method @Nullable public java.io.File[] listFiles();
    method @Nullable public java.io.File[] listFiles(@Nullable java.io.FilenameFilter);
    method @Nullable public java.io.File[] listFiles(@Nullable java.io.FileFilter);
    method @NonNull public static java.io.File[] listRoots();
    method public boolean mkdir();
    method public boolean mkdirs();
    method public boolean renameTo(@NonNull java.io.File);
    method public boolean setExecutable(boolean, boolean);
    method public boolean setExecutable(boolean);
    method public boolean setLastModified(long);
    method public boolean setReadOnly();
    method public boolean setReadable(boolean, boolean);
    method public boolean setReadable(boolean);
    method public boolean setWritable(boolean, boolean);
    method public boolean setWritable(boolean);
    method @NonNull public java.nio.file.Path toPath();
    method @NonNull public java.net.URI toURI();
    method @Deprecated @NonNull public java.net.URL toURL() throws java.net.MalformedURLException;
    field @NonNull public static final String pathSeparator;
    field public static final char pathSeparatorChar;
    field @NonNull public static final String separator;
    field public static final char separatorChar;
  }

  public final class FileDescriptor {
    ctor public FileDescriptor();
    method public void sync() throws java.io.SyncFailedException;
    method public boolean valid();
    field public static final java.io.FileDescriptor err;
    field public static final java.io.FileDescriptor in;
    field public static final java.io.FileDescriptor out;
  }

  @java.lang.FunctionalInterface public interface FileFilter {
    method public boolean accept(java.io.File);
  }

  public class FileInputStream extends java.io.InputStream {
    ctor public FileInputStream(String) throws java.io.FileNotFoundException;
    ctor public FileInputStream(java.io.File) throws java.io.FileNotFoundException;
    ctor public FileInputStream(java.io.FileDescriptor);
    method protected void finalize() throws java.io.IOException;
    method public java.nio.channels.FileChannel getChannel();
    method public final java.io.FileDescriptor getFD() throws java.io.IOException;
    method public int read() throws java.io.IOException;
  }

  public class FileNotFoundException extends java.io.IOException {
    ctor public FileNotFoundException();
    ctor public FileNotFoundException(String);
  }

  public class FileOutputStream extends java.io.OutputStream {
    ctor public FileOutputStream(String) throws java.io.FileNotFoundException;
    ctor public FileOutputStream(String, boolean) throws java.io.FileNotFoundException;
    ctor public FileOutputStream(java.io.File) throws java.io.FileNotFoundException;
    ctor public FileOutputStream(java.io.File, boolean) throws java.io.FileNotFoundException;
    ctor public FileOutputStream(java.io.FileDescriptor);
    method protected void finalize() throws java.io.IOException;
    method public java.nio.channels.FileChannel getChannel();
    method public final java.io.FileDescriptor getFD() throws java.io.IOException;
    method public void write(int) throws java.io.IOException;
  }

  public final class FilePermission extends java.security.Permission implements java.io.Serializable {
    ctor public FilePermission(String, String);
    method public String getActions();
    method public boolean implies(java.security.Permission);
  }

  public class FileReader extends java.io.InputStreamReader {
    ctor public FileReader(String) throws java.io.FileNotFoundException;
    ctor public FileReader(java.io.File) throws java.io.FileNotFoundException;
    ctor public FileReader(java.io.FileDescriptor);
    ctor public FileReader(String, java.nio.charset.Charset) throws java.io.IOException;
    ctor public FileReader(java.io.File, java.nio.charset.Charset) throws java.io.IOException;
  }

  public class FileWriter extends java.io.OutputStreamWriter {
    ctor public FileWriter(String) throws java.io.IOException;
    ctor public FileWriter(String, boolean) throws java.io.IOException;
    ctor public FileWriter(java.io.File) throws java.io.IOException;
    ctor public FileWriter(java.io.File, boolean) throws java.io.IOException;
    ctor public FileWriter(java.io.FileDescriptor);
    ctor public FileWriter(String, java.nio.charset.Charset) throws java.io.IOException;
    ctor public FileWriter(String, java.nio.charset.Charset, boolean) throws java.io.IOException;
    ctor public FileWriter(java.io.File, java.nio.charset.Charset) throws java.io.IOException;
    ctor public FileWriter(java.io.File, java.nio.charset.Charset, boolean) throws java.io.IOException;
  }

  @java.lang.FunctionalInterface public interface FilenameFilter {
    method public boolean accept(java.io.File, String);
  }

  public class FilterInputStream extends java.io.InputStream {
    ctor protected FilterInputStream(java.io.InputStream);
    method public int read() throws java.io.IOException;
    field protected volatile java.io.InputStream in;
  }

  public class FilterOutputStream extends java.io.OutputStream {
    ctor public FilterOutputStream(java.io.OutputStream);
    method public void write(int) throws java.io.IOException;
    field protected java.io.OutputStream out;
  }

  public abstract class FilterReader extends java.io.Reader {
    ctor protected FilterReader(java.io.Reader);
    method public void close() throws java.io.IOException;
    method public int read(char[], int, int) throws java.io.IOException;
    field protected java.io.Reader in;
  }

  public abstract class FilterWriter extends java.io.Writer {
    ctor protected FilterWriter(java.io.Writer);
    method public void close() throws java.io.IOException;
    method public void flush() throws java.io.IOException;
    method public void write(char[], int, int) throws java.io.IOException;
    field protected java.io.Writer out;
  }

  public interface Flushable {
    method public void flush() throws java.io.IOException;
  }

  public class IOError extends java.lang.Error {
    ctor public IOError(Throwable);
  }

  public class IOException extends java.lang.Exception {
    ctor public IOException();
    ctor public IOException(String);
    ctor public IOException(String, Throwable);
    ctor public IOException(Throwable);
  }

  public abstract class InputStream implements java.io.Closeable {
    ctor public InputStream();
    method public int available() throws java.io.IOException;
    method public void close() throws java.io.IOException;
    method public void mark(int);
    method public boolean markSupported();
    method public static java.io.InputStream nullInputStream();
    method public abstract int read() throws java.io.IOException;
    method public int read(byte[]) throws java.io.IOException;
    method public int read(byte[], int, int) throws java.io.IOException;
    method public byte[] readAllBytes() throws java.io.IOException;
    method public byte[] readNBytes(int) throws java.io.IOException;
    method public int readNBytes(byte[], int, int) throws java.io.IOException;
    method public void reset() throws java.io.IOException;
    method public long skip(long) throws java.io.IOException;
    method public void skipNBytes(long) throws java.io.IOException;
    method public long transferTo(java.io.OutputStream) throws java.io.IOException;
  }

  public class InputStreamReader extends java.io.Reader {
    ctor public InputStreamReader(java.io.InputStream);
    ctor public InputStreamReader(java.io.InputStream, String) throws java.io.UnsupportedEncodingException;
    ctor public InputStreamReader(java.io.InputStream, java.nio.charset.Charset);
    ctor public InputStreamReader(java.io.InputStream, java.nio.charset.CharsetDecoder);
    method public void close() throws java.io.IOException;
    method public String getEncoding();
    method public int read(char[], int, int) throws java.io.IOException;
  }

  public class InterruptedIOException extends java.io.IOException {
    ctor public InterruptedIOException();
    ctor public InterruptedIOException(String);
    field public int bytesTransferred;
  }

  public class InvalidClassException extends java.io.ObjectStreamException {
    ctor public InvalidClassException(String);
    ctor public InvalidClassException(String, String);
    field public String classname;
  }

  public class InvalidObjectException extends java.io.ObjectStreamException {
    ctor public InvalidObjectException(String);
  }

  @Deprecated public class LineNumberInputStream extends java.io.FilterInputStream {
    ctor @Deprecated public LineNumberInputStream(java.io.InputStream);
    method @Deprecated public int getLineNumber();
    method @Deprecated public void setLineNumber(int);
  }

  public class LineNumberReader extends java.io.BufferedReader {
    ctor public LineNumberReader(java.io.Reader);
    ctor public LineNumberReader(java.io.Reader, int);
    method public int getLineNumber();
    method public void setLineNumber(int);
  }

  public class NotActiveException extends java.io.ObjectStreamException {
    ctor public NotActiveException(String);
    ctor public NotActiveException();
  }

  public class NotSerializableException extends java.io.ObjectStreamException {
    ctor public NotSerializableException(String);
    ctor public NotSerializableException();
  }

  public interface ObjectInput extends java.io.DataInput java.lang.AutoCloseable {
    method public int available() throws java.io.IOException;
    method public void close() throws java.io.IOException;
    method public int read() throws java.io.IOException;
    method public int read(byte[]) throws java.io.IOException;
    method public int read(byte[], int, int) throws java.io.IOException;
    method public Object readObject() throws java.lang.ClassNotFoundException, java.io.IOException;
    method public long skip(long) throws java.io.IOException;
  }

  public class ObjectInputStream extends java.io.InputStream implements java.io.ObjectInput java.io.ObjectStreamConstants {
    ctor public ObjectInputStream(java.io.InputStream) throws java.io.IOException;
    ctor protected ObjectInputStream() throws java.io.IOException, java.lang.SecurityException;
    method public void defaultReadObject() throws java.lang.ClassNotFoundException, java.io.IOException;
    method protected boolean enableResolveObject(boolean) throws java.lang.SecurityException;
    method public int read() throws java.io.IOException;
    method public boolean readBoolean() throws java.io.IOException;
    method public byte readByte() throws java.io.IOException;
    method public char readChar() throws java.io.IOException;
    method protected java.io.ObjectStreamClass readClassDescriptor() throws java.lang.ClassNotFoundException, java.io.IOException;
    method public double readDouble() throws java.io.IOException;
    method public java.io.ObjectInputStream.GetField readFields() throws java.lang.ClassNotFoundException, java.io.IOException;
    method public float readFloat() throws java.io.IOException;
    method public void readFully(byte[]) throws java.io.IOException;
    method public void readFully(byte[], int, int) throws java.io.IOException;
    method public int readInt() throws java.io.IOException;
    method @Deprecated public String readLine() throws java.io.IOException;
    method public long readLong() throws java.io.IOException;
    method public final Object readObject() throws java.lang.ClassNotFoundException, java.io.IOException;
    method protected Object readObjectOverride() throws java.lang.ClassNotFoundException, java.io.IOException;
    method public short readShort() throws java.io.IOException;
    method protected void readStreamHeader() throws java.io.IOException, java.io.StreamCorruptedException;
    method public String readUTF() throws java.io.IOException;
    method public Object readUnshared() throws java.lang.ClassNotFoundException, java.io.IOException;
    method public int readUnsignedByte() throws java.io.IOException;
    method public int readUnsignedShort() throws java.io.IOException;
    method public void registerValidation(java.io.ObjectInputValidation, int) throws java.io.InvalidObjectException, java.io.NotActiveException;
    method protected Class<?> resolveClass(java.io.ObjectStreamClass) throws java.lang.ClassNotFoundException, java.io.IOException;
    method protected Object resolveObject(Object) throws java.io.IOException;
    method protected Class<?> resolveProxyClass(String[]) throws java.lang.ClassNotFoundException, java.io.IOException;
    method public int skipBytes(int) throws java.io.IOException;
  }

  public abstract static class ObjectInputStream.GetField {
    ctor public ObjectInputStream.GetField();
    method public abstract boolean defaulted(String) throws java.io.IOException;
    method public abstract boolean get(String, boolean) throws java.io.IOException;
    method public abstract byte get(String, byte) throws java.io.IOException;
    method public abstract char get(String, char) throws java.io.IOException;
    method public abstract short get(String, short) throws java.io.IOException;
    method public abstract int get(String, int) throws java.io.IOException;
    method public abstract long get(String, long) throws java.io.IOException;
    method public abstract float get(String, float) throws java.io.IOException;
    method public abstract double get(String, double) throws java.io.IOException;
    method public abstract Object get(String, Object) throws java.io.IOException;
    method public abstract java.io.ObjectStreamClass getObjectStreamClass();
  }

  public interface ObjectInputValidation {
    method public void validateObject() throws java.io.InvalidObjectException;
  }

  public interface ObjectOutput extends java.io.DataOutput java.lang.AutoCloseable {
    method public void close() throws java.io.IOException;
    method public void flush() throws java.io.IOException;
    method public void writeObject(Object) throws java.io.IOException;
  }

  public class ObjectOutputStream extends java.io.OutputStream implements java.io.ObjectOutput java.io.ObjectStreamConstants {
    ctor public ObjectOutputStream(java.io.OutputStream) throws java.io.IOException;
    ctor protected ObjectOutputStream() throws java.io.IOException, java.lang.SecurityException;
    method protected void annotateClass(Class<?>) throws java.io.IOException;
    method protected void annotateProxyClass(Class<?>) throws java.io.IOException;
    method public void defaultWriteObject() throws java.io.IOException;
    method protected void drain() throws java.io.IOException;
    method protected boolean enableReplaceObject(boolean) throws java.lang.SecurityException;
    method public java.io.ObjectOutputStream.PutField putFields() throws java.io.IOException;
    method protected Object replaceObject(Object) throws java.io.IOException;
    method public void reset() throws java.io.IOException;
    method public void useProtocolVersion(int) throws java.io.IOException;
    method public void write(int) throws java.io.IOException;
    method public void writeBoolean(boolean) throws java.io.IOException;
    method public void writeByte(int) throws java.io.IOException;
    method public void writeBytes(String) throws java.io.IOException;
    method public void writeChar(int) throws java.io.IOException;
    method public void writeChars(String) throws java.io.IOException;
    method protected void writeClassDescriptor(java.io.ObjectStreamClass) throws java.io.IOException;
    method public void writeDouble(double) throws java.io.IOException;
    method public void writeFields() throws java.io.IOException;
    method public void writeFloat(float) throws java.io.IOException;
    method public void writeInt(int) throws java.io.IOException;
    method public void writeLong(long) throws java.io.IOException;
    method public final void writeObject(Object) throws java.io.IOException;
    method protected void writeObjectOverride(Object) throws java.io.IOException;
    method public void writeShort(int) throws java.io.IOException;
    method protected void writeStreamHeader() throws java.io.IOException;
    method public void writeUTF(String) throws java.io.IOException;
    method public void writeUnshared(Object) throws java.io.IOException;
  }

  public abstract static class ObjectOutputStream.PutField {
    ctor public ObjectOutputStream.PutField();
    method public abstract void put(String, boolean);
    method public abstract void put(String, byte);
    method public abstract void put(String, char);
    method public abstract void put(String, short);
    method public abstract void put(String, int);
    method public abstract void put(String, long);
    method public abstract void put(String, float);
    method public abstract void put(String, double);
    method public abstract void put(String, Object);
    method @Deprecated public abstract void write(java.io.ObjectOutput) throws java.io.IOException;
  }

  public class ObjectStreamClass implements java.io.Serializable {
    method public Class<?> forClass();
    method public java.io.ObjectStreamField getField(String);
    method public java.io.ObjectStreamField[] getFields();
    method public String getName();
    method public long getSerialVersionUID();
    method public static java.io.ObjectStreamClass lookup(Class<?>);
    method public static java.io.ObjectStreamClass lookupAny(Class<?>);
    field public static final java.io.ObjectStreamField[] NO_FIELDS;
  }

  public interface ObjectStreamConstants {
    field public static final int PROTOCOL_VERSION_1 = 1; // 0x1
    field public static final int PROTOCOL_VERSION_2 = 2; // 0x2
    field public static final byte SC_BLOCK_DATA = 8; // 0x8
    field public static final byte SC_ENUM = 16; // 0x10
    field public static final byte SC_EXTERNALIZABLE = 4; // 0x4
    field public static final byte SC_SERIALIZABLE = 2; // 0x2
    field public static final byte SC_WRITE_METHOD = 1; // 0x1
    field public static final short STREAM_MAGIC = -21267; // 0xffffaced
    field public static final short STREAM_VERSION = 5; // 0x5
    field public static final java.io.SerializablePermission SUBCLASS_IMPLEMENTATION_PERMISSION;
    field public static final java.io.SerializablePermission SUBSTITUTION_PERMISSION;
    field public static final byte TC_ARRAY = 117; // 0x75
    field public static final byte TC_BASE = 112; // 0x70
    field public static final byte TC_BLOCKDATA = 119; // 0x77
    field public static final byte TC_BLOCKDATALONG = 122; // 0x7a
    field public static final byte TC_CLASS = 118; // 0x76
    field public static final byte TC_CLASSDESC = 114; // 0x72
    field public static final byte TC_ENDBLOCKDATA = 120; // 0x78
    field public static final byte TC_ENUM = 126; // 0x7e
    field public static final byte TC_EXCEPTION = 123; // 0x7b
    field public static final byte TC_LONGSTRING = 124; // 0x7c
    field public static final byte TC_MAX = 126; // 0x7e
    field public static final byte TC_NULL = 112; // 0x70
    field public static final byte TC_OBJECT = 115; // 0x73
    field public static final byte TC_PROXYCLASSDESC = 125; // 0x7d
    field public static final byte TC_REFERENCE = 113; // 0x71
    field public static final byte TC_RESET = 121; // 0x79
    field public static final byte TC_STRING = 116; // 0x74
    field public static final int baseWireHandle = 8257536; // 0x7e0000
  }

  public abstract class ObjectStreamException extends java.io.IOException {
    ctor protected ObjectStreamException(String);
    ctor protected ObjectStreamException();
  }

  public class ObjectStreamField implements java.lang.Comparable<java.lang.Object> {
    ctor public ObjectStreamField(String, Class<?>);
    ctor public ObjectStreamField(String, Class<?>, boolean);
    method public int compareTo(Object);
    method public String getName();
    method public int getOffset();
    method public Class<?> getType();
    method public char getTypeCode();
    method public String getTypeString();
    method public boolean isPrimitive();
    method public boolean isUnshared();
    method protected void setOffset(int);
  }

  public class OptionalDataException extends java.io.ObjectStreamException {
    field public boolean eof;
    field public int length;
  }

  public abstract class OutputStream implements java.io.Closeable java.io.Flushable {
    ctor public OutputStream();
    method public void close() throws java.io.IOException;
    method public void flush() throws java.io.IOException;
    method public static java.io.OutputStream nullOutputStream();
    method public abstract void write(int) throws java.io.IOException;
    method public void write(byte[]) throws java.io.IOException;
    method public void write(byte[], int, int) throws java.io.IOException;
  }

  public class OutputStreamWriter extends java.io.Writer {
    ctor public OutputStreamWriter(java.io.OutputStream, String) throws java.io.UnsupportedEncodingException;
    ctor public OutputStreamWriter(java.io.OutputStream);
    ctor public OutputStreamWriter(java.io.OutputStream, java.nio.charset.Charset);
    ctor public OutputStreamWriter(java.io.OutputStream, java.nio.charset.CharsetEncoder);
    method public void close() throws java.io.IOException;
    method public void flush() throws java.io.IOException;
    method public String getEncoding();
    method public void write(char[], int, int) throws java.io.IOException;
  }

  public class PipedInputStream extends java.io.InputStream {
    ctor public PipedInputStream(java.io.PipedOutputStream) throws java.io.IOException;
    ctor public PipedInputStream(java.io.PipedOutputStream, int) throws java.io.IOException;
    ctor public PipedInputStream();
    ctor public PipedInputStream(int);
    method public void connect(java.io.PipedOutputStream) throws java.io.IOException;
    method public int read() throws java.io.IOException;
    method protected void receive(int) throws java.io.IOException;
    field protected static final int PIPE_SIZE = 1024; // 0x400
    field protected byte[] buffer;
    field protected int in;
    field protected int out;
  }

  public class PipedOutputStream extends java.io.OutputStream {
    ctor public PipedOutputStream(java.io.PipedInputStream) throws java.io.IOException;
    ctor public PipedOutputStream();
    method public void connect(java.io.PipedInputStream) throws java.io.IOException;
    method public void write(int) throws java.io.IOException;
  }

  public class PipedReader extends java.io.Reader {
    ctor public PipedReader(java.io.PipedWriter) throws java.io.IOException;
    ctor public PipedReader(java.io.PipedWriter, int) throws java.io.IOException;
    ctor public PipedReader();
    ctor public PipedReader(int);
    method public void close() throws java.io.IOException;
    method public void connect(java.io.PipedWriter) throws java.io.IOException;
    method public int read(char[], int, int) throws java.io.IOException;
  }

  public class PipedWriter extends java.io.Writer {
    ctor public PipedWriter(java.io.PipedReader) throws java.io.IOException;
    ctor public PipedWriter();
    method public void close() throws java.io.IOException;
    method public void connect(java.io.PipedReader) throws java.io.IOException;
    method public void flush() throws java.io.IOException;
    method public void write(char[], int, int) throws java.io.IOException;
  }

  public class PrintStream extends java.io.FilterOutputStream implements java.lang.Appendable java.io.Closeable {
    ctor public PrintStream(java.io.OutputStream);
    ctor public PrintStream(java.io.OutputStream, boolean);
    ctor public PrintStream(java.io.OutputStream, boolean, String) throws java.io.UnsupportedEncodingException;
    ctor public PrintStream(java.io.OutputStream, boolean, java.nio.charset.Charset);
    ctor public PrintStream(String) throws java.io.FileNotFoundException;
    ctor public PrintStream(String, String) throws java.io.FileNotFoundException, java.io.UnsupportedEncodingException;
    ctor public PrintStream(String, java.nio.charset.Charset) throws java.io.IOException;
    ctor public PrintStream(java.io.File) throws java.io.FileNotFoundException;
    ctor public PrintStream(java.io.File, String) throws java.io.FileNotFoundException, java.io.UnsupportedEncodingException;
    ctor public PrintStream(java.io.File, java.nio.charset.Charset) throws java.io.IOException;
    method public java.io.PrintStream append(CharSequence);
    method public java.io.PrintStream append(CharSequence, int, int);
    method public java.io.PrintStream append(char);
    method public boolean checkError();
    method protected void clearError();
    method public void close();
    method public void flush();
    method public java.io.PrintStream format(String, java.lang.Object...);
    method public java.io.PrintStream format(java.util.Locale, String, java.lang.Object...);
    method public void print(boolean);
    method public void print(char);
    method public void print(int);
    method public void print(long);
    method public void print(float);
    method public void print(double);
    method public void print(char[]);
    method public void print(String);
    method public void print(Object);
    method public java.io.PrintStream printf(String, java.lang.Object...);
    method public java.io.PrintStream printf(java.util.Locale, String, java.lang.Object...);
    method public void println();
    method public void println(boolean);
    method public void println(char);
    method public void println(int);
    method public void println(long);
    method public void println(float);
    method public void println(double);
    method public void println(char[]);
    method public void println(String);
    method public void println(Object);
    method protected void setError();
    method public void write(int);
    method public void write(byte[], int, int);
    method public void writeBytes(byte[]);
  }

  public class PrintWriter extends java.io.Writer {
    ctor public PrintWriter(@NonNull java.io.Writer);
    ctor public PrintWriter(@NonNull java.io.Writer, boolean);
    ctor public PrintWriter(@NonNull java.io.OutputStream);
    ctor public PrintWriter(@NonNull java.io.OutputStream, boolean);
    ctor public PrintWriter(@NonNull java.io.OutputStream, boolean, @NonNull java.nio.charset.Charset);
    ctor public PrintWriter(@NonNull String) throws java.io.FileNotFoundException;
    ctor public PrintWriter(@NonNull String, @NonNull String) throws java.io.FileNotFoundException, java.io.UnsupportedEncodingException;
    ctor public PrintWriter(@NonNull String, @NonNull java.nio.charset.Charset) throws java.io.IOException;
    ctor public PrintWriter(@NonNull java.io.File) throws java.io.FileNotFoundException;
    ctor public PrintWriter(@NonNull java.io.File, @NonNull String) throws java.io.FileNotFoundException, java.io.UnsupportedEncodingException;
    ctor public PrintWriter(@NonNull java.io.File, @NonNull java.nio.charset.Charset) throws java.io.IOException;
    method @NonNull public java.io.PrintWriter append(@Nullable CharSequence);
    method @NonNull public java.io.PrintWriter append(@Nullable CharSequence, int, int);
    method @NonNull public java.io.PrintWriter append(char);
    method public boolean checkError();
    method protected void clearError();
    method public void close();
    method public void flush();
    method @NonNull public java.io.PrintWriter format(@NonNull String, @NonNull java.lang.Object...);
    method @NonNull public java.io.PrintWriter format(@Nullable java.util.Locale, @NonNull String, @NonNull java.lang.Object...);
    method public void print(boolean);
    method public void print(char);
    method public void print(int);
    method public void print(long);
    method public void print(float);
    method public void print(double);
    method public void print(char[]);
    method public void print(@Nullable String);
    method public void print(@Nullable Object);
    method @NonNull public java.io.PrintWriter printf(@NonNull String, @NonNull java.lang.Object...);
    method @NonNull public java.io.PrintWriter printf(@Nullable java.util.Locale, @NonNull String, @NonNull java.lang.Object...);
    method public void println();
    method public void println(boolean);
    method public void println(char);
    method public void println(int);
    method public void println(long);
    method public void println(float);
    method public void println(double);
    method public void println(char[]);
    method public void println(@Nullable String);
    method public void println(@Nullable Object);
    method protected void setError();
    method public void write(int);
    method public void write(char[], int, int);
    method public void write(char[]);
    method public void write(@NonNull String, int, int);
    method public void write(@NonNull String);
    field protected java.io.Writer out;
  }

  public class PushbackInputStream extends java.io.FilterInputStream {
    ctor public PushbackInputStream(java.io.InputStream, int);
    ctor public PushbackInputStream(java.io.InputStream);
    method public void unread(int) throws java.io.IOException;
    method public void unread(byte[], int, int) throws java.io.IOException;
    method public void unread(byte[]) throws java.io.IOException;
    field protected byte[] buf;
    field protected int pos;
  }

  public class PushbackReader extends java.io.FilterReader {
    ctor public PushbackReader(java.io.Reader, int);
    ctor public PushbackReader(java.io.Reader);
    method public void unread(int) throws java.io.IOException;
    method public void unread(char[], int, int) throws java.io.IOException;
    method public void unread(char[]) throws java.io.IOException;
  }

  public class RandomAccessFile implements java.io.Closeable java.io.DataInput java.io.DataOutput {
    ctor public RandomAccessFile(String, String) throws java.io.FileNotFoundException;
    ctor public RandomAccessFile(java.io.File, String) throws java.io.FileNotFoundException;
    method public void close() throws java.io.IOException;
    method public final java.nio.channels.FileChannel getChannel();
    method public final java.io.FileDescriptor getFD() throws java.io.IOException;
    method public long getFilePointer() throws java.io.IOException;
    method public long length() throws java.io.IOException;
    method public int read() throws java.io.IOException;
    method public int read(byte[], int, int) throws java.io.IOException;
    method public int read(byte[]) throws java.io.IOException;
    method public final boolean readBoolean() throws java.io.IOException;
    method public final byte readByte() throws java.io.IOException;
    method public final char readChar() throws java.io.IOException;
    method public final double readDouble() throws java.io.IOException;
    method public final float readFloat() throws java.io.IOException;
    method public final void readFully(byte[]) throws java.io.IOException;
    method public final void readFully(byte[], int, int) throws java.io.IOException;
    method public final int readInt() throws java.io.IOException;
    method public final String readLine() throws java.io.IOException;
    method public final long readLong() throws java.io.IOException;
    method public final short readShort() throws java.io.IOException;
    method public final String readUTF() throws java.io.IOException;
    method public final int readUnsignedByte() throws java.io.IOException;
    method public final int readUnsignedShort() throws java.io.IOException;
    method public void seek(long) throws java.io.IOException;
    method public void setLength(long) throws java.io.IOException;
    method public int skipBytes(int) throws java.io.IOException;
    method public void write(int) throws java.io.IOException;
    method public void write(byte[]) throws java.io.IOException;
    method public void write(byte[], int, int) throws java.io.IOException;
    method public final void writeBoolean(boolean) throws java.io.IOException;
    method public final void writeByte(int) throws java.io.IOException;
    method public final void writeBytes(String) throws java.io.IOException;
    method public final void writeChar(int) throws java.io.IOException;
    method public final void writeChars(String) throws java.io.IOException;
    method public final void writeDouble(double) throws java.io.IOException;
    method public final void writeFloat(float) throws java.io.IOException;
    method public final void writeInt(int) throws java.io.IOException;
    method public final void writeLong(long) throws java.io.IOException;
    method public final void writeShort(int) throws java.io.IOException;
    method public final void writeUTF(String) throws java.io.IOException;
  }

  public abstract class Reader implements java.io.Closeable java.lang.Readable {
    ctor protected Reader();
    ctor protected Reader(Object);
    method public void mark(int) throws java.io.IOException;
    method public boolean markSupported();
    method public static java.io.Reader nullReader();
    method public int read(java.nio.CharBuffer) throws java.io.IOException;
    method public int read() throws java.io.IOException;
    method public int read(char[]) throws java.io.IOException;
    method public abstract int read(char[], int, int) throws java.io.IOException;
    method public boolean ready() throws java.io.IOException;
    method public void reset() throws java.io.IOException;
    method public long skip(long) throws java.io.IOException;
    method public long transferTo(java.io.Writer) throws java.io.IOException;
    field protected Object lock;
  }

  public class SequenceInputStream extends java.io.InputStream {
    ctor public SequenceInputStream(java.util.Enumeration<? extends java.io.InputStream>);
    ctor public SequenceInputStream(java.io.InputStream, java.io.InputStream);
    method public int read() throws java.io.IOException;
  }

  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) @java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.FIELD}) public @interface Serial {
  }

  public interface Serializable {
  }

  public final class SerializablePermission extends java.security.BasicPermission {
    ctor public SerializablePermission(String);
    ctor public SerializablePermission(String, String);
  }

  public class StreamCorruptedException extends java.io.ObjectStreamException {
    ctor public StreamCorruptedException(String);
    ctor public StreamCorruptedException();
  }

  public class StreamTokenizer {
    ctor @Deprecated public StreamTokenizer(java.io.InputStream);
    ctor public StreamTokenizer(java.io.Reader);
    method public void commentChar(int);
    method public void eolIsSignificant(boolean);
    method public int lineno();
    method public void lowerCaseMode(boolean);
    method public int nextToken() throws java.io.IOException;
    method public void ordinaryChar(int);
    method public void ordinaryChars(int, int);
    method public void parseNumbers();
    method public void pushBack();
    method public void quoteChar(int);
    method public void resetSyntax();
    method public void slashSlashComments(boolean);
    method public void slashStarComments(boolean);
    method public void whitespaceChars(int, int);
    method public void wordChars(int, int);
    field public static final int TT_EOF = -1; // 0xffffffff
    field public static final int TT_EOL = 10; // 0xa
    field public static final int TT_NUMBER = -2; // 0xfffffffe
    field public static final int TT_WORD = -3; // 0xfffffffd
    field public double nval;
    field public String sval;
    field public int ttype;
  }

  @Deprecated public class StringBufferInputStream extends java.io.InputStream {
    ctor @Deprecated public StringBufferInputStream(String);
    method @Deprecated public int available();
    method @Deprecated public int read();
    method @Deprecated public int read(byte[], int, int);
    method @Deprecated public void reset();
    method @Deprecated public long skip(long);
    field @Deprecated protected String buffer;
    field @Deprecated protected int count;
    field @Deprecated protected int pos;
  }

  public class StringReader extends java.io.Reader {
    ctor public StringReader(String);
    method public void close();
    method public int read(char[], int, int) throws java.io.IOException;
  }

  public class StringWriter extends java.io.Writer {
    ctor public StringWriter();
    ctor public StringWriter(int);
    method public java.io.StringWriter append(CharSequence);
    method public java.io.StringWriter append(CharSequence, int, int);
    method public java.io.StringWriter append(char);
    method public void close() throws java.io.IOException;
    method public void flush();
    method public StringBuffer getBuffer();
    method public void write(int);
    method public void write(char[], int, int);
    method public void write(String);
    method public void write(String, int, int);
  }

  public class SyncFailedException extends java.io.IOException {
    ctor public SyncFailedException(String);
  }

  public class UTFDataFormatException extends java.io.IOException {
    ctor public UTFDataFormatException();
    ctor public UTFDataFormatException(String);
  }

  public class UncheckedIOException extends java.lang.RuntimeException {
    ctor public UncheckedIOException(String, java.io.IOException);
    ctor public UncheckedIOException(java.io.IOException);
    method public java.io.IOException getCause();
  }

  public class UnsupportedEncodingException extends java.io.IOException {
    ctor public UnsupportedEncodingException();
    ctor public UnsupportedEncodingException(String);
  }

  public class WriteAbortedException extends java.io.ObjectStreamException {
    ctor public WriteAbortedException(String, Exception);
    field @Deprecated public Exception detail;
  }

  public abstract class Writer implements java.lang.Appendable java.io.Closeable java.io.Flushable {
    ctor protected Writer();
    ctor protected Writer(Object);
    method public java.io.Writer append(CharSequence) throws java.io.IOException;
    method public java.io.Writer append(CharSequence, int, int) throws java.io.IOException;
    method public java.io.Writer append(char) throws java.io.IOException;
    method public static java.io.Writer nullWriter();
    method public void write(int) throws java.io.IOException;
    method public void write(char[]) throws java.io.IOException;
    method public abstract void write(char[], int, int) throws java.io.IOException;
    method public void write(String) throws java.io.IOException;
    method public void write(String, int, int) throws java.io.IOException;
    field protected Object lock;
  }

}

package java.lang {

  public class AbstractMethodError extends java.lang.IncompatibleClassChangeError {
    ctor public AbstractMethodError();
    ctor public AbstractMethodError(String);
  }

  public interface Appendable {
    method @NonNull public Appendable append(@Nullable CharSequence) throws java.io.IOException;
    method @NonNull public Appendable append(@Nullable CharSequence, int, int) throws java.io.IOException;
    method @NonNull public Appendable append(char) throws java.io.IOException;
  }

  public class ArithmeticException extends java.lang.RuntimeException {
    ctor public ArithmeticException();
    ctor public ArithmeticException(String);
  }

  public class ArrayIndexOutOfBoundsException extends java.lang.IndexOutOfBoundsException {
    ctor public ArrayIndexOutOfBoundsException();
    ctor public ArrayIndexOutOfBoundsException(String);
    ctor public ArrayIndexOutOfBoundsException(int);
  }

  public class ArrayStoreException extends java.lang.RuntimeException {
    ctor public ArrayStoreException();
    ctor public ArrayStoreException(String);
  }

  public class AssertionError extends java.lang.Error {
    ctor public AssertionError();
    ctor public AssertionError(Object);
    ctor public AssertionError(boolean);
    ctor public AssertionError(char);
    ctor public AssertionError(int);
    ctor public AssertionError(long);
    ctor public AssertionError(float);
    ctor public AssertionError(double);
    ctor public AssertionError(String, Throwable);
  }

  public interface AutoCloseable {
    method public void close() throws java.lang.Exception;
  }

  public final class Boolean implements java.lang.Comparable<java.lang.Boolean> java.io.Serializable {
    ctor @Deprecated public Boolean(boolean);
    ctor @Deprecated public Boolean(@Nullable String);
    method public boolean booleanValue();
    method public static int compare(boolean, boolean);
    method public int compareTo(@NonNull Boolean);
    method public static boolean getBoolean(@NonNull String);
    method public static int hashCode(boolean);
    method public static boolean logicalAnd(boolean, boolean);
    method public static boolean logicalOr(boolean, boolean);
    method public static boolean logicalXor(boolean, boolean);
    method public static boolean parseBoolean(@Nullable String);
    method @NonNull public static String toString(boolean);
    method @NonNull public static Boolean valueOf(boolean);
    method @NonNull public static Boolean valueOf(@Nullable String);
    field public static final Boolean FALSE;
    field public static final Boolean TRUE;
    field public static final Class<java.lang.Boolean> TYPE;
  }

  public class BootstrapMethodError extends java.lang.LinkageError {
    ctor public BootstrapMethodError();
    ctor public BootstrapMethodError(String);
    ctor public BootstrapMethodError(String, Throwable);
    ctor public BootstrapMethodError(Throwable);
  }

  public final class Byte extends java.lang.Number implements java.lang.Comparable<java.lang.Byte> {
    ctor @Deprecated public Byte(byte);
    ctor @Deprecated public Byte(@NonNull String) throws java.lang.NumberFormatException;
    method public static int compare(byte, byte);
    method public int compareTo(@NonNull Byte);
    method public static int compareUnsigned(byte, byte);
    method @NonNull public static Byte decode(@NonNull String) throws java.lang.NumberFormatException;
    method public double doubleValue();
    method public float floatValue();
    method public static int hashCode(byte);
    method public int intValue();
    method public long longValue();
    method public static byte parseByte(@NonNull String, int) throws java.lang.NumberFormatException;
    method public static byte parseByte(@NonNull String) throws java.lang.NumberFormatException;
    method @NonNull public static String toString(byte);
    method public static int toUnsignedInt(byte);
    method public static long toUnsignedLong(byte);
    method @NonNull public static Byte valueOf(byte);
    method @NonNull public static Byte valueOf(@NonNull String, int) throws java.lang.NumberFormatException;
    method @NonNull public static Byte valueOf(@NonNull String) throws java.lang.NumberFormatException;
    field public static final int BYTES = 1; // 0x1
    field public static final byte MAX_VALUE = 127; // 0x7f
    field public static final byte MIN_VALUE = -128; // 0xffffff80
    field public static final int SIZE = 8; // 0x8
    field public static final Class<java.lang.Byte> TYPE;
  }

  public interface CharSequence {
    method public char charAt(int);
    method @NonNull public default java.util.stream.IntStream chars();
    method @NonNull public default java.util.stream.IntStream codePoints();
    method public static int compare(@NonNull CharSequence, @NonNull CharSequence);
    method @FlaggedApi("com.android.libcore.v_apis") public default boolean isEmpty();
    method public int length();
    method @NonNull public CharSequence subSequence(int, int);
    method @NonNull public String toString();
  }

  public final class Character implements java.lang.Comparable<java.lang.Character> java.io.Serializable {
    ctor @Deprecated public Character(char);
    method public static int charCount(int);
    method public char charValue();
    method public static int codePointAt(@NonNull CharSequence, int);
    method public static int codePointAt(char[], int);
    method public static int codePointAt(char[], int, int);
    method public static int codePointBefore(@NonNull CharSequence, int);
    method public static int codePointBefore(char[], int);
    method public static int codePointBefore(char[], int, int);
    method public static int codePointCount(@NonNull CharSequence, int, int);
    method public static int codePointCount(char[], int, int);
    method @FlaggedApi("com.android.libcore.v_apis") public static int codePointOf(@NonNull String);
    method public static int compare(char, char);
    method public int compareTo(@NonNull Character);
    method public static int digit(char, int);
    method public static int digit(int, int);
    method public static char forDigit(int, int);
    method public static byte getDirectionality(char);
    method public static byte getDirectionality(int);
    method @Nullable public static String getName(int);
    method public static int getNumericValue(char);
    method public static int getNumericValue(int);
    method public static int getType(char);
    method public static int getType(int);
    method public static int hashCode(char);
    method public static char highSurrogate(int);
    method public static boolean isAlphabetic(int);
    method public static boolean isBmpCodePoint(int);
    method public static boolean isDefined(char);
    method public static boolean isDefined(int);
    method public static boolean isDigit(char);
    method public static boolean isDigit(int);
    method public static boolean isHighSurrogate(char);
    method public static boolean isISOControl(char);
    method public static boolean isISOControl(int);
    method public static boolean isIdentifierIgnorable(char);
    method public static boolean isIdentifierIgnorable(int);
    method public static boolean isIdeographic(int);
    method public static boolean isJavaIdentifierPart(char);
    method public static boolean isJavaIdentifierPart(int);
    method public static boolean isJavaIdentifierStart(char);
    method public static boolean isJavaIdentifierStart(int);
    method @Deprecated public static boolean isJavaLetter(char);
    method @Deprecated public static boolean isJavaLetterOrDigit(char);
    method public static boolean isLetter(char);
    method public static boolean isLetter(int);
    method public static boolean isLetterOrDigit(char);
    method public static boolean isLetterOrDigit(int);
    method public static boolean isLowSurrogate(char);
    method public static boolean isLowerCase(char);
    method public static boolean isLowerCase(int);
    method public static boolean isMirrored(char);
    method public static boolean isMirrored(int);
    method @Deprecated public static boolean isSpace(char);
    method public static boolean isSpaceChar(char);
    method public static boolean isSpaceChar(int);
    method public static boolean isSupplementaryCodePoint(int);
    method public static boolean isSurrogate(char);
    method public static boolean isSurrogatePair(char, char);
    method public static boolean isTitleCase(char);
    method public static boolean isTitleCase(int);
    method public static boolean isUnicodeIdentifierPart(char);
    method public static boolean isUnicodeIdentifierPart(int);
    method public static boolean isUnicodeIdentifierStart(char);
    method public static boolean isUnicodeIdentifierStart(int);
    method public static boolean isUpperCase(char);
    method public static boolean isUpperCase(int);
    method public static boolean isValidCodePoint(int);
    method public static boolean isWhitespace(char);
    method public static boolean isWhitespace(int);
    method public static char lowSurrogate(int);
    method public static int offsetByCodePoints(@NonNull CharSequence, int, int);
    method public static int offsetByCodePoints(char[], int, int, int, int);
    method public static char reverseBytes(char);
    method public static int toChars(int, char[], int);
    method public static char[] toChars(int);
    method public static int toCodePoint(char, char);
    method public static char toLowerCase(char);
    method public static int toLowerCase(int);
    method @NonNull public static String toString(char);
    method @FlaggedApi("com.android.libcore.v_apis") @NonNull public static String toString(int);
    method public static char toTitleCase(char);
    method public static int toTitleCase(int);
    method public static char toUpperCase(char);
    method public static int toUpperCase(int);
    method @NonNull public static Character valueOf(char);
    field public static final int BYTES = 2; // 0x2
    field public static final byte COMBINING_SPACING_MARK = 8; // 0x8
    field public static final byte CONNECTOR_PUNCTUATION = 23; // 0x17
    field public static final byte CONTROL = 15; // 0xf
    field public static final byte CURRENCY_SYMBOL = 26; // 0x1a
    field public static final byte DASH_PUNCTUATION = 20; // 0x14
    field public static final byte DECIMAL_DIGIT_NUMBER = 9; // 0x9
    field public static final byte DIRECTIONALITY_ARABIC_NUMBER = 6; // 0x6
    field public static final byte DIRECTIONALITY_BOUNDARY_NEUTRAL = 9; // 0x9
    field public static final byte DIRECTIONALITY_COMMON_NUMBER_SEPARATOR = 7; // 0x7
    field public static final byte DIRECTIONALITY_EUROPEAN_NUMBER = 3; // 0x3
    field public static final byte DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR = 4; // 0x4
    field public static final byte DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR = 5; // 0x5
    field public static final byte DIRECTIONALITY_FIRST_STRONG_ISOLATE = 21; // 0x15
    field public static final byte DIRECTIONALITY_LEFT_TO_RIGHT = 0; // 0x0
    field public static final byte DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING = 14; // 0xe
    field public static final byte DIRECTIONALITY_LEFT_TO_RIGHT_ISOLATE = 19; // 0x13
    field public static final byte DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE = 15; // 0xf
    field public static final byte DIRECTIONALITY_NONSPACING_MARK = 8; // 0x8
    field public static final byte DIRECTIONALITY_OTHER_NEUTRALS = 13; // 0xd
    field public static final byte DIRECTIONALITY_PARAGRAPH_SEPARATOR = 10; // 0xa
    field public static final byte DIRECTIONALITY_POP_DIRECTIONAL_FORMAT = 18; // 0x12
    field public static final byte DIRECTIONALITY_POP_DIRECTIONAL_ISOLATE = 22; // 0x16
    field public static final byte DIRECTIONALITY_RIGHT_TO_LEFT = 1; // 0x1
    field public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC = 2; // 0x2
    field public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING = 16; // 0x10
    field public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_ISOLATE = 20; // 0x14
    field public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE = 17; // 0x11
    field public static final byte DIRECTIONALITY_SEGMENT_SEPARATOR = 11; // 0xb
    field public static final byte DIRECTIONALITY_UNDEFINED = -1; // 0xffffffff
    field public static final byte DIRECTIONALITY_WHITESPACE = 12; // 0xc
    field public static final byte ENCLOSING_MARK = 7; // 0x7
    field public static final byte END_PUNCTUATION = 22; // 0x16
    field public static final byte FINAL_QUOTE_PUNCTUATION = 30; // 0x1e
    field public static final byte FORMAT = 16; // 0x10
    field public static final byte INITIAL_QUOTE_PUNCTUATION = 29; // 0x1d
    field public static final byte LETTER_NUMBER = 10; // 0xa
    field public static final byte LINE_SEPARATOR = 13; // 0xd
    field public static final byte LOWERCASE_LETTER = 2; // 0x2
    field public static final byte MATH_SYMBOL = 25; // 0x19
    field public static final int MAX_CODE_POINT = 1114111; // 0x10ffff
    field public static final char MAX_HIGH_SURROGATE = 56319; // 0xdbff '\udbff'
    field public static final char MAX_LOW_SURROGATE = 57343; // 0xdfff '\udfff'
    field public static final int MAX_RADIX = 36; // 0x24
    field public static final char MAX_SURROGATE = 57343; // 0xdfff '\udfff'
    field public static final char MAX_VALUE = 65535; // 0xffff '\uffff'
    field public static final int MIN_CODE_POINT = 0; // 0x0
    field public static final char MIN_HIGH_SURROGATE = 55296; // 0xd800 '\ud800'
    field public static final char MIN_LOW_SURROGATE = 56320; // 0xdc00 '\udc00'
    field public static final int MIN_RADIX = 2; // 0x2
    field public static final int MIN_SUPPLEMENTARY_CODE_POINT = 65536; // 0x10000
    field public static final char MIN_SURROGATE = 55296; // 0xd800 '\ud800'
    field public static final char MIN_VALUE = 0; // 0x0000 '\u0000'
    field public static final byte MODIFIER_LETTER = 4; // 0x4
    field public static final byte MODIFIER_SYMBOL = 27; // 0x1b
    field public static final byte NON_SPACING_MARK = 6; // 0x6
    field public static final byte OTHER_LETTER = 5; // 0x5
    field public static final byte OTHER_NUMBER = 11; // 0xb
    field public static final byte OTHER_PUNCTUATION = 24; // 0x18
    field public static final byte OTHER_SYMBOL = 28; // 0x1c
    field public static final byte PARAGRAPH_SEPARATOR = 14; // 0xe
    field public static final byte PRIVATE_USE = 18; // 0x12
    field public static final int SIZE = 16; // 0x10
    field public static final byte SPACE_SEPARATOR = 12; // 0xc
    field public static final byte START_PUNCTUATION = 21; // 0x15
    field public static final byte SURROGATE = 19; // 0x13
    field public static final byte TITLECASE_LETTER = 3; // 0x3
    field public static final Class<java.lang.Character> TYPE;
    field public static final byte UNASSIGNED = 0; // 0x0
    field public static final byte UPPERCASE_LETTER = 1; // 0x1
  }

  public static class Character.Subset {
    ctor protected Character.Subset(@NonNull String);
    method public final boolean equals(@Nullable Object);
    method public final int hashCode();
    method @NonNull public final String toString();
  }

  public static final class Character.UnicodeBlock extends java.lang.Character.Subset {
    method @NonNull public static java.lang.Character.UnicodeBlock forName(@NonNull String);
    method @Nullable public static java.lang.Character.UnicodeBlock of(char);
    method @Nullable public static java.lang.Character.UnicodeBlock of(int);
    field public static final java.lang.Character.UnicodeBlock ADLAM;
    field public static final java.lang.Character.UnicodeBlock AEGEAN_NUMBERS;
    field public static final java.lang.Character.UnicodeBlock AHOM;
    field public static final java.lang.Character.UnicodeBlock ALCHEMICAL_SYMBOLS;
    field public static final java.lang.Character.UnicodeBlock ALPHABETIC_PRESENTATION_FORMS;
    field public static final java.lang.Character.UnicodeBlock ANATOLIAN_HIEROGLYPHS;
    field public static final java.lang.Character.UnicodeBlock ANCIENT_GREEK_MUSICAL_NOTATION;
    field public static final java.lang.Character.UnicodeBlock ANCIENT_GREEK_NUMBERS;
    field public static final java.lang.Character.UnicodeBlock ANCIENT_SYMBOLS;
    field public static final java.lang.Character.UnicodeBlock ARABIC;
    field public static final java.lang.Character.UnicodeBlock ARABIC_EXTENDED_A;
    field public static final java.lang.Character.UnicodeBlock ARABIC_MATHEMATICAL_ALPHABETIC_SYMBOLS;
    field public static final java.lang.Character.UnicodeBlock ARABIC_PRESENTATION_FORMS_A;
    field public static final java.lang.Character.UnicodeBlock ARABIC_PRESENTATION_FORMS_B;
    field public static final java.lang.Character.UnicodeBlock ARABIC_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock ARMENIAN;
    field public static final java.lang.Character.UnicodeBlock ARROWS;
    field public static final java.lang.Character.UnicodeBlock AVESTAN;
    field public static final java.lang.Character.UnicodeBlock BALINESE;
    field public static final java.lang.Character.UnicodeBlock BAMUM;
    field public static final java.lang.Character.UnicodeBlock BAMUM_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock BASIC_LATIN;
    field public static final java.lang.Character.UnicodeBlock BASSA_VAH;
    field public static final java.lang.Character.UnicodeBlock BATAK;
    field public static final java.lang.Character.UnicodeBlock BENGALI;
    field public static final java.lang.Character.UnicodeBlock BHAIKSUKI;
    field public static final java.lang.Character.UnicodeBlock BLOCK_ELEMENTS;
    field public static final java.lang.Character.UnicodeBlock BOPOMOFO;
    field public static final java.lang.Character.UnicodeBlock BOPOMOFO_EXTENDED;
    field public static final java.lang.Character.UnicodeBlock BOX_DRAWING;
    field public static final java.lang.Character.UnicodeBlock BRAHMI;
    field public static final java.lang.Character.UnicodeBlock BRAILLE_PATTERNS;
    field public static final java.lang.Character.UnicodeBlock BUGINESE;
    field public static final java.lang.Character.UnicodeBlock BUHID;
    field public static final java.lang.Character.UnicodeBlock BYZANTINE_MUSICAL_SYMBOLS;
    field public static final java.lang.Character.UnicodeBlock CARIAN;
    field public static final java.lang.Character.UnicodeBlock CAUCASIAN_ALBANIAN;
    field public static final java.lang.Character.UnicodeBlock CHAKMA;
    field public static final java.lang.Character.UnicodeBlock CHAM;
    field public static final java.lang.Character.UnicodeBlock CHEROKEE;
    field public static final java.lang.Character.UnicodeBlock CHEROKEE_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock CHESS_SYMBOLS;
    field public static final java.lang.Character.UnicodeBlock CHORASMIAN;
    field public static final java.lang.Character.UnicodeBlock CJK_COMPATIBILITY;
    field public static final java.lang.Character.UnicodeBlock CJK_COMPATIBILITY_FORMS;
    field public static final java.lang.Character.UnicodeBlock CJK_COMPATIBILITY_IDEOGRAPHS;
    field public static final java.lang.Character.UnicodeBlock CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock CJK_RADICALS_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock CJK_STROKES;
    field public static final java.lang.Character.UnicodeBlock CJK_SYMBOLS_AND_PUNCTUATION;
    field public static final java.lang.Character.UnicodeBlock CJK_UNIFIED_IDEOGRAPHS;
    field public static final java.lang.Character.UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A;
    field public static final java.lang.Character.UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B;
    field public static final java.lang.Character.UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C;
    field public static final java.lang.Character.UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D;
    field public static final java.lang.Character.UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_E;
    field public static final java.lang.Character.UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_F;
    field public static final java.lang.Character.UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_G;
    field public static final java.lang.Character.UnicodeBlock COMBINING_DIACRITICAL_MARKS;
    field public static final java.lang.Character.UnicodeBlock COMBINING_DIACRITICAL_MARKS_EXTENDED;
    field public static final java.lang.Character.UnicodeBlock COMBINING_DIACRITICAL_MARKS_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock COMBINING_HALF_MARKS;
    field public static final java.lang.Character.UnicodeBlock COMBINING_MARKS_FOR_SYMBOLS;
    field public static final java.lang.Character.UnicodeBlock COMMON_INDIC_NUMBER_FORMS;
    field public static final java.lang.Character.UnicodeBlock CONTROL_PICTURES;
    field public static final java.lang.Character.UnicodeBlock COPTIC;
    field public static final java.lang.Character.UnicodeBlock COPTIC_EPACT_NUMBERS;
    field public static final java.lang.Character.UnicodeBlock COUNTING_ROD_NUMERALS;
    field public static final java.lang.Character.UnicodeBlock CUNEIFORM;
    field public static final java.lang.Character.UnicodeBlock CUNEIFORM_NUMBERS_AND_PUNCTUATION;
    field public static final java.lang.Character.UnicodeBlock CURRENCY_SYMBOLS;
    field public static final java.lang.Character.UnicodeBlock CYPRIOT_SYLLABARY;
    field public static final java.lang.Character.UnicodeBlock CYRILLIC;
    field public static final java.lang.Character.UnicodeBlock CYRILLIC_EXTENDED_A;
    field public static final java.lang.Character.UnicodeBlock CYRILLIC_EXTENDED_B;
    field public static final java.lang.Character.UnicodeBlock CYRILLIC_EXTENDED_C;
    field public static final java.lang.Character.UnicodeBlock CYRILLIC_SUPPLEMENTARY;
    field public static final java.lang.Character.UnicodeBlock DESERET;
    field public static final java.lang.Character.UnicodeBlock DEVANAGARI;
    field public static final java.lang.Character.UnicodeBlock DEVANAGARI_EXTENDED;
    field public static final java.lang.Character.UnicodeBlock DINGBATS;
    field public static final java.lang.Character.UnicodeBlock DIVES_AKURU;
    field public static final java.lang.Character.UnicodeBlock DOGRA;
    field public static final java.lang.Character.UnicodeBlock DOMINO_TILES;
    field public static final java.lang.Character.UnicodeBlock DUPLOYAN;
    field public static final java.lang.Character.UnicodeBlock EARLY_DYNASTIC_CUNEIFORM;
    field public static final java.lang.Character.UnicodeBlock EGYPTIAN_HIEROGLYPHS;
    field public static final java.lang.Character.UnicodeBlock EGYPTIAN_HIEROGLYPH_FORMAT_CONTROLS;
    field public static final java.lang.Character.UnicodeBlock ELBASAN;
    field public static final java.lang.Character.UnicodeBlock ELYMAIC;
    field public static final java.lang.Character.UnicodeBlock EMOTICONS;
    field public static final java.lang.Character.UnicodeBlock ENCLOSED_ALPHANUMERICS;
    field public static final java.lang.Character.UnicodeBlock ENCLOSED_ALPHANUMERIC_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock ENCLOSED_CJK_LETTERS_AND_MONTHS;
    field public static final java.lang.Character.UnicodeBlock ENCLOSED_IDEOGRAPHIC_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock ETHIOPIC;
    field public static final java.lang.Character.UnicodeBlock ETHIOPIC_EXTENDED;
    field public static final java.lang.Character.UnicodeBlock ETHIOPIC_EXTENDED_A;
    field public static final java.lang.Character.UnicodeBlock ETHIOPIC_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock GENERAL_PUNCTUATION;
    field public static final java.lang.Character.UnicodeBlock GEOMETRIC_SHAPES;
    field public static final java.lang.Character.UnicodeBlock GEOMETRIC_SHAPES_EXTENDED;
    field public static final java.lang.Character.UnicodeBlock GEORGIAN;
    field public static final java.lang.Character.UnicodeBlock GEORGIAN_EXTENDED;
    field public static final java.lang.Character.UnicodeBlock GEORGIAN_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock GLAGOLITIC;
    field public static final java.lang.Character.UnicodeBlock GLAGOLITIC_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock GOTHIC;
    field public static final java.lang.Character.UnicodeBlock GRANTHA;
    field public static final java.lang.Character.UnicodeBlock GREEK;
    field public static final java.lang.Character.UnicodeBlock GREEK_EXTENDED;
    field public static final java.lang.Character.UnicodeBlock GUJARATI;
    field public static final java.lang.Character.UnicodeBlock GUNJALA_GONDI;
    field public static final java.lang.Character.UnicodeBlock GURMUKHI;
    field public static final java.lang.Character.UnicodeBlock HALFWIDTH_AND_FULLWIDTH_FORMS;
    field public static final java.lang.Character.UnicodeBlock HANGUL_COMPATIBILITY_JAMO;
    field public static final java.lang.Character.UnicodeBlock HANGUL_JAMO;
    field public static final java.lang.Character.UnicodeBlock HANGUL_JAMO_EXTENDED_A;
    field public static final java.lang.Character.UnicodeBlock HANGUL_JAMO_EXTENDED_B;
    field public static final java.lang.Character.UnicodeBlock HANGUL_SYLLABLES;
    field public static final java.lang.Character.UnicodeBlock HANIFI_ROHINGYA;
    field public static final java.lang.Character.UnicodeBlock HANUNOO;
    field public static final java.lang.Character.UnicodeBlock HATRAN;
    field public static final java.lang.Character.UnicodeBlock HEBREW;
    field public static final java.lang.Character.UnicodeBlock HIGH_PRIVATE_USE_SURROGATES;
    field public static final java.lang.Character.UnicodeBlock HIGH_SURROGATES;
    field public static final java.lang.Character.UnicodeBlock HIRAGANA;
    field public static final java.lang.Character.UnicodeBlock IDEOGRAPHIC_DESCRIPTION_CHARACTERS;
    field public static final java.lang.Character.UnicodeBlock IDEOGRAPHIC_SYMBOLS_AND_PUNCTUATION;
    field public static final java.lang.Character.UnicodeBlock IMPERIAL_ARAMAIC;
    field public static final java.lang.Character.UnicodeBlock INDIC_SIYAQ_NUMBERS;
    field public static final java.lang.Character.UnicodeBlock INSCRIPTIONAL_PAHLAVI;
    field public static final java.lang.Character.UnicodeBlock INSCRIPTIONAL_PARTHIAN;
    field public static final java.lang.Character.UnicodeBlock IPA_EXTENSIONS;
    field public static final java.lang.Character.UnicodeBlock JAVANESE;
    field public static final java.lang.Character.UnicodeBlock KAITHI;
    field public static final java.lang.Character.UnicodeBlock KANA_EXTENDED_A;
    field public static final java.lang.Character.UnicodeBlock KANA_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock KANBUN;
    field public static final java.lang.Character.UnicodeBlock KANGXI_RADICALS;
    field public static final java.lang.Character.UnicodeBlock KANNADA;
    field public static final java.lang.Character.UnicodeBlock KATAKANA;
    field public static final java.lang.Character.UnicodeBlock KATAKANA_PHONETIC_EXTENSIONS;
    field public static final java.lang.Character.UnicodeBlock KAYAH_LI;
    field public static final java.lang.Character.UnicodeBlock KHAROSHTHI;
    field public static final java.lang.Character.UnicodeBlock KHITAN_SMALL_SCRIPT;
    field public static final java.lang.Character.UnicodeBlock KHMER;
    field public static final java.lang.Character.UnicodeBlock KHMER_SYMBOLS;
    field public static final java.lang.Character.UnicodeBlock KHOJKI;
    field public static final java.lang.Character.UnicodeBlock KHUDAWADI;
    field public static final java.lang.Character.UnicodeBlock LAO;
    field public static final java.lang.Character.UnicodeBlock LATIN_1_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock LATIN_EXTENDED_A;
    field public static final java.lang.Character.UnicodeBlock LATIN_EXTENDED_ADDITIONAL;
    field public static final java.lang.Character.UnicodeBlock LATIN_EXTENDED_B;
    field public static final java.lang.Character.UnicodeBlock LATIN_EXTENDED_C;
    field public static final java.lang.Character.UnicodeBlock LATIN_EXTENDED_D;
    field public static final java.lang.Character.UnicodeBlock LATIN_EXTENDED_E;
    field public static final java.lang.Character.UnicodeBlock LEPCHA;
    field public static final java.lang.Character.UnicodeBlock LETTERLIKE_SYMBOLS;
    field public static final java.lang.Character.UnicodeBlock LIMBU;
    field public static final java.lang.Character.UnicodeBlock LINEAR_A;
    field public static final java.lang.Character.UnicodeBlock LINEAR_B_IDEOGRAMS;
    field public static final java.lang.Character.UnicodeBlock LINEAR_B_SYLLABARY;
    field public static final java.lang.Character.UnicodeBlock LISU;
    field public static final java.lang.Character.UnicodeBlock LISU_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock LOW_SURROGATES;
    field public static final java.lang.Character.UnicodeBlock LYCIAN;
    field public static final java.lang.Character.UnicodeBlock LYDIAN;
    field public static final java.lang.Character.UnicodeBlock MAHAJANI;
    field public static final java.lang.Character.UnicodeBlock MAHJONG_TILES;
    field public static final java.lang.Character.UnicodeBlock MAKASAR;
    field public static final java.lang.Character.UnicodeBlock MALAYALAM;
    field public static final java.lang.Character.UnicodeBlock MANDAIC;
    field public static final java.lang.Character.UnicodeBlock MANICHAEAN;
    field public static final java.lang.Character.UnicodeBlock MARCHEN;
    field public static final java.lang.Character.UnicodeBlock MASARAM_GONDI;
    field public static final java.lang.Character.UnicodeBlock MATHEMATICAL_ALPHANUMERIC_SYMBOLS;
    field public static final java.lang.Character.UnicodeBlock MATHEMATICAL_OPERATORS;
    field public static final java.lang.Character.UnicodeBlock MAYAN_NUMERALS;
    field public static final java.lang.Character.UnicodeBlock MEDEFAIDRIN;
    field public static final java.lang.Character.UnicodeBlock MEETEI_MAYEK;
    field public static final java.lang.Character.UnicodeBlock MEETEI_MAYEK_EXTENSIONS;
    field public static final java.lang.Character.UnicodeBlock MENDE_KIKAKUI;
    field public static final java.lang.Character.UnicodeBlock MEROITIC_CURSIVE;
    field public static final java.lang.Character.UnicodeBlock MEROITIC_HIEROGLYPHS;
    field public static final java.lang.Character.UnicodeBlock MIAO;
    field public static final java.lang.Character.UnicodeBlock MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A;
    field public static final java.lang.Character.UnicodeBlock MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B;
    field public static final java.lang.Character.UnicodeBlock MISCELLANEOUS_SYMBOLS;
    field public static final java.lang.Character.UnicodeBlock MISCELLANEOUS_SYMBOLS_AND_ARROWS;
    field public static final java.lang.Character.UnicodeBlock MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS;
    field public static final java.lang.Character.UnicodeBlock MISCELLANEOUS_TECHNICAL;
    field public static final java.lang.Character.UnicodeBlock MODI;
    field public static final java.lang.Character.UnicodeBlock MODIFIER_TONE_LETTERS;
    field public static final java.lang.Character.UnicodeBlock MONGOLIAN;
    field public static final java.lang.Character.UnicodeBlock MONGOLIAN_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock MRO;
    field public static final java.lang.Character.UnicodeBlock MULTANI;
    field public static final java.lang.Character.UnicodeBlock MUSICAL_SYMBOLS;
    field public static final java.lang.Character.UnicodeBlock MYANMAR;
    field public static final java.lang.Character.UnicodeBlock MYANMAR_EXTENDED_A;
    field public static final java.lang.Character.UnicodeBlock MYANMAR_EXTENDED_B;
    field public static final java.lang.Character.UnicodeBlock NABATAEAN;
    field public static final java.lang.Character.UnicodeBlock NANDINAGARI;
    field public static final java.lang.Character.UnicodeBlock NEWA;
    field public static final java.lang.Character.UnicodeBlock NEW_TAI_LUE;
    field public static final java.lang.Character.UnicodeBlock NKO;
    field public static final java.lang.Character.UnicodeBlock NUMBER_FORMS;
    field public static final java.lang.Character.UnicodeBlock NUSHU;
    field public static final java.lang.Character.UnicodeBlock NYIAKENG_PUACHUE_HMONG;
    field public static final java.lang.Character.UnicodeBlock OGHAM;
    field public static final java.lang.Character.UnicodeBlock OLD_HUNGARIAN;
    field public static final java.lang.Character.UnicodeBlock OLD_ITALIC;
    field public static final java.lang.Character.UnicodeBlock OLD_NORTH_ARABIAN;
    field public static final java.lang.Character.UnicodeBlock OLD_PERMIC;
    field public static final java.lang.Character.UnicodeBlock OLD_PERSIAN;
    field public static final java.lang.Character.UnicodeBlock OLD_SOGDIAN;
    field public static final java.lang.Character.UnicodeBlock OLD_SOUTH_ARABIAN;
    field public static final java.lang.Character.UnicodeBlock OLD_TURKIC;
    field public static final java.lang.Character.UnicodeBlock OL_CHIKI;
    field public static final java.lang.Character.UnicodeBlock OPTICAL_CHARACTER_RECOGNITION;
    field public static final java.lang.Character.UnicodeBlock ORIYA;
    field public static final java.lang.Character.UnicodeBlock ORNAMENTAL_DINGBATS;
    field public static final java.lang.Character.UnicodeBlock OSAGE;
    field public static final java.lang.Character.UnicodeBlock OSMANYA;
    field public static final java.lang.Character.UnicodeBlock OTTOMAN_SIYAQ_NUMBERS;
    field public static final java.lang.Character.UnicodeBlock PAHAWH_HMONG;
    field public static final java.lang.Character.UnicodeBlock PALMYRENE;
    field public static final java.lang.Character.UnicodeBlock PAU_CIN_HAU;
    field public static final java.lang.Character.UnicodeBlock PHAGS_PA;
    field public static final java.lang.Character.UnicodeBlock PHAISTOS_DISC;
    field public static final java.lang.Character.UnicodeBlock PHOENICIAN;
    field public static final java.lang.Character.UnicodeBlock PHONETIC_EXTENSIONS;
    field public static final java.lang.Character.UnicodeBlock PHONETIC_EXTENSIONS_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock PLAYING_CARDS;
    field public static final java.lang.Character.UnicodeBlock PRIVATE_USE_AREA;
    field public static final java.lang.Character.UnicodeBlock PSALTER_PAHLAVI;
    field public static final java.lang.Character.UnicodeBlock REJANG;
    field public static final java.lang.Character.UnicodeBlock RUMI_NUMERAL_SYMBOLS;
    field public static final java.lang.Character.UnicodeBlock RUNIC;
    field public static final java.lang.Character.UnicodeBlock SAMARITAN;
    field public static final java.lang.Character.UnicodeBlock SAURASHTRA;
    field public static final java.lang.Character.UnicodeBlock SHARADA;
    field public static final java.lang.Character.UnicodeBlock SHAVIAN;
    field public static final java.lang.Character.UnicodeBlock SHORTHAND_FORMAT_CONTROLS;
    field public static final java.lang.Character.UnicodeBlock SIDDHAM;
    field public static final java.lang.Character.UnicodeBlock SINHALA;
    field public static final java.lang.Character.UnicodeBlock SINHALA_ARCHAIC_NUMBERS;
    field public static final java.lang.Character.UnicodeBlock SMALL_FORM_VARIANTS;
    field public static final java.lang.Character.UnicodeBlock SMALL_KANA_EXTENSION;
    field public static final java.lang.Character.UnicodeBlock SOGDIAN;
    field public static final java.lang.Character.UnicodeBlock SORA_SOMPENG;
    field public static final java.lang.Character.UnicodeBlock SOYOMBO;
    field public static final java.lang.Character.UnicodeBlock SPACING_MODIFIER_LETTERS;
    field public static final java.lang.Character.UnicodeBlock SPECIALS;
    field public static final java.lang.Character.UnicodeBlock SUNDANESE;
    field public static final java.lang.Character.UnicodeBlock SUNDANESE_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock SUPERSCRIPTS_AND_SUBSCRIPTS;
    field public static final java.lang.Character.UnicodeBlock SUPPLEMENTAL_ARROWS_A;
    field public static final java.lang.Character.UnicodeBlock SUPPLEMENTAL_ARROWS_B;
    field public static final java.lang.Character.UnicodeBlock SUPPLEMENTAL_ARROWS_C;
    field public static final java.lang.Character.UnicodeBlock SUPPLEMENTAL_MATHEMATICAL_OPERATORS;
    field public static final java.lang.Character.UnicodeBlock SUPPLEMENTAL_PUNCTUATION;
    field public static final java.lang.Character.UnicodeBlock SUPPLEMENTAL_SYMBOLS_AND_PICTOGRAPHS;
    field public static final java.lang.Character.UnicodeBlock SUPPLEMENTARY_PRIVATE_USE_AREA_A;
    field public static final java.lang.Character.UnicodeBlock SUPPLEMENTARY_PRIVATE_USE_AREA_B;
    field @Deprecated public static final java.lang.Character.UnicodeBlock SURROGATES_AREA;
    field public static final java.lang.Character.UnicodeBlock SUTTON_SIGNWRITING;
    field public static final java.lang.Character.UnicodeBlock SYLOTI_NAGRI;
    field public static final java.lang.Character.UnicodeBlock SYMBOLS_AND_PICTOGRAPHS_EXTENDED_A;
    field public static final java.lang.Character.UnicodeBlock SYMBOLS_FOR_LEGACY_COMPUTING;
    field public static final java.lang.Character.UnicodeBlock SYRIAC;
    field public static final java.lang.Character.UnicodeBlock SYRIAC_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock TAGALOG;
    field public static final java.lang.Character.UnicodeBlock TAGBANWA;
    field public static final java.lang.Character.UnicodeBlock TAGS;
    field public static final java.lang.Character.UnicodeBlock TAI_LE;
    field public static final java.lang.Character.UnicodeBlock TAI_THAM;
    field public static final java.lang.Character.UnicodeBlock TAI_VIET;
    field public static final java.lang.Character.UnicodeBlock TAI_XUAN_JING_SYMBOLS;
    field public static final java.lang.Character.UnicodeBlock TAKRI;
    field public static final java.lang.Character.UnicodeBlock TAMIL;
    field public static final java.lang.Character.UnicodeBlock TAMIL_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock TANGUT;
    field public static final java.lang.Character.UnicodeBlock TANGUT_COMPONENTS;
    field public static final java.lang.Character.UnicodeBlock TANGUT_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock TELUGU;
    field public static final java.lang.Character.UnicodeBlock THAANA;
    field public static final java.lang.Character.UnicodeBlock THAI;
    field public static final java.lang.Character.UnicodeBlock TIBETAN;
    field public static final java.lang.Character.UnicodeBlock TIFINAGH;
    field public static final java.lang.Character.UnicodeBlock TIRHUTA;
    field public static final java.lang.Character.UnicodeBlock TRANSPORT_AND_MAP_SYMBOLS;
    field public static final java.lang.Character.UnicodeBlock UGARITIC;
    field public static final java.lang.Character.UnicodeBlock UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS;
    field public static final java.lang.Character.UnicodeBlock UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED;
    field public static final java.lang.Character.UnicodeBlock VAI;
    field public static final java.lang.Character.UnicodeBlock VARIATION_SELECTORS;
    field public static final java.lang.Character.UnicodeBlock VARIATION_SELECTORS_SUPPLEMENT;
    field public static final java.lang.Character.UnicodeBlock VEDIC_EXTENSIONS;
    field public static final java.lang.Character.UnicodeBlock VERTICAL_FORMS;
    field public static final java.lang.Character.UnicodeBlock WANCHO;
    field public static final java.lang.Character.UnicodeBlock WARANG_CITI;
    field public static final java.lang.Character.UnicodeBlock YEZIDI;
    field public static final java.lang.Character.UnicodeBlock YIJING_HEXAGRAM_SYMBOLS;
    field public static final java.lang.Character.UnicodeBlock YI_RADICALS;
    field public static final java.lang.Character.UnicodeBlock YI_SYLLABLES;
    field public static final java.lang.Character.UnicodeBlock ZANABAZAR_SQUARE;
  }

  public enum Character.UnicodeScript {
    method @NonNull public static final java.lang.Character.UnicodeScript forName(@NonNull String);
    method @NonNull public static java.lang.Character.UnicodeScript of(int);
    enum_constant public static final java.lang.Character.UnicodeScript ADLAM;
    enum_constant public static final java.lang.Character.UnicodeScript AHOM;
    enum_constant public static final java.lang.Character.UnicodeScript ANATOLIAN_HIEROGLYPHS;
    enum_constant public static final java.lang.Character.UnicodeScript ARABIC;
    enum_constant public static final java.lang.Character.UnicodeScript ARMENIAN;
    enum_constant public static final java.lang.Character.UnicodeScript AVESTAN;
    enum_constant public static final java.lang.Character.UnicodeScript BALINESE;
    enum_constant public static final java.lang.Character.UnicodeScript BAMUM;
    enum_constant public static final java.lang.Character.UnicodeScript BASSA_VAH;
    enum_constant public static final java.lang.Character.UnicodeScript BATAK;
    enum_constant public static final java.lang.Character.UnicodeScript BENGALI;
    enum_constant public static final java.lang.Character.UnicodeScript BHAIKSUKI;
    enum_constant public static final java.lang.Character.UnicodeScript BOPOMOFO;
    enum_constant public static final java.lang.Character.UnicodeScript BRAHMI;
    enum_constant public static final java.lang.Character.UnicodeScript BRAILLE;
    enum_constant public static final java.lang.Character.UnicodeScript BUGINESE;
    enum_constant public static final java.lang.Character.UnicodeScript BUHID;
    enum_constant public static final java.lang.Character.UnicodeScript CANADIAN_ABORIGINAL;
    enum_constant public static final java.lang.Character.UnicodeScript CARIAN;
    enum_constant public static final java.lang.Character.UnicodeScript CAUCASIAN_ALBANIAN;
    enum_constant public static final java.lang.Character.UnicodeScript CHAKMA;
    enum_constant public static final java.lang.Character.UnicodeScript CHAM;
    enum_constant public static final java.lang.Character.UnicodeScript CHEROKEE;
    enum_constant public static final java.lang.Character.UnicodeScript CHORASMIAN;
    enum_constant public static final java.lang.Character.UnicodeScript COMMON;
    enum_constant public static final java.lang.Character.UnicodeScript COPTIC;
    enum_constant public static final java.lang.Character.UnicodeScript CUNEIFORM;
    enum_constant public static final java.lang.Character.UnicodeScript CYPRIOT;
    enum_constant public static final java.lang.Character.UnicodeScript CYRILLIC;
    enum_constant public static final java.lang.Character.UnicodeScript DESERET;
    enum_constant public static final java.lang.Character.UnicodeScript DEVANAGARI;
    enum_constant public static final java.lang.Character.UnicodeScript DIVES_AKURU;
    enum_constant public static final java.lang.Character.UnicodeScript DOGRA;
    enum_constant public static final java.lang.Character.UnicodeScript DUPLOYAN;
    enum_constant public static final java.lang.Character.UnicodeScript EGYPTIAN_HIEROGLYPHS;
    enum_constant public static final java.lang.Character.UnicodeScript ELBASAN;
    enum_constant public static final java.lang.Character.UnicodeScript ELYMAIC;
    enum_constant public static final java.lang.Character.UnicodeScript ETHIOPIC;
    enum_constant public static final java.lang.Character.UnicodeScript GEORGIAN;
    enum_constant public static final java.lang.Character.UnicodeScript GLAGOLITIC;
    enum_constant public static final java.lang.Character.UnicodeScript GOTHIC;
    enum_constant public static final java.lang.Character.UnicodeScript GRANTHA;
    enum_constant public static final java.lang.Character.UnicodeScript GREEK;
    enum_constant public static final java.lang.Character.UnicodeScript GUJARATI;
    enum_constant public static final java.lang.Character.UnicodeScript GUNJALA_GONDI;
    enum_constant public static final java.lang.Character.UnicodeScript GURMUKHI;
    enum_constant public static final java.lang.Character.UnicodeScript HAN;
    enum_constant public static final java.lang.Character.UnicodeScript HANGUL;
    enum_constant public static final java.lang.Character.UnicodeScript HANIFI_ROHINGYA;
    enum_constant public static final java.lang.Character.UnicodeScript HANUNOO;
    enum_constant public static final java.lang.Character.UnicodeScript HATRAN;
    enum_constant public static final java.lang.Character.UnicodeScript HEBREW;
    enum_constant public static final java.lang.Character.UnicodeScript HIRAGANA;
    enum_constant public static final java.lang.Character.UnicodeScript IMPERIAL_ARAMAIC;
    enum_constant public static final java.lang.Character.UnicodeScript INHERITED;
    enum_constant public static final java.lang.Character.UnicodeScript INSCRIPTIONAL_PAHLAVI;
    enum_constant public static final java.lang.Character.UnicodeScript INSCRIPTIONAL_PARTHIAN;
    enum_constant public static final java.lang.Character.UnicodeScript JAVANESE;
    enum_constant public static final java.lang.Character.UnicodeScript KAITHI;
    enum_constant public static final java.lang.Character.UnicodeScript KANNADA;
    enum_constant public static final java.lang.Character.UnicodeScript KATAKANA;
    enum_constant public static final java.lang.Character.UnicodeScript KAYAH_LI;
    enum_constant public static final java.lang.Character.UnicodeScript KHAROSHTHI;
    enum_constant public static final java.lang.Character.UnicodeScript KHITAN_SMALL_SCRIPT;
    enum_constant public static final java.lang.Character.UnicodeScript KHMER;
    enum_constant public static final java.lang.Character.UnicodeScript KHOJKI;
    enum_constant public static final java.lang.Character.UnicodeScript KHUDAWADI;
    enum_constant public static final java.lang.Character.UnicodeScript LAO;
    enum_constant public static final java.lang.Character.UnicodeScript LATIN;
    enum_constant public static final java.lang.Character.UnicodeScript LEPCHA;
    enum_constant public static final java.lang.Character.UnicodeScript LIMBU;
    enum_constant public static final java.lang.Character.UnicodeScript LINEAR_A;
    enum_constant public static final java.lang.Character.UnicodeScript LINEAR_B;
    enum_constant public static final java.lang.Character.UnicodeScript LISU;
    enum_constant public static final java.lang.Character.UnicodeScript LYCIAN;
    enum_constant public static final java.lang.Character.UnicodeScript LYDIAN;
    enum_constant public static final java.lang.Character.UnicodeScript MAHAJANI;
    enum_constant public static final java.lang.Character.UnicodeScript MAKASAR;
    enum_constant public static final java.lang.Character.UnicodeScript MALAYALAM;
    enum_constant public static final java.lang.Character.UnicodeScript MANDAIC;
    enum_constant public static final java.lang.Character.UnicodeScript MANICHAEAN;
    enum_constant public static final java.lang.Character.UnicodeScript MARCHEN;
    enum_constant public static final java.lang.Character.UnicodeScript MASARAM_GONDI;
    enum_constant public static final java.lang.Character.UnicodeScript MEDEFAIDRIN;
    enum_constant public static final java.lang.Character.UnicodeScript MEETEI_MAYEK;
    enum_constant public static final java.lang.Character.UnicodeScript MENDE_KIKAKUI;
    enum_constant public static final java.lang.Character.UnicodeScript MEROITIC_CURSIVE;
    enum_constant public static final java.lang.Character.UnicodeScript MEROITIC_HIEROGLYPHS;
    enum_constant public static final java.lang.Character.UnicodeScript MIAO;
    enum_constant public static final java.lang.Character.UnicodeScript MODI;
    enum_constant public static final java.lang.Character.UnicodeScript MONGOLIAN;
    enum_constant public static final java.lang.Character.UnicodeScript MRO;
    enum_constant public static final java.lang.Character.UnicodeScript MULTANI;
    enum_constant public static final java.lang.Character.UnicodeScript MYANMAR;
    enum_constant public static final java.lang.Character.UnicodeScript NABATAEAN;
    enum_constant public static final java.lang.Character.UnicodeScript NANDINAGARI;
    enum_constant public static final java.lang.Character.UnicodeScript NEWA;
    enum_constant public static final java.lang.Character.UnicodeScript NEW_TAI_LUE;
    enum_constant public static final java.lang.Character.UnicodeScript NKO;
    enum_constant public static final java.lang.Character.UnicodeScript NUSHU;
    enum_constant public static final java.lang.Character.UnicodeScript NYIAKENG_PUACHUE_HMONG;
    enum_constant public static final java.lang.Character.UnicodeScript OGHAM;
    enum_constant public static final java.lang.Character.UnicodeScript OLD_HUNGARIAN;
    enum_constant public static final java.lang.Character.UnicodeScript OLD_ITALIC;
    enum_constant public static final java.lang.Character.UnicodeScript OLD_NORTH_ARABIAN;
    enum_constant public static final java.lang.Character.UnicodeScript OLD_PERMIC;
    enum_constant public static final java.lang.Character.UnicodeScript OLD_PERSIAN;
    enum_constant public static final java.lang.Character.UnicodeScript OLD_SOGDIAN;
    enum_constant public static final java.lang.Character.UnicodeScript OLD_SOUTH_ARABIAN;
    enum_constant public static final java.lang.Character.UnicodeScript OLD_TURKIC;
    enum_constant public static final java.lang.Character.UnicodeScript OL_CHIKI;
    enum_constant public static final java.lang.Character.UnicodeScript ORIYA;
    enum_constant public static final java.lang.Character.UnicodeScript OSAGE;
    enum_constant public static final java.lang.Character.UnicodeScript OSMANYA;
    enum_constant public static final java.lang.Character.UnicodeScript PAHAWH_HMONG;
    enum_constant public static final java.lang.Character.UnicodeScript PALMYRENE;
    enum_constant public static final java.lang.Character.UnicodeScript PAU_CIN_HAU;
    enum_constant public static final java.lang.Character.UnicodeScript PHAGS_PA;
    enum_constant public static final java.lang.Character.UnicodeScript PHOENICIAN;
    enum_constant public static final java.lang.Character.UnicodeScript PSALTER_PAHLAVI;
    enum_constant public static final java.lang.Character.UnicodeScript REJANG;
    enum_constant public static final java.lang.Character.UnicodeScript RUNIC;
    enum_constant public static final java.lang.Character.UnicodeScript SAMARITAN;
    enum_constant public static final java.lang.Character.UnicodeScript SAURASHTRA;
    enum_constant public static final java.lang.Character.UnicodeScript SHARADA;
    enum_constant public static final java.lang.Character.UnicodeScript SHAVIAN;
    enum_constant public static final java.lang.Character.UnicodeScript SIDDHAM;
    enum_constant public static final java.lang.Character.UnicodeScript SIGNWRITING;
    enum_constant public static final java.lang.Character.UnicodeScript SINHALA;
    enum_constant public static final java.lang.Character.UnicodeScript SOGDIAN;
    enum_constant public static final java.lang.Character.UnicodeScript SORA_SOMPENG;
    enum_constant public static final java.lang.Character.UnicodeScript SOYOMBO;
    enum_constant public static final java.lang.Character.UnicodeScript SUNDANESE;
    enum_constant public static final java.lang.Character.UnicodeScript SYLOTI_NAGRI;
    enum_constant public static final java.lang.Character.UnicodeScript SYRIAC;
    enum_constant public static final java.lang.Character.UnicodeScript TAGALOG;
    enum_constant public static final java.lang.Character.UnicodeScript TAGBANWA;
    enum_constant public static final java.lang.Character.UnicodeScript TAI_LE;
    enum_constant public static final java.lang.Character.UnicodeScript TAI_THAM;
    enum_constant public static final java.lang.Character.UnicodeScript TAI_VIET;
    enum_constant public static final java.lang.Character.UnicodeScript TAKRI;
    enum_constant public static final java.lang.Character.UnicodeScript TAMIL;
    enum_constant public static final java.lang.Character.UnicodeScript TANGUT;
    enum_constant public static final java.lang.Character.UnicodeScript TELUGU;
    enum_constant public static final java.lang.Character.UnicodeScript THAANA;
    enum_constant public static final java.lang.Character.UnicodeScript THAI;
    enum_constant public static final java.lang.Character.UnicodeScript TIBETAN;
    enum_constant public static final java.lang.Character.UnicodeScript TIFINAGH;
    enum_constant public static final java.lang.Character.UnicodeScript TIRHUTA;
    enum_constant public static final java.lang.Character.UnicodeScript UGARITIC;
    enum_constant public static final java.lang.Character.UnicodeScript UNKNOWN;
    enum_constant public static final java.lang.Character.UnicodeScript VAI;
    enum_constant public static final java.lang.Character.UnicodeScript WANCHO;
    enum_constant public static final java.lang.Character.UnicodeScript WARANG_CITI;
    enum_constant public static final java.lang.Character.UnicodeScript YEZIDI;
    enum_constant public static final java.lang.Character.UnicodeScript YI;
    enum_constant public static final java.lang.Character.UnicodeScript ZANABAZAR_SQUARE;
  }

  public final class Class<T> implements java.lang.reflect.AnnotatedElement java.lang.reflect.GenericDeclaration java.io.Serializable java.lang.reflect.Type java.lang.invoke.TypeDescriptor.OfField<java.lang.Class<?>> {
    method @NonNull public Class<?> arrayType();
    method @NonNull public <U> Class<? extends U> asSubclass(@NonNull Class<U>);
    method @Nullable public T cast(@Nullable Object);
    method @Nullable public Class<?> componentType();
    method @NonNull public String descriptorString();
    method public boolean desiredAssertionStatus();
    method @NonNull public static Class<?> forName(@NonNull String) throws java.lang.ClassNotFoundException;
    method @NonNull public static Class<?> forName(@NonNull String, boolean, @Nullable ClassLoader) throws java.lang.ClassNotFoundException;
    method @Nullable public <A extends java.lang.annotation.Annotation> A getAnnotation(@NonNull Class<A>);
    method @NonNull public java.lang.annotation.Annotation[] getAnnotations();
    method @NonNull public <A extends java.lang.annotation.Annotation> A[] getAnnotationsByType(@NonNull Class<A>);
    method @Nullable public String getCanonicalName();
    method @Nullable public ClassLoader getClassLoader();
    method @NonNull public Class<?>[] getClasses();
    method @Nullable public Class<?> getComponentType();
    method @NonNull public java.lang.reflect.Constructor<T> getConstructor(@Nullable Class<?>...) throws java.lang.NoSuchMethodException, java.lang.SecurityException;
    method @NonNull public java.lang.reflect.Constructor<?>[] getConstructors() throws java.lang.SecurityException;
    method @Nullable public <A extends java.lang.annotation.Annotation> A getDeclaredAnnotation(@NonNull Class<A>);
    method @NonNull public java.lang.annotation.Annotation[] getDeclaredAnnotations();
    method @NonNull public <A extends java.lang.annotation.Annotation> A[] getDeclaredAnnotationsByType(@NonNull Class<A>);
    method @NonNull public Class<?>[] getDeclaredClasses();
    method @NonNull public java.lang.reflect.Constructor<T> getDeclaredConstructor(@Nullable Class<?>...) throws java.lang.NoSuchMethodException, java.lang.SecurityException;
    method @NonNull public java.lang.reflect.Constructor<?>[] getDeclaredConstructors() throws java.lang.SecurityException;
    method @NonNull public java.lang.reflect.Field getDeclaredField(@NonNull String) throws java.lang.NoSuchFieldException;
    method @NonNull public java.lang.reflect.Field[] getDeclaredFields();
    method @NonNull public java.lang.reflect.Method getDeclaredMethod(@NonNull String, @Nullable Class<?>...) throws java.lang.NoSuchMethodException, java.lang.SecurityException;
    method @NonNull public java.lang.reflect.Method[] getDeclaredMethods() throws java.lang.SecurityException;
    method @Nullable public Class<?> getDeclaringClass();
    method @Nullable public Class<?> getEnclosingClass();
    method @Nullable public java.lang.reflect.Constructor<?> getEnclosingConstructor();
    method @Nullable public java.lang.reflect.Method getEnclosingMethod();
    method @Nullable public T[] getEnumConstants();
    method @NonNull public java.lang.reflect.Field getField(@NonNull String) throws java.lang.NoSuchFieldException;
    method @NonNull public java.lang.reflect.Field[] getFields() throws java.lang.SecurityException;
    method @NonNull public java.lang.reflect.Type[] getGenericInterfaces();
    method @Nullable public java.lang.reflect.Type getGenericSuperclass();
    method @NonNull public Class<?>[] getInterfaces();
    method @NonNull public java.lang.reflect.Method getMethod(@NonNull String, @Nullable Class<?>...) throws java.lang.NoSuchMethodException, java.lang.SecurityException;
    method @NonNull public java.lang.reflect.Method[] getMethods() throws java.lang.SecurityException;
    method public int getModifiers();
    method @NonNull public String getName();
    method @NonNull public Class<?> getNestHost();
    method @NonNull public Class<?>[] getNestMembers();
    method @Nullable public Package getPackage();
    method @NonNull public String getPackageName();
    method @Nullable public Class<?>[] getPermittedSubclasses();
    method @Nullable public java.security.ProtectionDomain getProtectionDomain();
    method @Nullable public java.lang.reflect.RecordComponent[] getRecordComponents();
    method @Nullable public java.net.URL getResource(@NonNull String);
    method @Nullable public java.io.InputStream getResourceAsStream(@NonNull String);
    method @Nullable public Object[] getSigners();
    method @NonNull public String getSimpleName();
    method @Nullable public Class<? super T> getSuperclass();
    method @NonNull public String getTypeName();
    method @NonNull public java.lang.reflect.TypeVariable<java.lang.Class<T>>[] getTypeParameters();
    method public boolean isAnnotation();
    method public boolean isAnnotationPresent(@NonNull Class<? extends java.lang.annotation.Annotation>);
    method public boolean isAnonymousClass();
    method public boolean isArray();
    method public boolean isAssignableFrom(@NonNull Class<?>);
    method public boolean isEnum();
    method public boolean isInstance(@Nullable Object);
    method public boolean isInterface();
    method public boolean isLocalClass();
    method public boolean isMemberClass();
    method public boolean isNestmateOf(@NonNull Class<?>);
    method public boolean isPrimitive();
    method public boolean isRecord();
    method public boolean isSealed();
    method public boolean isSynthetic();
    method @Deprecated @NonNull public T newInstance() throws java.lang.IllegalAccessException, java.lang.InstantiationException;
    method @NonNull public String toGenericString();
  }

  public class ClassCastException extends java.lang.RuntimeException {
    ctor public ClassCastException();
    ctor public ClassCastException(String);
  }

  public class ClassCircularityError extends java.lang.LinkageError {
    ctor public ClassCircularityError();
    ctor public ClassCircularityError(String);
  }

  public class ClassFormatError extends java.lang.LinkageError {
    ctor public ClassFormatError();
    ctor public ClassFormatError(String);
  }

  public abstract class ClassLoader {
    ctor protected ClassLoader(ClassLoader);
    ctor protected ClassLoader();
    method public void clearAssertionStatus();
    method @Deprecated protected final Class<?> defineClass(byte[], int, int) throws java.lang.ClassFormatError;
    method protected final Class<?> defineClass(String, byte[], int, int) throws java.lang.ClassFormatError;
    method protected final Class<?> defineClass(String, byte[], int, int, java.security.ProtectionDomain) throws java.lang.ClassFormatError;
    method protected final Class<?> defineClass(String, java.nio.ByteBuffer, java.security.ProtectionDomain) throws java.lang.ClassFormatError;
    method protected Package definePackage(String, String, String, String, String, String, String, java.net.URL) throws java.lang.IllegalArgumentException;
    method protected Class<?> findClass(String) throws java.lang.ClassNotFoundException;
    method protected String findLibrary(String);
    method protected final Class<?> findLoadedClass(String);
    method protected java.net.URL findResource(String);
    method protected java.util.Enumeration<java.net.URL> findResources(String) throws java.io.IOException;
    method protected final Class<?> findSystemClass(String) throws java.lang.ClassNotFoundException;
    method @Deprecated protected Package getPackage(String);
    method protected Package[] getPackages();
    method public final ClassLoader getParent();
    method public java.net.URL getResource(String);
    method public java.io.InputStream getResourceAsStream(String);
    method public java.util.Enumeration<java.net.URL> getResources(String) throws java.io.IOException;
    method public static ClassLoader getSystemClassLoader();
    method public static java.net.URL getSystemResource(String);
    method public static java.io.InputStream getSystemResourceAsStream(String);
    method public static java.util.Enumeration<java.net.URL> getSystemResources(String) throws java.io.IOException;
    method public Class<?> loadClass(String) throws java.lang.ClassNotFoundException;
    method protected Class<?> loadClass(String, boolean) throws java.lang.ClassNotFoundException;
    method protected static boolean registerAsParallelCapable();
    method protected final void resolveClass(Class<?>);
    method public void setClassAssertionStatus(String, boolean);
    method public void setDefaultAssertionStatus(boolean);
    method public void setPackageAssertionStatus(String, boolean);
    method protected final void setSigners(Class<?>, Object[]);
  }

  public class ClassNotFoundException extends java.lang.ReflectiveOperationException {
    ctor public ClassNotFoundException();
    ctor public ClassNotFoundException(String);
    ctor public ClassNotFoundException(String, Throwable);
    method public Throwable getException();
  }

  public abstract class ClassValue<T> {
    ctor protected ClassValue();
    method protected abstract T computeValue(Class<?>);
    method public T get(Class<?>);
    method public void remove(Class<?>);
  }

  public class CloneNotSupportedException extends java.lang.Exception {
    ctor public CloneNotSupportedException();
    ctor public CloneNotSupportedException(String);
  }

  public interface Cloneable {
  }

  public interface Comparable<T> {
    method public int compareTo(T);
  }

  public final class Compiler {
    method public static Object command(Object);
    method public static boolean compileClass(Class<?>);
    method public static boolean compileClasses(String);
    method public static void disable();
    method public static void enable();
  }

  @java.lang.annotation.Documented @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) @java.lang.annotation.Target({java.lang.annotation.ElementType.CONSTRUCTOR, java.lang.annotation.ElementType.FIELD, java.lang.annotation.ElementType.LOCAL_VARIABLE, java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.PACKAGE, java.lang.annotation.ElementType.MODULE, java.lang.annotation.ElementType.PARAMETER, java.lang.annotation.ElementType.TYPE}) public @interface Deprecated {
    method public abstract boolean forRemoval() default false;
    method public abstract String since() default "";
  }

  public final class Double extends java.lang.Number implements java.lang.Comparable<java.lang.Double> {
    ctor @Deprecated public Double(double);
    ctor @Deprecated public Double(@NonNull String) throws java.lang.NumberFormatException;
    method public static int compare(double, double);
    method public int compareTo(@NonNull Double);
    method public static long doubleToLongBits(double);
    method public static long doubleToRawLongBits(double);
    method public double doubleValue();
    method public float floatValue();
    method public static int hashCode(double);
    method public int intValue();
    method public static boolean isFinite(double);
    method public static boolean isInfinite(double);
    method public boolean isInfinite();
    method public static boolean isNaN(double);
    method public boolean isNaN();
    method public static double longBitsToDouble(long);
    method public long longValue();
    method public static double max(double, double);
    method public static double min(double, double);
    method public static double parseDouble(@NonNull String) throws java.lang.NumberFormatException;
    method public static double sum(double, double);
    method @NonNull public static String toHexString(double);
    method @NonNull public static String toString(double);
    method @NonNull public static Double valueOf(@NonNull String) throws java.lang.NumberFormatException;
    method @NonNull public static Double valueOf(double);
    field public static final int BYTES = 8; // 0x8
    field public static final int MAX_EXPONENT = 1023; // 0x3ff
    field public static final double MAX_VALUE = 1.7976931348623157E308;
    field public static final int MIN_EXPONENT = -1022; // 0xfffffc02
    field public static final double MIN_NORMAL = 2.2250738585072014E-308;
    field public static final double MIN_VALUE = 4.9E-324;
    field public static final double NEGATIVE_INFINITY = (-1.0/0.0);
    field public static final double NaN = (0.0/0.0);
    field public static final double POSITIVE_INFINITY = (1.0/0.0);
    field public static final int SIZE = 64; // 0x40
    field public static final Class<java.lang.Double> TYPE;
  }

  public abstract class Enum<E extends java.lang.Enum<E>> implements java.lang.Comparable<E> java.io.Serializable {
    ctor protected Enum(@NonNull String, int);
    method @NonNull protected final Object clone() throws java.lang.CloneNotSupportedException;
    method public final int compareTo(E);
    method public final boolean equals(@Nullable Object);
    method protected final void finalize();
    method @NonNull public final Class<E> getDeclaringClass();
    method public final int hashCode();
    method @NonNull public final String name();
    method public final int ordinal();
    method @NonNull public static <T extends java.lang.Enum<T>> T valueOf(@NonNull Class<T>, @NonNull String);
  }

  public class EnumConstantNotPresentException extends java.lang.RuntimeException {
    ctor public EnumConstantNotPresentException(Class<? extends java.lang.Enum>, String);
    method public String constantName();
    method public Class<? extends java.lang.Enum> enumType();
  }

  public class Error extends java.lang.Throwable {
    ctor public Error();
    ctor public Error(String);
    ctor public Error(String, Throwable);
    ctor public Error(Throwable);
    ctor protected Error(String, Throwable, boolean, boolean);
  }

  public class Exception extends java.lang.Throwable {
    ctor public Exception();
    ctor public Exception(String);
    ctor public Exception(String, Throwable);
    ctor public Exception(Throwable);
    ctor protected Exception(String, Throwable, boolean, boolean);
  }

  public class ExceptionInInitializerError extends java.lang.LinkageError {
    ctor public ExceptionInInitializerError();
    ctor public ExceptionInInitializerError(Throwable);
    ctor public ExceptionInInitializerError(String);
    method public Throwable getException();
  }

  public final class Float extends java.lang.Number implements java.lang.Comparable<java.lang.Float> {
    ctor @Deprecated public Float(float);
    ctor @Deprecated public Float(double);
    ctor @Deprecated public Float(@NonNull String) throws java.lang.NumberFormatException;
    method public static int compare(float, float);
    method public int compareTo(@NonNull Float);
    method public double doubleValue();
    method public static int floatToIntBits(float);
    method public static int floatToRawIntBits(float);
    method public float floatValue();
    method public static int hashCode(float);
    method public static float intBitsToFloat(int);
    method public int intValue();
    method public static boolean isFinite(float);
    method public static boolean isInfinite(float);
    method public boolean isInfinite();
    method public static boolean isNaN(float);
    method public boolean isNaN();
    method public long longValue();
    method public static float max(float, float);
    method public static float min(float, float);
    method public static float parseFloat(@NonNull String) throws java.lang.NumberFormatException;
    method public static float sum(float, float);
    method @NonNull public static String toHexString(float);
    method @NonNull public static String toString(float);
    method @NonNull public static Float valueOf(@NonNull String) throws java.lang.NumberFormatException;
    method @NonNull public static Float valueOf(float);
    field public static final int BYTES = 4; // 0x4
    field public static final int MAX_EXPONENT = 127; // 0x7f
    field public static final float MAX_VALUE = 3.4028235E38f;
    field public static final int MIN_EXPONENT = -126; // 0xffffff82
    field public static final float MIN_NORMAL = 1.17549435E-38f;
    field public static final float MIN_VALUE = 1.4E-45f;
    field public static final float NEGATIVE_INFINITY = (-1.0f/0.0f);
    field public static final float NaN = (0.0f/0.0f);
    field public static final float POSITIVE_INFINITY = (1.0f/0.0f);
    field public static final int SIZE = 32; // 0x20
    field public static final Class<java.lang.Float> TYPE;
  }

  @java.lang.annotation.Documented @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) @java.lang.annotation.Target(java.lang.annotation.ElementType.TYPE) public @interface FunctionalInterface {
  }

  public class IllegalAccessError extends java.lang.IncompatibleClassChangeError {
    ctor public IllegalAccessError();
    ctor public IllegalAccessError(String);
  }

  public class IllegalAccessException extends java.lang.ReflectiveOperationException {
    ctor public IllegalAccessException();
    ctor public IllegalAccessException(String);
  }

  public class IllegalArgumentException extends java.lang.RuntimeException {
    ctor public IllegalArgumentException();
    ctor public IllegalArgumentException(String);
    ctor public IllegalArgumentException(String, Throwable);
    ctor public IllegalArgumentException(Throwable);
  }

  public class IllegalMonitorStateException extends java.lang.RuntimeException {
    ctor public IllegalMonitorStateException();
    ctor public IllegalMonitorStateException(String);
  }

  public class IllegalStateException extends java.lang.RuntimeException {
    ctor public IllegalStateException();
    ctor public IllegalStateException(String);
    ctor public IllegalStateException(String, Throwable);
    ctor public IllegalStateException(Throwable);
  }

  public class IllegalThreadStateException extends java.lang.IllegalArgumentException {
    ctor public IllegalThreadStateException();
    ctor public IllegalThreadStateException(String);
  }

  public class IncompatibleClassChangeError extends java.lang.LinkageError {
    ctor public IncompatibleClassChangeError();
    ctor public IncompatibleClassChangeError(String);
  }

  public class IndexOutOfBoundsException extends java.lang.RuntimeException {
    ctor public IndexOutOfBoundsException();
    ctor public IndexOutOfBoundsException(String);
    ctor public IndexOutOfBoundsException(int);
    ctor public IndexOutOfBoundsException(long);
  }

  public class InheritableThreadLocal<T> extends java.lang.ThreadLocal<T> {
    ctor public InheritableThreadLocal();
    method protected T childValue(T);
  }

  public class InstantiationError extends java.lang.IncompatibleClassChangeError {
    ctor public InstantiationError();
    ctor public InstantiationError(String);
  }

  public class InstantiationException extends java.lang.ReflectiveOperationException {
    ctor public InstantiationException();
    ctor public InstantiationException(String);
  }

  public final class Integer extends java.lang.Number implements java.lang.Comparable<java.lang.Integer> {
    ctor @Deprecated public Integer(int);
    ctor @Deprecated public Integer(@NonNull String) throws java.lang.NumberFormatException;
    method public static int bitCount(int);
    method public static int compare(int, int);
    method public int compareTo(@NonNull Integer);
    method public static int compareUnsigned(int, int);
    method @NonNull public static Integer decode(@NonNull String) throws java.lang.NumberFormatException;
    method public static int divideUnsigned(int, int);
    method public double doubleValue();
    method public float floatValue();
    method @Nullable public static Integer getInteger(@NonNull String);
    method @Nullable public static Integer getInteger(@NonNull String, int);
    method @Nullable public static Integer getInteger(@NonNull String, @Nullable Integer);
    method public static int hashCode(int);
    method public static int highestOneBit(int);
    method public int intValue();
    method public long longValue();
    method public static int lowestOneBit(int);
    method public static int max(int, int);
    method public static int min(int, int);
    method public static int numberOfLeadingZeros(int);
    method public static int numberOfTrailingZeros(int);
    method public static int parseInt(@NonNull String, int) throws java.lang.NumberFormatException;
    method public static int parseInt(@NonNull CharSequence, int, int, int) throws java.lang.NumberFormatException;
    method public static int parseInt(@NonNull String) throws java.lang.NumberFormatException;
    method public static int parseUnsignedInt(@NonNull String, int) throws java.lang.NumberFormatException;
    method public static int parseUnsignedInt(@NonNull CharSequence, int, int, int) throws java.lang.NumberFormatException;
    method public static int parseUnsignedInt(@NonNull String) throws java.lang.NumberFormatException;
    method public static int remainderUnsigned(int, int);
    method public static int reverse(int);
    method public static int reverseBytes(int);
    method public static int rotateLeft(int, int);
    method public static int rotateRight(int, int);
    method public static int signum(int);
    method public static int sum(int, int);
    method @NonNull public static String toBinaryString(int);
    method @NonNull public static String toHexString(int);
    method @NonNull public static String toOctalString(int);
    method @NonNull public static String toString(int, int);
    method @NonNull public static String toString(int);
    method public static long toUnsignedLong(int);
    method @NonNull public static String toUnsignedString(int, int);
    method @NonNull public static String toUnsignedString(int);
    method @NonNull public static Integer valueOf(@NonNull String, int) throws java.lang.NumberFormatException;
    method @NonNull public static Integer valueOf(@NonNull String) throws java.lang.NumberFormatException;
    method @NonNull public static Integer valueOf(int);
    field public static final int BYTES = 4; // 0x4
    field public static final int MAX_VALUE = 2147483647; // 0x7fffffff
    field public static final int MIN_VALUE = -2147483648; // 0x80000000
    field public static final int SIZE = 32; // 0x20
    field public static final Class<java.lang.Integer> TYPE;
  }

  public class InternalError extends java.lang.VirtualMachineError {
    ctor public InternalError();
    ctor public InternalError(String);
    ctor public InternalError(String, Throwable);
    ctor public InternalError(Throwable);
  }

  public class InterruptedException extends java.lang.Exception {
    ctor public InterruptedException();
    ctor public InterruptedException(String);
  }

  public interface Iterable<T> {
    method public default void forEach(@NonNull java.util.function.Consumer<? super T>);
    method @NonNull public java.util.Iterator<T> iterator();
    method @NonNull public default java.util.Spliterator<T> spliterator();
  }

  public class LinkageError extends java.lang.Error {
    ctor public LinkageError();
    ctor public LinkageError(String);
    ctor public LinkageError(String, Throwable);
  }

  public final class Long extends java.lang.Number implements java.lang.Comparable<java.lang.Long> {
    ctor @Deprecated public Long(long);
    ctor @Deprecated public Long(@NonNull String) throws java.lang.NumberFormatException;
    method public static int bitCount(long);
    method public static int compare(long, long);
    method public int compareTo(@NonNull Long);
    method public static int compareUnsigned(long, long);
    method @NonNull public static Long decode(@NonNull String) throws java.lang.NumberFormatException;
    method public static long divideUnsigned(long, long);
    method public double doubleValue();
    method public float floatValue();
    method @Nullable public static Long getLong(@NonNull String);
    method @Nullable public static Long getLong(@NonNull String, long);
    method @Nullable public static Long getLong(@NonNull String, @Nullable Long);
    method public static int hashCode(long);
    method public static long highestOneBit(long);
    method public int intValue();
    method public long longValue();
    method public static long lowestOneBit(long);
    method public static long max(long, long);
    method public static long min(long, long);
    method public static int numberOfLeadingZeros(long);
    method public static int numberOfTrailingZeros(long);
    method public static long parseLong(@NonNull String, int) throws java.lang.NumberFormatException;
    method public static long parseLong(@NonNull CharSequence, int, int, int) throws java.lang.NumberFormatException;
    method public static long parseLong(@NonNull String) throws java.lang.NumberFormatException;
    method public static long parseUnsignedLong(@NonNull String, int) throws java.lang.NumberFormatException;
    method public static long parseUnsignedLong(@NonNull CharSequence, int, int, int) throws java.lang.NumberFormatException;
    method public static long parseUnsignedLong(@NonNull String) throws java.lang.NumberFormatException;
    method public static long remainderUnsigned(long, long);
    method public static long reverse(long);
    method public static long reverseBytes(long);
    method public static long rotateLeft(long, int);
    method public static long rotateRight(long, int);
    method public static int signum(long);
    method public static long sum(long, long);
    method @NonNull public static String toBinaryString(long);
    method @NonNull public static String toHexString(long);
    method @NonNull public static String toOctalString(long);
    method @NonNull public static String toString(long, int);
    method @NonNull public static String toString(long);
    method @NonNull public static String toUnsignedString(long, int);
    method @NonNull public static String toUnsignedString(long);
    method @NonNull public static Long valueOf(@NonNull String, int) throws java.lang.NumberFormatException;
    method @NonNull public static Long valueOf(@NonNull String) throws java.lang.NumberFormatException;
    method @NonNull public static Long valueOf(long);
    field public static final int BYTES = 8; // 0x8
    field public static final long MAX_VALUE = 9223372036854775807L; // 0x7fffffffffffffffL
    field public static final long MIN_VALUE = -9223372036854775808L; // 0x8000000000000000L
    field public static final int SIZE = 64; // 0x40
    field public static final Class<java.lang.Long> TYPE;
  }

  public final class Math {
    method public static double IEEEremainder(double, double);
    method public static int abs(int);
    method public static long abs(long);
    method public static float abs(float);
    method public static double abs(double);
    method public static int absExact(int);
    method public static long absExact(long);
    method public static double acos(double);
    method public static int addExact(int, int);
    method public static long addExact(long, long);
    method public static double asin(double);
    method public static double atan(double);
    method public static double atan2(double, double);
    method public static double cbrt(double);
    method public static double ceil(double);
    method public static double copySign(double, double);
    method public static float copySign(float, float);
    method public static double cos(double);
    method public static double cosh(double);
    method public static int decrementExact(int);
    method public static long decrementExact(long);
    method public static double exp(double);
    method public static double expm1(double);
    method public static double floor(double);
    method public static int floorDiv(int, int);
    method public static long floorDiv(long, int);
    method public static long floorDiv(long, long);
    method public static int floorMod(int, int);
    method public static int floorMod(long, int);
    method public static long floorMod(long, long);
    method public static double fma(double, double, double);
    method public static float fma(float, float, float);
    method public static int getExponent(float);
    method public static int getExponent(double);
    method public static double hypot(double, double);
    method public static int incrementExact(int);
    method public static long incrementExact(long);
    method public static double log(double);
    method public static double log10(double);
    method public static double log1p(double);
    method public static int max(int, int);
    method public static long max(long, long);
    method public static float max(float, float);
    method public static double max(double, double);
    method public static int min(int, int);
    method public static long min(long, long);
    method public static float min(float, float);
    method public static double min(double, double);
    method public static int multiplyExact(int, int);
    method public static long multiplyExact(long, int);
    method public static long multiplyExact(long, long);
    method public static long multiplyFull(int, int);
    method public static long multiplyHigh(long, long);
    method public static int negateExact(int);
    method public static long negateExact(long);
    method public static double nextAfter(double, double);
    method public static float nextAfter(float, double);
    method public static double nextDown(double);
    method public static float nextDown(float);
    method public static double nextUp(double);
    method public static float nextUp(float);
    method public static double pow(double, double);
    method public static double random();
    method public static double rint(double);
    method public static int round(float);
    method public static long round(double);
    method public static double scalb(double, int);
    method public static float scalb(float, int);
    method public static double signum(double);
    method public static float signum(float);
    method public static double sin(double);
    method public static double sinh(double);
    method public static double sqrt(double);
    method public static int subtractExact(int, int);
    method public static long subtractExact(long, long);
    method public static double tan(double);
    method public static double tanh(double);
    method public static double toDegrees(double);
    method public static int toIntExact(long);
    method public static double toRadians(double);
    method public static double ulp(double);
    method public static float ulp(float);
    field public static final double E = 2.718281828459045;
    field public static final double PI = 3.141592653589793;
  }

  public class NegativeArraySizeException extends java.lang.RuntimeException {
    ctor public NegativeArraySizeException();
    ctor public NegativeArraySizeException(String);
  }

  public class NoClassDefFoundError extends java.lang.LinkageError {
    ctor public NoClassDefFoundError();
    ctor public NoClassDefFoundError(String);
  }

  public class NoSuchFieldError extends java.lang.IncompatibleClassChangeError {
    ctor public NoSuchFieldError();
    ctor public NoSuchFieldError(String);
  }

  public class NoSuchFieldException extends java.lang.ReflectiveOperationException {
    ctor public NoSuchFieldException();
    ctor public NoSuchFieldException(String);
  }

  public class NoSuchMethodError extends java.lang.IncompatibleClassChangeError {
    ctor public NoSuchMethodError();
    ctor public NoSuchMethodError(String);
  }

  public class NoSuchMethodException extends java.lang.ReflectiveOperationException {
    ctor public NoSuchMethodException();
    ctor public NoSuchMethodException(String);
  }

  public class NullPointerException extends java.lang.RuntimeException {
    ctor public NullPointerException();
    ctor public NullPointerException(String);
  }

  public abstract class Number implements java.io.Serializable {
    ctor public Number();
    method public byte byteValue();
    method public abstract double doubleValue();
    method public abstract float floatValue();
    method public abstract int intValue();
    method public abstract long longValue();
    method public short shortValue();
  }

  public class NumberFormatException extends java.lang.IllegalArgumentException {
    ctor public NumberFormatException();
    ctor public NumberFormatException(String);
  }

  public class Object {
    ctor public Object();
    method @NonNull protected Object clone() throws java.lang.CloneNotSupportedException;
    method public boolean equals(@Nullable Object);
    method protected void finalize() throws java.lang.Throwable;
    method @NonNull public final Class<?> getClass();
    method public int hashCode();
    method public final void notify();
    method public final void notifyAll();
    method @NonNull public String toString();
    method public final void wait(long) throws java.lang.InterruptedException;
    method public final void wait(long, int) throws java.lang.InterruptedException;
    method public final void wait() throws java.lang.InterruptedException;
  }

  public class OutOfMemoryError extends java.lang.VirtualMachineError {
    ctor public OutOfMemoryError();
    ctor public OutOfMemoryError(String);
  }

  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) @java.lang.annotation.Target(java.lang.annotation.ElementType.METHOD) public @interface Override {
  }

  public class Package implements java.lang.reflect.AnnotatedElement {
    method public <A extends java.lang.annotation.Annotation> A getAnnotation(Class<A>);
    method public java.lang.annotation.Annotation[] getAnnotations();
    method public <A extends java.lang.annotation.Annotation> A[] getAnnotationsByType(Class<A>);
    method public <A extends java.lang.annotation.Annotation> A getDeclaredAnnotation(Class<A>);
    method public java.lang.annotation.Annotation[] getDeclaredAnnotations();
    method public <A extends java.lang.annotation.Annotation> A[] getDeclaredAnnotationsByType(Class<A>);
    method public String getImplementationTitle();
    method public String getImplementationVendor();
    method public String getImplementationVersion();
    method public String getName();
    method public static Package getPackage(String);
    method public static Package[] getPackages();
    method public String getSpecificationTitle();
    method public String getSpecificationVendor();
    method public String getSpecificationVersion();
    method public boolean isAnnotationPresent(Class<? extends java.lang.annotation.Annotation>);
    method public boolean isCompatibleWith(String) throws java.lang.NumberFormatException;
    method public boolean isSealed();
    method public boolean isSealed(java.net.URL);
  }

  public abstract class Process {
    ctor public Process();
    method public abstract void destroy();
    method public Process destroyForcibly();
    method public abstract int exitValue();
    method public abstract java.io.InputStream getErrorStream();
    method public abstract java.io.InputStream getInputStream();
    method public abstract java.io.OutputStream getOutputStream();
    method public boolean isAlive();
    method public abstract int waitFor() throws java.lang.InterruptedException;
    method public boolean waitFor(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
  }

  public final class ProcessBuilder {
    ctor public ProcessBuilder(java.util.List<java.lang.String>);
    ctor public ProcessBuilder(java.lang.String...);
    method public ProcessBuilder command(java.util.List<java.lang.String>);
    method public ProcessBuilder command(java.lang.String...);
    method public java.util.List<java.lang.String> command();
    method public java.io.File directory();
    method public ProcessBuilder directory(java.io.File);
    method public java.util.Map<java.lang.String,java.lang.String> environment();
    method public ProcessBuilder inheritIO();
    method public ProcessBuilder redirectError(java.lang.ProcessBuilder.Redirect);
    method public ProcessBuilder redirectError(java.io.File);
    method public java.lang.ProcessBuilder.Redirect redirectError();
    method public boolean redirectErrorStream();
    method public ProcessBuilder redirectErrorStream(boolean);
    method public ProcessBuilder redirectInput(java.lang.ProcessBuilder.Redirect);
    method public ProcessBuilder redirectInput(java.io.File);
    method public java.lang.ProcessBuilder.Redirect redirectInput();
    method public ProcessBuilder redirectOutput(java.lang.ProcessBuilder.Redirect);
    method public ProcessBuilder redirectOutput(java.io.File);
    method public java.lang.ProcessBuilder.Redirect redirectOutput();
    method public Process start() throws java.io.IOException;
  }

  public abstract static class ProcessBuilder.Redirect {
    method public static java.lang.ProcessBuilder.Redirect appendTo(java.io.File);
    method public java.io.File file();
    method public static java.lang.ProcessBuilder.Redirect from(java.io.File);
    method public static java.lang.ProcessBuilder.Redirect to(java.io.File);
    method public abstract java.lang.ProcessBuilder.Redirect.Type type();
    field public static final java.lang.ProcessBuilder.Redirect INHERIT;
    field public static final java.lang.ProcessBuilder.Redirect PIPE;
  }

  public enum ProcessBuilder.Redirect.Type {
    enum_constant public static final java.lang.ProcessBuilder.Redirect.Type APPEND;
    enum_constant public static final java.lang.ProcessBuilder.Redirect.Type INHERIT;
    enum_constant public static final java.lang.ProcessBuilder.Redirect.Type PIPE;
    enum_constant public static final java.lang.ProcessBuilder.Redirect.Type READ;
    enum_constant public static final java.lang.ProcessBuilder.Redirect.Type WRITE;
  }

  public interface Readable {
    method public int read(java.nio.CharBuffer) throws java.io.IOException;
  }

  public abstract class Record {
    ctor protected Record();
    method public abstract boolean equals(@Nullable Object);
    method public abstract int hashCode();
    method @NonNull public abstract String toString();
  }

  public class ReflectiveOperationException extends java.lang.Exception {
    ctor public ReflectiveOperationException();
    ctor public ReflectiveOperationException(String);
    ctor public ReflectiveOperationException(String, Throwable);
    ctor public ReflectiveOperationException(Throwable);
  }

  @java.lang.FunctionalInterface public interface Runnable {
    method public void run();
  }

  public class Runtime {
    method public void addShutdownHook(Thread);
    method public int availableProcessors();
    method public Process exec(String) throws java.io.IOException;
    method public Process exec(String, String[]) throws java.io.IOException;
    method public Process exec(String, String[], java.io.File) throws java.io.IOException;
    method public Process exec(String[]) throws java.io.IOException;
    method public Process exec(String[], String[]) throws java.io.IOException;
    method public Process exec(String[], String[], java.io.File) throws java.io.IOException;
    method public void exit(int);
    method public long freeMemory();
    method public void gc();
    method public static Runtime getRuntime();
    method public void halt(int);
    method public void load(String);
    method public void loadLibrary(String);
    method public long maxMemory();
    method public boolean removeShutdownHook(Thread);
    method public void runFinalization();
    method @Deprecated public static void runFinalizersOnExit(boolean);
    method public long totalMemory();
    method @Deprecated public void traceInstructions(boolean);
    method @Deprecated public void traceMethodCalls(boolean);
  }

  public class RuntimeException extends java.lang.Exception {
    ctor public RuntimeException();
    ctor public RuntimeException(String);
    ctor public RuntimeException(String, Throwable);
    ctor public RuntimeException(Throwable);
    ctor protected RuntimeException(String, Throwable, boolean, boolean);
  }

  public final class RuntimePermission extends java.security.BasicPermission {
    ctor public RuntimePermission(String);
    ctor public RuntimePermission(String, String);
  }

  @java.lang.annotation.Documented @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) @java.lang.annotation.Target({java.lang.annotation.ElementType.CONSTRUCTOR, java.lang.annotation.ElementType.METHOD}) public @interface SafeVarargs {
  }

  public class SecurityException extends java.lang.RuntimeException {
    ctor public SecurityException();
    ctor public SecurityException(String);
    ctor public SecurityException(String, Throwable);
    ctor public SecurityException(Throwable);
  }

  public class SecurityManager {
    ctor public SecurityManager();
    method public void checkAccept(String, int);
    method public void checkAccess(Thread);
    method public void checkAccess(ThreadGroup);
    method public void checkAwtEventQueueAccess();
    method public void checkConnect(String, int);
    method public void checkConnect(String, int, Object);
    method public void checkCreateClassLoader();
    method public void checkDelete(String);
    method public void checkExec(String);
    method public void checkExit(int);
    method public void checkLink(String);
    method public void checkListen(int);
    method @Deprecated public void checkMemberAccess(Class<?>, int);
    method public void checkMulticast(java.net.InetAddress);
    method @Deprecated public void checkMulticast(java.net.InetAddress, byte);
    method public void checkPackageAccess(String);
    method public void checkPackageDefinition(String);
    method public void checkPermission(java.security.Permission);
    method public void checkPermission(java.security.Permission, Object);
    method public void checkPrintJobAccess();
    method public void checkPropertiesAccess();
    method public void checkPropertyAccess(String);
    method public void checkRead(java.io.FileDescriptor);
    method public void checkRead(String);
    method public void checkRead(String, Object);
    method public void checkSecurityAccess(String);
    method public void checkSetFactory();
    method public void checkSystemClipboardAccess();
    method @Deprecated public boolean checkTopLevelWindow(Object);
    method public void checkWrite(java.io.FileDescriptor);
    method public void checkWrite(String);
    method @Deprecated protected int classDepth(String);
    method @Deprecated protected int classLoaderDepth();
    method @Deprecated protected ClassLoader currentClassLoader();
    method @Deprecated protected Class<?> currentLoadedClass();
    method protected Class[] getClassContext();
    method @Deprecated public boolean getInCheck();
    method public Object getSecurityContext();
    method public ThreadGroup getThreadGroup();
    method @Deprecated protected boolean inClass(String);
    method @Deprecated protected boolean inClassLoader();
    field @Deprecated protected boolean inCheck;
  }

  public final class Short extends java.lang.Number implements java.lang.Comparable<java.lang.Short> {
    ctor @Deprecated public Short(short);
    ctor @Deprecated public Short(String) throws java.lang.NumberFormatException;
    method public static int compare(short, short);
    method public int compareTo(Short);
    method public static int compareUnsigned(short, short);
    method public static Short decode(String) throws java.lang.NumberFormatException;
    method public double doubleValue();
    method public float floatValue();
    method public static int hashCode(short);
    method public int intValue();
    method public long longValue();
    method public static short parseShort(String, int) throws java.lang.NumberFormatException;
    method public static short parseShort(String) throws java.lang.NumberFormatException;
    method public static short reverseBytes(short);
    method public static String toString(short);
    method public static int toUnsignedInt(short);
    method public static long toUnsignedLong(short);
    method public static Short valueOf(String, int) throws java.lang.NumberFormatException;
    method public static Short valueOf(String) throws java.lang.NumberFormatException;
    method public static Short valueOf(short);
    field public static final int BYTES = 2; // 0x2
    field public static final short MAX_VALUE = 32767; // 0x7fff
    field public static final short MIN_VALUE = -32768; // 0xffff8000
    field public static final int SIZE = 16; // 0x10
    field public static final Class<java.lang.Short> TYPE;
  }

  public class StackOverflowError extends java.lang.VirtualMachineError {
    ctor public StackOverflowError();
    ctor public StackOverflowError(String);
  }

  public final class StackTraceElement implements java.io.Serializable {
    ctor public StackTraceElement(String, String, String, int);
    method public String getClassName();
    method public String getFileName();
    method public int getLineNumber();
    method public String getMethodName();
    method public boolean isNativeMethod();
  }

  public final class StackWalker {
    method public void forEach(java.util.function.Consumer<? super java.lang.StackWalker.StackFrame>);
    method public Class<?> getCallerClass();
    method public static StackWalker getInstance();
    method public static StackWalker getInstance(java.lang.StackWalker.Option);
    method public static StackWalker getInstance(java.util.Set<java.lang.StackWalker.Option>);
    method public static StackWalker getInstance(java.util.Set<java.lang.StackWalker.Option>, int);
    method public <T> T walk(java.util.function.Function<? super java.util.stream.Stream<java.lang.StackWalker.StackFrame>,? extends T>);
  }

  public enum StackWalker.Option {
    enum_constant public static final java.lang.StackWalker.Option RETAIN_CLASS_REFERENCE;
    enum_constant public static final java.lang.StackWalker.Option SHOW_HIDDEN_FRAMES;
    enum_constant public static final java.lang.StackWalker.Option SHOW_REFLECT_FRAMES;
  }

  public static interface StackWalker.StackFrame {
    method public int getByteCodeIndex();
    method public String getClassName();
    method public Class<?> getDeclaringClass();
    method public default String getDescriptor();
    method public String getFileName();
    method public int getLineNumber();
    method public String getMethodName();
    method public default java.lang.invoke.MethodType getMethodType();
    method public boolean isNativeMethod();
    method public StackTraceElement toStackTraceElement();
  }

  public final class StrictMath {
    method public static double IEEEremainder(double, double);
    method public static int abs(int);
    method public static long abs(long);
    method public static float abs(float);
    method public static double abs(double);
    method public static int absExact(int);
    method public static long absExact(long);
    method public static double acos(double);
    method public static int addExact(int, int);
    method public static long addExact(long, long);
    method public static double asin(double);
    method public static double atan(double);
    method public static double atan2(double, double);
    method public static double cbrt(double);
    method public static double ceil(double);
    method public static double copySign(double, double);
    method public static float copySign(float, float);
    method public static double cos(double);
    method public static double cosh(double);
    method public static int decrementExact(int);
    method public static long decrementExact(long);
    method public static double exp(double);
    method public static double expm1(double);
    method public static double floor(double);
    method public static int floorDiv(int, int);
    method public static long floorDiv(long, int);
    method public static long floorDiv(long, long);
    method public static int floorMod(int, int);
    method public static int floorMod(long, int);
    method public static long floorMod(long, long);
    method public static double fma(double, double, double);
    method public static float fma(float, float, float);
    method public static int getExponent(float);
    method public static int getExponent(double);
    method public static double hypot(double, double);
    method public static int incrementExact(int);
    method public static long incrementExact(long);
    method public static double log(double);
    method public static double log10(double);
    method public static double log1p(double);
    method public static int max(int, int);
    method public static long max(long, long);
    method public static float max(float, float);
    method public static double max(double, double);
    method public static int min(int, int);
    method public static long min(long, long);
    method public static float min(float, float);
    method public static double min(double, double);
    method public static int multiplyExact(int, int);
    method public static long multiplyExact(long, int);
    method public static long multiplyExact(long, long);
    method public static long multiplyFull(int, int);
    method public static long multiplyHigh(long, long);
    method public static int negateExact(int);
    method public static long negateExact(long);
    method public static double nextAfter(double, double);
    method public static float nextAfter(float, double);
    method public static double nextDown(double);
    method public static float nextDown(float);
    method public static double nextUp(double);
    method public static float nextUp(float);
    method public static double pow(double, double);
    method public static double random();
    method public static double rint(double);
    method public static int round(float);
    method public static long round(double);
    method public static double scalb(double, int);
    method public static float scalb(float, int);
    method public static double signum(double);
    method public static float signum(float);
    method public static double sin(double);
    method public static double sinh(double);
    method public static double sqrt(double);
    method public static int subtractExact(int, int);
    method public static long subtractExact(long, long);
    method public static double tan(double);
    method public static double tanh(double);
    method public static double toDegrees(double);
    method public static int toIntExact(long);
    method public static double toRadians(double);
    method public static double ulp(double);
    method public static float ulp(float);
    field public static final double E = 2.718281828459045;
    field public static final double PI = 3.141592653589793;
  }

  public final class String implements java.lang.CharSequence java.lang.Comparable<java.lang.String> java.io.Serializable {
    ctor public String();
    ctor public String(@NonNull String);
    ctor public String(char[]);
    ctor public String(char[], int, int);
    ctor public String(int[], int, int);
    ctor @Deprecated public String(byte[], int, int, int);
    ctor @Deprecated public String(byte[], int);
    ctor public String(byte[], int, int, @NonNull String) throws java.io.UnsupportedEncodingException;
    ctor public String(byte[], int, int, @NonNull java.nio.charset.Charset);
    ctor public String(byte[], @NonNull String) throws java.io.UnsupportedEncodingException;
    ctor public String(byte[], @NonNull java.nio.charset.Charset);
    ctor public String(byte[], int, int);
    ctor public String(byte[]);
    ctor public String(@NonNull StringBuffer);
    ctor public String(@NonNull StringBuilder);
    method public char charAt(int);
    method @NonNull public java.util.stream.IntStream chars();
    method public int codePointAt(int);
    method public int codePointBefore(int);
    method public int codePointCount(int, int);
    method @NonNull public java.util.stream.IntStream codePoints();
    method public int compareTo(@NonNull String);
    method public int compareToIgnoreCase(@NonNull String);
    method @NonNull public String concat(@NonNull String);
    method public boolean contains(@NonNull CharSequence);
    method public boolean contentEquals(@NonNull StringBuffer);
    method public boolean contentEquals(@NonNull CharSequence);
    method @NonNull public static String copyValueOf(char[], int, int);
    method @NonNull public static String copyValueOf(char[]);
    method public boolean endsWith(@NonNull String);
    method public boolean equalsIgnoreCase(@Nullable String);
    method @NonNull public static String format(@NonNull String, @NonNull java.lang.Object...);
    method @NonNull public static String format(@NonNull java.util.Locale, @NonNull String, @NonNull java.lang.Object...);
    method @NonNull public String formatted(@NonNull java.lang.Object...);
    method @Deprecated public void getBytes(int, int, byte[], int);
    method public byte[] getBytes(@NonNull String) throws java.io.UnsupportedEncodingException;
    method public byte[] getBytes(@NonNull java.nio.charset.Charset);
    method public byte[] getBytes();
    method public void getChars(int, int, char[], int);
    method @NonNull public String indent(int);
    method public int indexOf(int);
    method public int indexOf(int, int);
    method public int indexOf(@NonNull String);
    method public int indexOf(@NonNull String, int);
    method @NonNull public String intern();
    method public boolean isBlank();
    method public boolean isEmpty();
    method @NonNull public static String join(@NonNull CharSequence, @Nullable java.lang.CharSequence...);
    method @NonNull public static String join(@NonNull CharSequence, @NonNull Iterable<? extends java.lang.CharSequence>);
    method public int lastIndexOf(int);
    method public int lastIndexOf(int, int);
    method public int lastIndexOf(@NonNull String);
    method public int lastIndexOf(@NonNull String, int);
    method public int length();
    method @NonNull public java.util.stream.Stream<java.lang.String> lines();
    method public boolean matches(@NonNull String);
    method public int offsetByCodePoints(int, int);
    method public boolean regionMatches(int, @NonNull String, int, int);
    method public boolean regionMatches(boolean, int, @NonNull String, int, int);
    method @NonNull public String repeat(int);
    method @NonNull public String replace(char, char);
    method @NonNull public String replace(@NonNull CharSequence, @NonNull CharSequence);
    method @NonNull public String replaceAll(@NonNull String, @NonNull String);
    method @NonNull public String replaceFirst(@NonNull String, @NonNull String);
    method @NonNull public String[] split(@NonNull String, int);
    method @NonNull public String[] split(@NonNull String);
    method public boolean startsWith(@NonNull String, int);
    method public boolean startsWith(@NonNull String);
    method @NonNull public String strip();
    method @NonNull public String stripIndent();
    method @NonNull public String stripLeading();
    method @NonNull public String stripTrailing();
    method @NonNull public CharSequence subSequence(int, int);
    method @NonNull public String substring(int);
    method @NonNull public String substring(int, int);
    method public char[] toCharArray();
    method @NonNull public String toLowerCase(@NonNull java.util.Locale);
    method @NonNull public String toLowerCase();
    method @NonNull public String toString();
    method @NonNull public String toUpperCase(@NonNull java.util.Locale);
    method @NonNull public String toUpperCase();
    method public <R> R transform(@NonNull java.util.function.Function<? super java.lang.String,? extends R>);
    method @NonNull public String translateEscapes();
    method @NonNull public String trim();
    method @NonNull public static String valueOf(@Nullable Object);
    method @NonNull public static String valueOf(char[]);
    method @NonNull public static String valueOf(char[], int, int);
    method @NonNull public static String valueOf(boolean);
    method @NonNull public static String valueOf(char);
    method @NonNull public static String valueOf(int);
    method @NonNull public static String valueOf(long);
    method @NonNull public static String valueOf(float);
    method @NonNull public static String valueOf(double);
    field public static final java.util.Comparator<java.lang.String> CASE_INSENSITIVE_ORDER;
  }

  public final class StringBuffer implements java.lang.Appendable java.lang.CharSequence java.lang.Comparable<java.lang.StringBuffer> java.io.Serializable {
    ctor public StringBuffer();
    ctor public StringBuffer(int);
    ctor public StringBuffer(@NonNull String);
    ctor public StringBuffer(@NonNull CharSequence);
    method @NonNull public StringBuffer append(@Nullable Object);
    method @NonNull public StringBuffer append(@Nullable String);
    method @NonNull public StringBuffer append(@Nullable StringBuffer);
    method @NonNull public StringBuffer append(@Nullable CharSequence);
    method @NonNull public StringBuffer append(@Nullable CharSequence, int, int);
    method @NonNull public StringBuffer append(char[]);
    method @NonNull public StringBuffer append(char[], int, int);
    method @NonNull public StringBuffer append(boolean);
    method @NonNull public StringBuffer append(char);
    method @NonNull public StringBuffer append(int);
    method @NonNull public StringBuffer append(long);
    method @NonNull public StringBuffer append(float);
    method @NonNull public StringBuffer append(double);
    method @NonNull public StringBuffer appendCodePoint(int);
    method public int capacity();
    method public char charAt(int);
    method @NonNull public java.util.stream.IntStream chars();
    method public int codePointAt(int);
    method public int codePointBefore(int);
    method public int codePointCount(int, int);
    method @NonNull public java.util.stream.IntStream codePoints();
    method public int compareTo(@NonNull StringBuffer);
    method @NonNull public StringBuffer delete(int, int);
    method @NonNull public StringBuffer deleteCharAt(int);
    method public void ensureCapacity(int);
    method public void getChars(int, int, char[], int);
    method public int indexOf(@NonNull String);
    method public int indexOf(@NonNull String, int);
    method @NonNull public StringBuffer insert(int, char[], int, int);
    method @NonNull public StringBuffer insert(int, @Nullable Object);
    method @NonNull public StringBuffer insert(int, @Nullable String);
    method @NonNull public StringBuffer insert(int, char[]);
    method @NonNull public StringBuffer insert(int, @Nullable CharSequence);
    method @NonNull public StringBuffer insert(int, @Nullable CharSequence, int, int);
    method @NonNull public StringBuffer insert(int, boolean);
    method @NonNull public StringBuffer insert(int, char);
    method @NonNull public StringBuffer insert(int, int);
    method @NonNull public StringBuffer insert(int, long);
    method @NonNull public StringBuffer insert(int, float);
    method @NonNull public StringBuffer insert(int, double);
    method public int lastIndexOf(@NonNull String);
    method public int lastIndexOf(@NonNull String, int);
    method public int length();
    method public int offsetByCodePoints(int, int);
    method @NonNull public StringBuffer replace(int, int, @NonNull String);
    method @NonNull public StringBuffer reverse();
    method public void setCharAt(int, char);
    method public void setLength(int);
    method @NonNull public CharSequence subSequence(int, int);
    method @NonNull public String substring(int);
    method @NonNull public String substring(int, int);
    method @NonNull public String toString();
    method public void trimToSize();
  }

  public final class StringBuilder implements java.lang.Appendable java.lang.CharSequence java.lang.Comparable<java.lang.StringBuilder> java.io.Serializable {
    ctor public StringBuilder();
    ctor public StringBuilder(int);
    ctor public StringBuilder(@NonNull String);
    ctor public StringBuilder(@NonNull CharSequence);
    method @NonNull public StringBuilder append(@Nullable Object);
    method @NonNull public StringBuilder append(@Nullable String);
    method @NonNull public StringBuilder append(@Nullable StringBuffer);
    method @NonNull public StringBuilder append(@Nullable CharSequence);
    method @NonNull public StringBuilder append(@Nullable CharSequence, int, int);
    method @NonNull public StringBuilder append(char[]);
    method @NonNull public StringBuilder append(char[], int, int);
    method @NonNull public StringBuilder append(boolean);
    method @NonNull public StringBuilder append(char);
    method @NonNull public StringBuilder append(int);
    method @NonNull public StringBuilder append(long);
    method @NonNull public StringBuilder append(float);
    method @NonNull public StringBuilder append(double);
    method @NonNull public StringBuilder appendCodePoint(int);
    method public int capacity();
    method public char charAt(int);
    method @NonNull public java.util.stream.IntStream chars();
    method public int codePointAt(int);
    method public int codePointBefore(int);
    method public int codePointCount(int, int);
    method @NonNull public java.util.stream.IntStream codePoints();
    method public int compareTo(@NonNull StringBuilder);
    method @NonNull public StringBuilder delete(int, int);
    method @NonNull public StringBuilder deleteCharAt(int);
    method public void ensureCapacity(int);
    method public void getChars(int, int, char[], int);
    method public int indexOf(@NonNull String);
    method public int indexOf(@NonNull String, int);
    method @NonNull public StringBuilder insert(int, char[], int, int);
    method @NonNull public StringBuilder insert(int, @Nullable Object);
    method @NonNull public StringBuilder insert(int, @Nullable String);
    method @NonNull public StringBuilder insert(int, char[]);
    method @NonNull public StringBuilder insert(int, @Nullable CharSequence);
    method @NonNull public StringBuilder insert(int, @Nullable CharSequence, int, int);
    method @NonNull public StringBuilder insert(int, boolean);
    method @NonNull public StringBuilder insert(int, char);
    method @NonNull public StringBuilder insert(int, int);
    method @NonNull public StringBuilder insert(int, long);
    method @NonNull public StringBuilder insert(int, float);
    method @NonNull public StringBuilder insert(int, double);
    method public int lastIndexOf(@NonNull String);
    method public int lastIndexOf(@NonNull String, int);
    method public int length();
    method public int offsetByCodePoints(int, int);
    method @NonNull public StringBuilder replace(int, int, @NonNull String);
    method @NonNull public StringBuilder reverse();
    method public void setCharAt(int, char);
    method public void setLength(int);
    method @NonNull public CharSequence subSequence(int, int);
    method @NonNull public String substring(int);
    method @NonNull public String substring(int, int);
    method @NonNull public String toString();
    method public void trimToSize();
  }

  public class StringIndexOutOfBoundsException extends java.lang.IndexOutOfBoundsException {
    ctor public StringIndexOutOfBoundsException();
    ctor public StringIndexOutOfBoundsException(String);
    ctor public StringIndexOutOfBoundsException(int);
  }

  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) @java.lang.annotation.Target({java.lang.annotation.ElementType.TYPE, java.lang.annotation.ElementType.FIELD, java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.PARAMETER, java.lang.annotation.ElementType.CONSTRUCTOR, java.lang.annotation.ElementType.LOCAL_VARIABLE}) public @interface SuppressWarnings {
    method public abstract String[] value();
  }

  public final class System {
    method public static void arraycopy(@NonNull Object, int, @NonNull Object, int, int);
    method @Nullable public static String clearProperty(@NonNull String);
    method @Nullable public static java.io.Console console();
    method public static long currentTimeMillis();
    method public static void exit(int);
    method public static void gc();
    method @NonNull public static java.util.Properties getProperties();
    method @Nullable public static String getProperty(@NonNull String);
    method @Nullable public static String getProperty(@NonNull String, @Nullable String);
    method @Nullable public static SecurityManager getSecurityManager();
    method @Nullable public static String getenv(@NonNull String);
    method @NonNull public static java.util.Map<java.lang.String,java.lang.String> getenv();
    method public static int identityHashCode(@Nullable Object);
    method @Nullable public static java.nio.channels.Channel inheritedChannel() throws java.io.IOException;
    method @NonNull public static String lineSeparator();
    method public static void load(@NonNull String);
    method public static void loadLibrary(@NonNull String);
    method @NonNull public static String mapLibraryName(@NonNull String);
    method public static long nanoTime();
    method public static void runFinalization();
    method @Deprecated public static void runFinalizersOnExit(boolean);
    method public static void setErr(@Nullable java.io.PrintStream);
    method public static void setIn(@Nullable java.io.InputStream);
    method public static void setOut(@Nullable java.io.PrintStream);
    method public static void setProperties(@Nullable java.util.Properties);
    method @Nullable public static String setProperty(@NonNull String, @Nullable String);
    method public static void setSecurityManager(@Nullable SecurityManager);
    field public static final java.io.PrintStream err;
    field public static final java.io.InputStream in;
    field public static final java.io.PrintStream out;
  }

  public class Thread implements java.lang.Runnable {
    ctor public Thread();
    ctor public Thread(@Nullable Runnable);
    ctor public Thread(@Nullable ThreadGroup, @Nullable Runnable);
    ctor public Thread(@NonNull String);
    ctor public Thread(@Nullable ThreadGroup, @NonNull String);
    ctor public Thread(@Nullable Runnable, @NonNull String);
    ctor public Thread(@Nullable ThreadGroup, @Nullable Runnable, @NonNull String);
    ctor public Thread(@Nullable ThreadGroup, @Nullable Runnable, @NonNull String, long);
    ctor public Thread(@Nullable ThreadGroup, @Nullable Runnable, @NonNull String, long, boolean);
    method public static int activeCount();
    method public final void checkAccess();
    method @Deprecated public int countStackFrames();
    method @NonNull public static Thread currentThread();
    method @Deprecated public void destroy();
    method public static void dumpStack();
    method public static int enumerate(Thread[]);
    method @NonNull public static java.util.Map<java.lang.Thread,java.lang.StackTraceElement[]> getAllStackTraces();
    method @Nullable public ClassLoader getContextClassLoader();
    method @Nullable public static java.lang.Thread.UncaughtExceptionHandler getDefaultUncaughtExceptionHandler();
    method public long getId();
    method @NonNull public final String getName();
    method public final int getPriority();
    method @NonNull public StackTraceElement[] getStackTrace();
    method @NonNull public java.lang.Thread.State getState();
    method @Nullable public final ThreadGroup getThreadGroup();
    method @Nullable public java.lang.Thread.UncaughtExceptionHandler getUncaughtExceptionHandler();
    method public static boolean holdsLock(@NonNull Object);
    method public void interrupt();
    method public static boolean interrupted();
    method public final boolean isAlive();
    method public final boolean isDaemon();
    method public boolean isInterrupted();
    method public final void join(long) throws java.lang.InterruptedException;
    method public final void join(long, int) throws java.lang.InterruptedException;
    method public final void join() throws java.lang.InterruptedException;
    method public static void onSpinWait();
    method @Deprecated public final void resume();
    method public void run();
    method public void setContextClassLoader(@Nullable ClassLoader);
    method public final void setDaemon(boolean);
    method public static void setDefaultUncaughtExceptionHandler(@Nullable java.lang.Thread.UncaughtExceptionHandler);
    method public final void setName(@NonNull String);
    method public final void setPriority(int);
    method public void setUncaughtExceptionHandler(@Nullable java.lang.Thread.UncaughtExceptionHandler);
    method public static void sleep(long) throws java.lang.InterruptedException;
    method public static void sleep(long, int) throws java.lang.InterruptedException;
    method public void start();
    method @Deprecated public final void stop();
    method @Deprecated public final void stop(@Nullable Throwable);
    method @Deprecated public final void suspend();
    method public static void yield();
    field public static final int MAX_PRIORITY = 10; // 0xa
    field public static final int MIN_PRIORITY = 1; // 0x1
    field public static final int NORM_PRIORITY = 5; // 0x5
  }

  public enum Thread.State {
    enum_constant public static final java.lang.Thread.State BLOCKED;
    enum_constant public static final java.lang.Thread.State NEW;
    enum_constant public static final java.lang.Thread.State RUNNABLE;
    enum_constant public static final java.lang.Thread.State TERMINATED;
    enum_constant public static final java.lang.Thread.State TIMED_WAITING;
    enum_constant public static final java.lang.Thread.State WAITING;
  }

  @java.lang.FunctionalInterface public static interface Thread.UncaughtExceptionHandler {
    method public void uncaughtException(@NonNull Thread, @NonNull Throwable);
  }

  public class ThreadDeath extends java.lang.Error {
    ctor public ThreadDeath();
  }

  public class ThreadGroup implements java.lang.Thread.UncaughtExceptionHandler {
    ctor public ThreadGroup(String);
    ctor public ThreadGroup(ThreadGroup, String);
    method public int activeCount();
    method public int activeGroupCount();
    method @Deprecated public boolean allowThreadSuspension(boolean);
    method public final void checkAccess();
    method public final void destroy();
    method public int enumerate(Thread[]);
    method public int enumerate(Thread[], boolean);
    method public int enumerate(ThreadGroup[]);
    method public int enumerate(ThreadGroup[], boolean);
    method public final int getMaxPriority();
    method public final String getName();
    method public final ThreadGroup getParent();
    method public final void interrupt();
    method public final boolean isDaemon();
    method public boolean isDestroyed();
    method public void list();
    method public final boolean parentOf(ThreadGroup);
    method @Deprecated public final void resume();
    method public final void setDaemon(boolean);
    method public final void setMaxPriority(int);
    method @Deprecated public final void stop();
    method @Deprecated public final void suspend();
    method public void uncaughtException(Thread, Throwable);
  }

  public class ThreadLocal<T> {
    ctor public ThreadLocal();
    method @Nullable public T get();
    method @Nullable protected T initialValue();
    method public void remove();
    method public void set(T);
    method @NonNull public static <S> ThreadLocal<S> withInitial(@NonNull java.util.function.Supplier<? extends S>);
  }

  public class Throwable implements java.io.Serializable {
    ctor public Throwable();
    ctor public Throwable(@Nullable String);
    ctor public Throwable(@Nullable String, @Nullable Throwable);
    ctor public Throwable(@Nullable Throwable);
    ctor protected Throwable(@Nullable String, @Nullable Throwable, boolean, boolean);
    method public final void addSuppressed(@NonNull Throwable);
    method @NonNull public Throwable fillInStackTrace();
    method @Nullable public Throwable getCause();
    method @Nullable public String getLocalizedMessage();
    method @Nullable public String getMessage();
    method @NonNull public StackTraceElement[] getStackTrace();
    method @NonNull public final Throwable[] getSuppressed();
    method @NonNull public Throwable initCause(@Nullable Throwable);
    method public void printStackTrace();
    method public void printStackTrace(@NonNull java.io.PrintStream);
    method public void printStackTrace(@NonNull java.io.PrintWriter);
    method public void setStackTrace(@NonNull StackTraceElement[]);
  }

  public class TypeNotPresentException extends java.lang.RuntimeException {
    ctor public TypeNotPresentException(String, Throwable);
    method public String typeName();
  }

  public class UnknownError extends java.lang.VirtualMachineError {
    ctor public UnknownError();
    ctor public UnknownError(String);
  }

  public class UnsatisfiedLinkError extends java.lang.LinkageError {
    ctor public UnsatisfiedLinkError();
    ctor public UnsatisfiedLinkError(String);
  }

  public class UnsupportedClassVersionError extends java.lang.ClassFormatError {
    ctor public UnsupportedClassVersionError();
    ctor public UnsupportedClassVersionError(String);
  }

  public class UnsupportedOperationException extends java.lang.RuntimeException {
    ctor public UnsupportedOperationException();
    ctor public UnsupportedOperationException(String);
    ctor public UnsupportedOperationException(String, Throwable);
    ctor public UnsupportedOperationException(Throwable);
  }

  public class VerifyError extends java.lang.LinkageError {
    ctor public VerifyError();
    ctor public VerifyError(String);
  }

  public abstract class VirtualMachineError extends java.lang.Error {
    ctor public VirtualMachineError();
    ctor public VirtualMachineError(String);
    ctor public VirtualMachineError(String, Throwable);
    ctor public VirtualMachineError(Throwable);
  }

  public final class Void {
    field public static final Class<java.lang.Void> TYPE;
  }

}

package java.lang.annotation {

  public interface Annotation {
    method public Class<? extends java.lang.annotation.Annotation> annotationType();
    method public boolean equals(Object);
    method public int hashCode();
    method public String toString();
  }

  public class AnnotationFormatError extends java.lang.Error {
    ctor public AnnotationFormatError(String);
    ctor public AnnotationFormatError(String, Throwable);
    ctor public AnnotationFormatError(Throwable);
  }

  public class AnnotationTypeMismatchException extends java.lang.RuntimeException {
    ctor public AnnotationTypeMismatchException(java.lang.reflect.Method, String);
    method public java.lang.reflect.Method element();
    method public String foundType();
  }

  @java.lang.annotation.Documented @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) @java.lang.annotation.Target(java.lang.annotation.ElementType.ANNOTATION_TYPE) public @interface Documented {
  }

  public enum ElementType {
    enum_constant public static final java.lang.annotation.ElementType ANNOTATION_TYPE;
    enum_constant public static final java.lang.annotation.ElementType CONSTRUCTOR;
    enum_constant public static final java.lang.annotation.ElementType FIELD;
    enum_constant public static final java.lang.annotation.ElementType LOCAL_VARIABLE;
    enum_constant public static final java.lang.annotation.ElementType METHOD;
    enum_constant public static final java.lang.annotation.ElementType MODULE;
    enum_constant public static final java.lang.annotation.ElementType PACKAGE;
    enum_constant public static final java.lang.annotation.ElementType PARAMETER;
    enum_constant public static final java.lang.annotation.ElementType RECORD_COMPONENT;
    enum_constant public static final java.lang.annotation.ElementType TYPE;
    enum_constant public static final java.lang.annotation.ElementType TYPE_PARAMETER;
    enum_constant public static final java.lang.annotation.ElementType TYPE_USE;
  }

  public class IncompleteAnnotationException extends java.lang.RuntimeException {
    ctor public IncompleteAnnotationException(Class<? extends java.lang.annotation.Annotation>, String);
    method public Class<? extends java.lang.annotation.Annotation> annotationType();
    method public String elementName();
  }

  @java.lang.annotation.Documented @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) @java.lang.annotation.Target(java.lang.annotation.ElementType.ANNOTATION_TYPE) public @interface Inherited {
  }

  @java.lang.annotation.Documented @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) @java.lang.annotation.Target(java.lang.annotation.ElementType.FIELD) public @interface Native {
  }

  @java.lang.annotation.Documented @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) @java.lang.annotation.Target(java.lang.annotation.ElementType.ANNOTATION_TYPE) public @interface Repeatable {
    method public abstract Class<? extends java.lang.annotation.Annotation> value();
  }

  @java.lang.annotation.Documented @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) @java.lang.annotation.Target(java.lang.annotation.ElementType.ANNOTATION_TYPE) public @interface Retention {
    method public abstract java.lang.annotation.RetentionPolicy value();
  }

  public enum RetentionPolicy {
    enum_constant public static final java.lang.annotation.RetentionPolicy CLASS;
    enum_constant public static final java.lang.annotation.RetentionPolicy RUNTIME;
    enum_constant public static final java.lang.annotation.RetentionPolicy SOURCE;
  }

  @java.lang.annotation.Documented @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) @java.lang.annotation.Target(java.lang.annotation.ElementType.ANNOTATION_TYPE) public @interface Target {
    method public abstract java.lang.annotation.ElementType[] value();
  }

}

package java.lang.invoke {

  public abstract class CallSite {
    method public abstract java.lang.invoke.MethodHandle dynamicInvoker();
    method public abstract java.lang.invoke.MethodHandle getTarget();
    method public abstract void setTarget(java.lang.invoke.MethodHandle);
    method public java.lang.invoke.MethodType type();
  }

  public class ConstantCallSite extends java.lang.invoke.CallSite {
    ctor public ConstantCallSite(java.lang.invoke.MethodHandle);
    ctor protected ConstantCallSite(java.lang.invoke.MethodType, java.lang.invoke.MethodHandle) throws java.lang.Throwable;
    method public final java.lang.invoke.MethodHandle dynamicInvoker();
    method public final java.lang.invoke.MethodHandle getTarget();
    method public final void setTarget(java.lang.invoke.MethodHandle);
  }

  public class LambdaConversionException extends java.lang.Exception {
    ctor public LambdaConversionException();
    ctor public LambdaConversionException(String);
    ctor public LambdaConversionException(String, Throwable);
    ctor public LambdaConversionException(Throwable);
    ctor public LambdaConversionException(String, Throwable, boolean, boolean);
  }

  public abstract class MethodHandle {
    method public java.lang.invoke.MethodHandle asCollector(Class<?>, int);
    method public java.lang.invoke.MethodHandle asCollector(int, Class<?>, int);
    method public java.lang.invoke.MethodHandle asFixedArity();
    method public java.lang.invoke.MethodHandle asSpreader(Class<?>, int);
    method public java.lang.invoke.MethodHandle asSpreader(int, Class<?>, int);
    method public java.lang.invoke.MethodHandle asType(java.lang.invoke.MethodType);
    method public java.lang.invoke.MethodHandle asVarargsCollector(Class<?>);
    method public java.lang.invoke.MethodHandle bindTo(Object);
    method public final native Object invoke(java.lang.Object...) throws java.lang.Throwable;
    method public final native Object invokeExact(java.lang.Object...) throws java.lang.Throwable;
    method public Object invokeWithArguments(java.lang.Object...) throws java.lang.Throwable;
    method public Object invokeWithArguments(java.util.List<?>) throws java.lang.Throwable;
    method public boolean isVarargsCollector();
    method public java.lang.invoke.MethodType type();
    method public java.lang.invoke.MethodHandle withVarargs(boolean);
  }

  public interface MethodHandleInfo {
    method public Class<?> getDeclaringClass();
    method public java.lang.invoke.MethodType getMethodType();
    method public int getModifiers();
    method public String getName();
    method public int getReferenceKind();
    method public default boolean isVarArgs();
    method @Deprecated public static boolean refKindIsField(int);
    method @Deprecated public static boolean refKindIsValid(int);
    method @Deprecated public static String refKindName(int);
    method public static String referenceKindToString(int);
    method public <T extends java.lang.reflect.Member> T reflectAs(Class<T>, java.lang.invoke.MethodHandles.Lookup);
    method public static String toString(int, Class<?>, String, java.lang.invoke.MethodType);
    field public static final int REF_getField = 1; // 0x1
    field public static final int REF_getStatic = 2; // 0x2
    field public static final int REF_invokeInterface = 9; // 0x9
    field public static final int REF_invokeSpecial = 7; // 0x7
    field public static final int REF_invokeStatic = 6; // 0x6
    field public static final int REF_invokeVirtual = 5; // 0x5
    field public static final int REF_newInvokeSpecial = 8; // 0x8
    field public static final int REF_putField = 3; // 0x3
    field public static final int REF_putStatic = 4; // 0x4
  }

  public class MethodHandles {
    method public static java.lang.invoke.MethodHandle arrayConstructor(Class<?>) throws java.lang.IllegalArgumentException;
    method public static java.lang.invoke.MethodHandle arrayElementGetter(Class<?>) throws java.lang.IllegalArgumentException;
    method public static java.lang.invoke.MethodHandle arrayElementSetter(Class<?>) throws java.lang.IllegalArgumentException;
    method public static java.lang.invoke.VarHandle arrayElementVarHandle(Class<?>) throws java.lang.IllegalArgumentException;
    method public static java.lang.invoke.MethodHandle arrayLength(Class<?>) throws java.lang.IllegalArgumentException;
    method public static java.lang.invoke.VarHandle byteArrayViewVarHandle(Class<?>, java.nio.ByteOrder) throws java.lang.IllegalArgumentException;
    method public static java.lang.invoke.VarHandle byteBufferViewVarHandle(Class<?>, java.nio.ByteOrder) throws java.lang.IllegalArgumentException;
    method public static java.lang.invoke.MethodHandle catchException(java.lang.invoke.MethodHandle, Class<? extends java.lang.Throwable>, java.lang.invoke.MethodHandle);
    method public static java.lang.invoke.MethodHandle collectArguments(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle);
    method public static java.lang.invoke.MethodHandle constant(Class<?>, Object);
    method public static java.lang.invoke.MethodHandle countedLoop(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
    method public static java.lang.invoke.MethodHandle countedLoop(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
    method public static java.lang.invoke.MethodHandle doWhileLoop(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
    method public static java.lang.invoke.MethodHandle dropArguments(java.lang.invoke.MethodHandle, int, java.util.List<java.lang.Class<?>>);
    method public static java.lang.invoke.MethodHandle dropArguments(java.lang.invoke.MethodHandle, int, Class<?>...);
    method public static java.lang.invoke.MethodHandle dropArgumentsToMatch(java.lang.invoke.MethodHandle, int, java.util.List<java.lang.Class<?>>, int);
    method public static java.lang.invoke.MethodHandle dropReturn(java.lang.invoke.MethodHandle);
    method public static java.lang.invoke.MethodHandle empty(java.lang.invoke.MethodType);
    method public static java.lang.invoke.MethodHandle exactInvoker(java.lang.invoke.MethodType);
    method public static java.lang.invoke.MethodHandle explicitCastArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType);
    method public static java.lang.invoke.MethodHandle filterArguments(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle...);
    method public static java.lang.invoke.MethodHandle filterReturnValue(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
    method public static java.lang.invoke.MethodHandle foldArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
    method public static java.lang.invoke.MethodHandle foldArguments(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle);
    method public static java.lang.invoke.MethodHandle guardWithTest(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
    method public static java.lang.invoke.MethodHandle identity(Class<?>);
    method public static java.lang.invoke.MethodHandle insertArguments(java.lang.invoke.MethodHandle, int, java.lang.Object...);
    method public static java.lang.invoke.MethodHandle invoker(java.lang.invoke.MethodType);
    method public static java.lang.invoke.MethodHandle iteratedLoop(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
    method public static java.lang.invoke.MethodHandles.Lookup lookup();
    method public static java.lang.invoke.MethodHandle loop(java.lang.invoke.MethodHandle[]...);
    method public static java.lang.invoke.MethodHandle permuteArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType, int...);
    method public static java.lang.invoke.MethodHandles.Lookup privateLookupIn(Class<?>, java.lang.invoke.MethodHandles.Lookup) throws java.lang.IllegalAccessException;
    method public static java.lang.invoke.MethodHandles.Lookup publicLookup();
    method public static <T extends java.lang.reflect.Member> T reflectAs(Class<T>, java.lang.invoke.MethodHandle);
    method public static java.lang.invoke.MethodHandle spreadInvoker(java.lang.invoke.MethodType, int);
    method public static java.lang.invoke.MethodHandle tableSwitch(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle...);
    method public static java.lang.invoke.MethodHandle throwException(Class<?>, Class<? extends java.lang.Throwable>);
    method public static java.lang.invoke.MethodHandle tryFinally(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
    method public static java.lang.invoke.MethodHandle varHandleExactInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType);
    method public static java.lang.invoke.MethodHandle varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType);
    method public static java.lang.invoke.MethodHandle whileLoop(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
    method public static java.lang.invoke.MethodHandle zero(Class<?>);
  }

  public static final class MethodHandles.Lookup {
    method public java.lang.invoke.MethodHandle bind(Object, String, java.lang.invoke.MethodType) throws java.lang.IllegalAccessException, java.lang.NoSuchMethodException;
    method public java.lang.invoke.MethodHandle findConstructor(Class<?>, java.lang.invoke.MethodType) throws java.lang.IllegalAccessException, java.lang.NoSuchMethodException;
    method public java.lang.invoke.MethodHandle findGetter(Class<?>, String, Class<?>) throws java.lang.IllegalAccessException, java.lang.NoSuchFieldException;
    method public java.lang.invoke.MethodHandle findSetter(Class<?>, String, Class<?>) throws java.lang.IllegalAccessException, java.lang.NoSuchFieldException;
    method public java.lang.invoke.MethodHandle findSpecial(Class<?>, String, java.lang.invoke.MethodType, Class<?>) throws java.lang.IllegalAccessException, java.lang.NoSuchMethodException;
    method public java.lang.invoke.MethodHandle findStatic(Class<?>, String, java.lang.invoke.MethodType) throws java.lang.IllegalAccessException, java.lang.NoSuchMethodException;
    method public java.lang.invoke.MethodHandle findStaticGetter(Class<?>, String, Class<?>) throws java.lang.IllegalAccessException, java.lang.NoSuchFieldException;
    method public java.lang.invoke.MethodHandle findStaticSetter(Class<?>, String, Class<?>) throws java.lang.IllegalAccessException, java.lang.NoSuchFieldException;
    method public java.lang.invoke.VarHandle findStaticVarHandle(Class<?>, String, Class<?>) throws java.lang.IllegalAccessException, java.lang.NoSuchFieldException;
    method public java.lang.invoke.VarHandle findVarHandle(Class<?>, String, Class<?>) throws java.lang.IllegalAccessException, java.lang.NoSuchFieldException;
    method public java.lang.invoke.MethodHandle findVirtual(Class<?>, String, java.lang.invoke.MethodType) throws java.lang.IllegalAccessException, java.lang.NoSuchMethodException;
    method public java.lang.invoke.MethodHandles.Lookup in(Class<?>);
    method public Class<?> lookupClass();
    method public int lookupModes();
    method public java.lang.invoke.MethodHandleInfo revealDirect(java.lang.invoke.MethodHandle);
    method public java.lang.invoke.MethodHandle unreflect(java.lang.reflect.Method) throws java.lang.IllegalAccessException;
    method public java.lang.invoke.MethodHandle unreflectConstructor(java.lang.reflect.Constructor<?>) throws java.lang.IllegalAccessException;
    method public java.lang.invoke.MethodHandle unreflectGetter(java.lang.reflect.Field) throws java.lang.IllegalAccessException;
    method public java.lang.invoke.MethodHandle unreflectSetter(java.lang.reflect.Field) throws java.lang.IllegalAccessException;
    method public java.lang.invoke.MethodHandle unreflectSpecial(java.lang.reflect.Method, Class<?>) throws java.lang.IllegalAccessException;
    method public java.lang.invoke.VarHandle unreflectVarHandle(java.lang.reflect.Field) throws java.lang.IllegalAccessException;
    field public static final int PACKAGE = 8; // 0x8
    field public static final int PRIVATE = 2; // 0x2
    field public static final int PROTECTED = 4; // 0x4
    field public static final int PUBLIC = 1; // 0x1
  }

  public final class MethodType implements java.io.Serializable java.lang.invoke.TypeDescriptor.OfMethod<java.lang.Class<?>,java.lang.invoke.MethodType> {
    method public java.lang.invoke.MethodType appendParameterTypes(Class<?>...);
    method public java.lang.invoke.MethodType appendParameterTypes(java.util.List<java.lang.Class<?>>);
    method public java.lang.invoke.MethodType changeParameterType(int, Class<?>);
    method public java.lang.invoke.MethodType changeReturnType(Class<?>);
    method @NonNull public String descriptorString();
    method public java.lang.invoke.MethodType dropParameterTypes(int, int);
    method public java.lang.invoke.MethodType erase();
    method public static java.lang.invoke.MethodType fromMethodDescriptorString(String, ClassLoader) throws java.lang.IllegalArgumentException, java.lang.TypeNotPresentException;
    method public java.lang.invoke.MethodType generic();
    method public static java.lang.invoke.MethodType genericMethodType(int, boolean);
    method public static java.lang.invoke.MethodType genericMethodType(int);
    method public boolean hasPrimitives();
    method public boolean hasWrappers();
    method public java.lang.invoke.MethodType insertParameterTypes(int, Class<?>...);
    method public java.lang.invoke.MethodType insertParameterTypes(int, java.util.List<java.lang.Class<?>>);
    method public Class<?> lastParameterType();
    method public static java.lang.invoke.MethodType methodType(Class<?>, Class<?>[]);
    method public static java.lang.invoke.MethodType methodType(Class<?>, java.util.List<java.lang.Class<?>>);
    method public static java.lang.invoke.MethodType methodType(Class<?>, Class<?>, Class<?>...);
    method public static java.lang.invoke.MethodType methodType(Class<?>);
    method public static java.lang.invoke.MethodType methodType(Class<?>, Class<?>);
    method public static java.lang.invoke.MethodType methodType(Class<?>, java.lang.invoke.MethodType);
    method public Class<?>[] parameterArray();
    method public int parameterCount();
    method public java.util.List<java.lang.Class<?>> parameterList();
    method public Class<?> parameterType(int);
    method public Class<?> returnType();
    method public String toMethodDescriptorString();
    method public java.lang.invoke.MethodType unwrap();
    method public java.lang.invoke.MethodType wrap();
  }

  public class MutableCallSite extends java.lang.invoke.CallSite {
    ctor public MutableCallSite(java.lang.invoke.MethodType);
    ctor public MutableCallSite(java.lang.invoke.MethodHandle);
    method public final java.lang.invoke.MethodHandle dynamicInvoker();
    method public final java.lang.invoke.MethodHandle getTarget();
    method public void setTarget(java.lang.invoke.MethodHandle);
  }

  public interface TypeDescriptor {
    method public String descriptorString();
  }

  public static interface TypeDescriptor.OfField<F extends java.lang.invoke.TypeDescriptor.OfField<F>> extends java.lang.invoke.TypeDescriptor {
    method public F arrayType();
    method public F componentType();
    method public boolean isArray();
    method public boolean isPrimitive();
  }

  public static interface TypeDescriptor.OfMethod<F extends java.lang.invoke.TypeDescriptor.OfField<F>, M extends java.lang.invoke.TypeDescriptor.OfMethod<F, M>> extends java.lang.invoke.TypeDescriptor {
    method public M changeParameterType(int, F);
    method public M changeReturnType(F);
    method public M dropParameterTypes(int, int);
    method public M insertParameterTypes(int, F...);
    method public F[] parameterArray();
    method public int parameterCount();
    method public java.util.List<F> parameterList();
    method public F parameterType(int);
    method public F returnType();
  }

  public abstract class VarHandle {
    method public final java.lang.invoke.MethodType accessModeType(java.lang.invoke.VarHandle.AccessMode);
    method public static void acquireFence();
    method public final native Object compareAndExchange(java.lang.Object...);
    method public final native Object compareAndExchangeAcquire(java.lang.Object...);
    method public final native Object compareAndExchangeRelease(java.lang.Object...);
    method public final native boolean compareAndSet(java.lang.Object...);
    method public final java.util.List<java.lang.Class<?>> coordinateTypes();
    method public static void fullFence();
    method public final native Object get(java.lang.Object...);
    method public final native Object getAcquire(java.lang.Object...);
    method public final native Object getAndAdd(java.lang.Object...);
    method public final native Object getAndAddAcquire(java.lang.Object...);
    method public final native Object getAndAddRelease(java.lang.Object...);
    method public final native Object getAndBitwiseAnd(java.lang.Object...);
    method public final native Object getAndBitwiseAndAcquire(java.lang.Object...);
    method public final native Object getAndBitwiseAndRelease(java.lang.Object...);
    method public final native Object getAndBitwiseOr(java.lang.Object...);
    method public final native Object getAndBitwiseOrAcquire(java.lang.Object...);
    method public final native Object getAndBitwiseOrRelease(java.lang.Object...);
    method public final native Object getAndBitwiseXor(java.lang.Object...);
    method public final native Object getAndBitwiseXorAcquire(java.lang.Object...);
    method public final native Object getAndBitwiseXorRelease(java.lang.Object...);
    method public final native Object getAndSet(java.lang.Object...);
    method public final native Object getAndSetAcquire(java.lang.Object...);
    method public final native Object getAndSetRelease(java.lang.Object...);
    method public final native Object getOpaque(java.lang.Object...);
    method public final native Object getVolatile(java.lang.Object...);
    method public final boolean isAccessModeSupported(java.lang.invoke.VarHandle.AccessMode);
    method public static void loadLoadFence();
    method public static void releaseFence();
    method public final native void set(java.lang.Object...);
    method public final native void setOpaque(java.lang.Object...);
    method public final native void setRelease(java.lang.Object...);
    method public final native void setVolatile(java.lang.Object...);
    method public static void storeStoreFence();
    method public final java.lang.invoke.MethodHandle toMethodHandle(java.lang.invoke.VarHandle.AccessMode);
    method public final Class<?> varType();
    method public final native boolean weakCompareAndSet(java.lang.Object...);
    method public final native boolean weakCompareAndSetAcquire(java.lang.Object...);
    method public final native boolean weakCompareAndSetPlain(java.lang.Object...);
    method public final native boolean weakCompareAndSetRelease(java.lang.Object...);
  }

  public enum VarHandle.AccessMode {
    method public String methodName();
    method public static java.lang.invoke.VarHandle.AccessMode valueFromMethodName(String);
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode COMPARE_AND_EXCHANGE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode COMPARE_AND_EXCHANGE_ACQUIRE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode COMPARE_AND_EXCHANGE_RELEASE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode COMPARE_AND_SET;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET_ACQUIRE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET_AND_ADD;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET_AND_ADD_ACQUIRE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET_AND_ADD_RELEASE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET_AND_BITWISE_AND;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET_AND_BITWISE_AND_ACQUIRE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET_AND_BITWISE_AND_RELEASE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET_AND_BITWISE_OR;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET_AND_BITWISE_OR_ACQUIRE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET_AND_BITWISE_OR_RELEASE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET_AND_BITWISE_XOR;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET_AND_BITWISE_XOR_ACQUIRE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET_AND_BITWISE_XOR_RELEASE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET_AND_SET;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET_AND_SET_ACQUIRE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET_AND_SET_RELEASE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET_OPAQUE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode GET_VOLATILE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode SET;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode SET_OPAQUE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode SET_RELEASE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode SET_VOLATILE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode WEAK_COMPARE_AND_SET;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode WEAK_COMPARE_AND_SET_ACQUIRE;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode WEAK_COMPARE_AND_SET_PLAIN;
    enum_constant public static final java.lang.invoke.VarHandle.AccessMode WEAK_COMPARE_AND_SET_RELEASE;
  }

  public class VolatileCallSite extends java.lang.invoke.CallSite {
    ctor public VolatileCallSite(java.lang.invoke.MethodType);
    ctor public VolatileCallSite(java.lang.invoke.MethodHandle);
    method public final java.lang.invoke.MethodHandle dynamicInvoker();
    method public final java.lang.invoke.MethodHandle getTarget();
    method public void setTarget(java.lang.invoke.MethodHandle);
  }

  public class WrongMethodTypeException extends java.lang.RuntimeException {
    ctor public WrongMethodTypeException();
    ctor public WrongMethodTypeException(String);
  }

}

package java.lang.ref {

  public final class Cleaner {
    method public static java.lang.ref.Cleaner create();
    method public static java.lang.ref.Cleaner create(java.util.concurrent.ThreadFactory);
    method public java.lang.ref.Cleaner.Cleanable register(Object, Runnable);
  }

  public static interface Cleaner.Cleanable {
    method public void clean();
  }

  public class PhantomReference<T> extends java.lang.ref.Reference<T> {
    ctor public PhantomReference(T, java.lang.ref.ReferenceQueue<? super T>);
  }

  public abstract class Reference<T> {
    method public void clear();
    method public boolean enqueue();
    method public T get();
    method @Deprecated public boolean isEnqueued();
    method public static void reachabilityFence(Object);
    method public final boolean refersTo(T);
  }

  public class ReferenceQueue<T> {
    ctor public ReferenceQueue();
    method public java.lang.ref.Reference<? extends T> poll();
    method public java.lang.ref.Reference<? extends T> remove(long) throws java.lang.IllegalArgumentException, java.lang.InterruptedException;
    method public java.lang.ref.Reference<? extends T> remove() throws java.lang.InterruptedException;
  }

  public class SoftReference<T> extends java.lang.ref.Reference<T> {
    ctor public SoftReference(T);
    ctor public SoftReference(T, java.lang.ref.ReferenceQueue<? super T>);
  }

  public class WeakReference<T> extends java.lang.ref.Reference<T> {
    ctor public WeakReference(T);
    ctor public WeakReference(T, java.lang.ref.ReferenceQueue<? super T>);
  }

}

package java.lang.reflect {

  public class AccessibleObject implements java.lang.reflect.AnnotatedElement {
    ctor protected AccessibleObject();
    method @Nullable public <T extends java.lang.annotation.Annotation> T getAnnotation(@NonNull Class<T>);
    method @NonNull public java.lang.annotation.Annotation[] getAnnotations();
    method public <T extends java.lang.annotation.Annotation> T[] getAnnotationsByType(@NonNull Class<T>);
    method @Nullable public <T extends java.lang.annotation.Annotation> T getDeclaredAnnotation(@NonNull Class<T>);
    method @NonNull public java.lang.annotation.Annotation[] getDeclaredAnnotations();
    method public <T extends java.lang.annotation.Annotation> T[] getDeclaredAnnotationsByType(@NonNull Class<T>);
    method public boolean isAccessible();
    method public boolean isAnnotationPresent(@NonNull Class<? extends java.lang.annotation.Annotation>);
    method public static void setAccessible(java.lang.reflect.AccessibleObject[], boolean) throws java.lang.SecurityException;
    method public void setAccessible(boolean) throws java.lang.SecurityException;
  }

  public interface AnnotatedElement {
    method @Nullable public <T extends java.lang.annotation.Annotation> T getAnnotation(@NonNull Class<T>);
    method @NonNull public java.lang.annotation.Annotation[] getAnnotations();
    method public default <T extends java.lang.annotation.Annotation> T[] getAnnotationsByType(@NonNull Class<T>);
    method @Nullable public default <T extends java.lang.annotation.Annotation> T getDeclaredAnnotation(@NonNull Class<T>);
    method @NonNull public java.lang.annotation.Annotation[] getDeclaredAnnotations();
    method public default <T extends java.lang.annotation.Annotation> T[] getDeclaredAnnotationsByType(@NonNull Class<T>);
    method public default boolean isAnnotationPresent(@NonNull Class<? extends java.lang.annotation.Annotation>);
  }

  public final class Array {
    method @Nullable public static Object get(@NonNull Object, int) throws java.lang.ArrayIndexOutOfBoundsException, java.lang.IllegalArgumentException;
    method public static boolean getBoolean(@NonNull Object, int) throws java.lang.ArrayIndexOutOfBoundsException, java.lang.IllegalArgumentException;
    method public static byte getByte(@NonNull Object, int) throws java.lang.ArrayIndexOutOfBoundsException, java.lang.IllegalArgumentException;
    method public static char getChar(@NonNull Object, int) throws java.lang.ArrayIndexOutOfBoundsException, java.lang.IllegalArgumentException;
    method public static double getDouble(@NonNull Object, int) throws java.lang.ArrayIndexOutOfBoundsException, java.lang.IllegalArgumentException;
    method public static float getFloat(@NonNull Object, int) throws java.lang.ArrayIndexOutOfBoundsException, java.lang.IllegalArgumentException;
    method public static int getInt(@NonNull Object, int) throws java.lang.ArrayIndexOutOfBoundsException, java.lang.IllegalArgumentException;
    method public static int getLength(@NonNull Object);
    method public static long getLong(@NonNull Object, int) throws java.lang.ArrayIndexOutOfBoundsException, java.lang.IllegalArgumentException;
    method public static short getShort(@NonNull Object, int) throws java.lang.ArrayIndexOutOfBoundsException, java.lang.IllegalArgumentException;
    method @NonNull public static Object newInstance(@NonNull Class<?>, int) throws java.lang.NegativeArraySizeException;
    method @NonNull public static Object newInstance(@NonNull Class<?>, int...) throws java.lang.IllegalArgumentException, java.lang.NegativeArraySizeException;
    method public static void set(@NonNull Object, int, @Nullable Object) throws java.lang.ArrayIndexOutOfBoundsException, java.lang.IllegalArgumentException;
    method public static void setBoolean(@NonNull Object, int, boolean);
    method public static void setByte(@NonNull Object, int, byte) throws java.lang.ArrayIndexOutOfBoundsException, java.lang.IllegalArgumentException;
    method public static void setChar(@NonNull Object, int, char) throws java.lang.ArrayIndexOutOfBoundsException, java.lang.IllegalArgumentException;
    method public static void setDouble(@NonNull Object, int, double) throws java.lang.ArrayIndexOutOfBoundsException, java.lang.IllegalArgumentException;
    method public static void setFloat(@NonNull Object, int, float) throws java.lang.ArrayIndexOutOfBoundsException, java.lang.IllegalArgumentException;
    method public static void setInt(@NonNull Object, int, int) throws java.lang.ArrayIndexOutOfBoundsException, java.lang.IllegalArgumentException;
    method public static void setLong(@NonNull Object, int, long) throws java.lang.ArrayIndexOutOfBoundsException, java.lang.IllegalArgumentException;
    method public static void setShort(@NonNull Object, int, short) throws java.lang.ArrayIndexOutOfBoundsException, java.lang.IllegalArgumentException;
  }

  public final class Constructor<T> extends java.lang.reflect.Executable {
    method @NonNull public Class<T> getDeclaringClass();
    method public Class<?>[] getExceptionTypes();
    method public int getModifiers();
    method @NonNull public String getName();
    method public java.lang.annotation.Annotation[][] getParameterAnnotations();
    method @NonNull public Class<?>[] getParameterTypes();
    method public java.lang.reflect.TypeVariable<java.lang.reflect.Constructor<T>>[] getTypeParameters();
    method @NonNull public T newInstance(java.lang.Object...) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException, java.lang.InstantiationException, java.lang.reflect.InvocationTargetException;
    method @NonNull public String toGenericString();
  }

  public abstract class Executable extends java.lang.reflect.AccessibleObject implements java.lang.reflect.GenericDeclaration java.lang.reflect.Member {
    method @NonNull public abstract Class<?>[] getExceptionTypes();
    method @NonNull public java.lang.reflect.Type[] getGenericExceptionTypes();
    method @NonNull public java.lang.reflect.Type[] getGenericParameterTypes();
    method @NonNull public abstract java.lang.annotation.Annotation[][] getParameterAnnotations();
    method public int getParameterCount();
    method @NonNull public abstract Class<?>[] getParameterTypes();
    method @NonNull public java.lang.reflect.Parameter[] getParameters();
    method public final boolean isAnnotationPresent(@NonNull Class<? extends java.lang.annotation.Annotation>);
    method public boolean isSynthetic();
    method public boolean isVarArgs();
    method @NonNull public abstract String toGenericString();
  }

  public final class Field extends java.lang.reflect.AccessibleObject implements java.lang.reflect.Member {
    method @Nullable public Object get(@Nullable Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public boolean getBoolean(@Nullable Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public byte getByte(@Nullable Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public char getChar(@Nullable Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method @NonNull public Class<?> getDeclaringClass();
    method public double getDouble(@Nullable Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public float getFloat(@Nullable Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method @NonNull public java.lang.reflect.Type getGenericType();
    method public int getInt(@Nullable Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public long getLong(@Nullable Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public int getModifiers();
    method @NonNull public String getName();
    method public short getShort(@Nullable Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method @NonNull public Class<?> getType();
    method public boolean isEnumConstant();
    method public boolean isSynthetic();
    method public void set(@Nullable Object, @Nullable Object) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public void setBoolean(@Nullable Object, boolean) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public void setByte(@Nullable Object, byte) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public void setChar(@Nullable Object, char) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public void setDouble(@Nullable Object, double) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public void setFloat(@Nullable Object, float) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public void setInt(@Nullable Object, int) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public void setLong(@Nullable Object, long) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method public void setShort(@Nullable Object, short) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException;
    method @NonNull public String toGenericString();
  }

  public interface GenericArrayType extends java.lang.reflect.Type {
    method @NonNull public java.lang.reflect.Type getGenericComponentType();
  }

  public interface GenericDeclaration extends java.lang.reflect.AnnotatedElement {
    method @NonNull public java.lang.reflect.TypeVariable<?>[] getTypeParameters();
  }

  public class GenericSignatureFormatError extends java.lang.ClassFormatError {
    ctor public GenericSignatureFormatError();
    ctor public GenericSignatureFormatError(String);
  }

  public interface InvocationHandler {
    method public Object invoke(Object, java.lang.reflect.Method, Object[]) throws java.lang.Throwable;
  }

  public class InvocationTargetException extends java.lang.ReflectiveOperationException {
    ctor protected InvocationTargetException();
    ctor public InvocationTargetException(Throwable);
    ctor public InvocationTargetException(Throwable, String);
    method public Throwable getTargetException();
  }

  public class MalformedParameterizedTypeException extends java.lang.RuntimeException {
    ctor public MalformedParameterizedTypeException();
    ctor public MalformedParameterizedTypeException(String);
  }

  public class MalformedParametersException extends java.lang.RuntimeException {
    ctor public MalformedParametersException();
    ctor public MalformedParametersException(String);
  }

  public interface Member {
    method @NonNull public Class<?> getDeclaringClass();
    method public int getModifiers();
    method @NonNull public String getName();
    method public boolean isSynthetic();
    field public static final int DECLARED = 1; // 0x1
    field public static final int PUBLIC = 0; // 0x0
  }

  public final class Method extends java.lang.reflect.Executable {
    method @NonNull public Class<?> getDeclaringClass();
    method @Nullable public Object getDefaultValue();
    method @NonNull public Class<?>[] getExceptionTypes();
    method @NonNull public java.lang.reflect.Type getGenericReturnType();
    method public int getModifiers();
    method @NonNull public String getName();
    method @NonNull public java.lang.annotation.Annotation[][] getParameterAnnotations();
    method @NonNull public Class<?>[] getParameterTypes();
    method @NonNull public Class<?> getReturnType();
    method @NonNull public java.lang.reflect.TypeVariable<java.lang.reflect.Method>[] getTypeParameters();
    method @Nullable public Object invoke(@Nullable Object, @Nullable java.lang.Object...) throws java.lang.IllegalAccessException, java.lang.IllegalArgumentException, java.lang.reflect.InvocationTargetException;
    method public boolean isBridge();
    method public boolean isDefault();
    method @NonNull public String toGenericString();
  }

  public class Modifier {
    ctor public Modifier();
    method public static int classModifiers();
    method public static int constructorModifiers();
    method public static int fieldModifiers();
    method public static int interfaceModifiers();
    method public static boolean isAbstract(int);
    method public static boolean isFinal(int);
    method public static boolean isInterface(int);
    method public static boolean isNative(int);
    method public static boolean isPrivate(int);
    method public static boolean isProtected(int);
    method public static boolean isPublic(int);
    method public static boolean isStatic(int);
    method public static boolean isStrict(int);
    method public static boolean isSynchronized(int);
    method public static boolean isTransient(int);
    method public static boolean isVolatile(int);
    method public static int methodModifiers();
    method public static int parameterModifiers();
    method public static String toString(int);
    field public static final int ABSTRACT = 1024; // 0x400
    field public static final int FINAL = 16; // 0x10
    field public static final int INTERFACE = 512; // 0x200
    field public static final int NATIVE = 256; // 0x100
    field public static final int PRIVATE = 2; // 0x2
    field public static final int PROTECTED = 4; // 0x4
    field public static final int PUBLIC = 1; // 0x1
    field public static final int STATIC = 8; // 0x8
    field public static final int STRICT = 2048; // 0x800
    field public static final int SYNCHRONIZED = 32; // 0x20
    field public static final int TRANSIENT = 128; // 0x80
    field public static final int VOLATILE = 64; // 0x40
  }

  public final class Parameter implements java.lang.reflect.AnnotatedElement {
    method @Nullable public <T extends java.lang.annotation.Annotation> T getAnnotation(@NonNull Class<T>);
    method @NonNull public java.lang.annotation.Annotation[] getAnnotations();
    method public <T extends java.lang.annotation.Annotation> T[] getAnnotationsByType(@NonNull Class<T>);
    method @Nullable public <T extends java.lang.annotation.Annotation> T getDeclaredAnnotation(@NonNull Class<T>);
    method @NonNull public java.lang.annotation.Annotation[] getDeclaredAnnotations();
    method public <T extends java.lang.annotation.Annotation> T[] getDeclaredAnnotationsByType(@NonNull Class<T>);
    method @NonNull public java.lang.reflect.Executable getDeclaringExecutable();
    method public int getModifiers();
    method @NonNull public String getName();
    method @NonNull public java.lang.reflect.Type getParameterizedType();
    method @NonNull public Class<?> getType();
    method public boolean isImplicit();
    method public boolean isNamePresent();
    method public boolean isSynthetic();
    method public boolean isVarArgs();
  }

  public interface ParameterizedType extends java.lang.reflect.Type {
    method @NonNull public java.lang.reflect.Type[] getActualTypeArguments();
    method @Nullable public java.lang.reflect.Type getOwnerType();
    method @NonNull public java.lang.reflect.Type getRawType();
  }

  public class Proxy implements java.io.Serializable {
    ctor protected Proxy(@NonNull java.lang.reflect.InvocationHandler);
    method @NonNull public static java.lang.reflect.InvocationHandler getInvocationHandler(@NonNull Object) throws java.lang.IllegalArgumentException;
    method @NonNull public static Class<?> getProxyClass(@Nullable ClassLoader, @NonNull Class<?>...) throws java.lang.IllegalArgumentException;
    method public static boolean isProxyClass(@NonNull Class<?>);
    method @NonNull public static Object newProxyInstance(@Nullable ClassLoader, @NonNull Class<?>[], @NonNull java.lang.reflect.InvocationHandler) throws java.lang.IllegalArgumentException;
    field protected java.lang.reflect.InvocationHandler h;
  }

  public final class RecordComponent implements java.lang.reflect.AnnotatedElement {
    method @NonNull public java.lang.reflect.Method getAccessor();
    method @Nullable public <T extends java.lang.annotation.Annotation> T getAnnotation(@NonNull Class<T>);
    method @NonNull public java.lang.annotation.Annotation[] getAnnotations();
    method @NonNull public java.lang.annotation.Annotation[] getDeclaredAnnotations();
    method @NonNull public Class<?> getDeclaringRecord();
    method @Nullable public String getGenericSignature();
    method @NonNull public java.lang.reflect.Type getGenericType();
    method @NonNull public String getName();
    method @NonNull public Class<?> getType();
  }

  public final class ReflectPermission extends java.security.BasicPermission {
    ctor public ReflectPermission(String);
    ctor public ReflectPermission(String, String);
  }

  public interface Type {
    method @NonNull public default String getTypeName();
  }

  public interface TypeVariable<D extends java.lang.reflect.GenericDeclaration> extends java.lang.reflect.Type {
    method @NonNull public java.lang.reflect.Type[] getBounds();
    method @NonNull public D getGenericDeclaration();
    method @NonNull public String getName();
  }

  public class UndeclaredThrowableException extends java.lang.RuntimeException {
    ctor public UndeclaredThrowableException(Throwable);
    ctor public UndeclaredThrowableException(Throwable, String);
    method public Throwable getUndeclaredThrowable();
  }

  public interface WildcardType extends java.lang.reflect.Type {
    method @NonNull public java.lang.reflect.Type[] getLowerBounds();
    method @NonNull public java.lang.reflect.Type[] getUpperBounds();
  }

}

package java.lang.runtime {

  public class ObjectMethods {
    method @NonNull public static Object bootstrap(@NonNull java.lang.invoke.MethodHandles.Lookup, @NonNull String, @NonNull java.lang.invoke.TypeDescriptor, @NonNull Class<?>, @Nullable String, @NonNull java.lang.invoke.MethodHandle...) throws java.lang.Throwable;
  }

}

package java.math {

  public class BigDecimal extends java.lang.Number implements java.lang.Comparable<java.math.BigDecimal> {
    ctor public BigDecimal(char[], int, int);
    ctor public BigDecimal(char[], int, int, java.math.MathContext);
    ctor public BigDecimal(char[]);
    ctor public BigDecimal(char[], java.math.MathContext);
    ctor public BigDecimal(String);
    ctor public BigDecimal(String, java.math.MathContext);
    ctor public BigDecimal(double);
    ctor public BigDecimal(double, java.math.MathContext);
    ctor public BigDecimal(java.math.BigInteger);
    ctor public BigDecimal(java.math.BigInteger, java.math.MathContext);
    ctor public BigDecimal(java.math.BigInteger, int);
    ctor public BigDecimal(java.math.BigInteger, int, java.math.MathContext);
    ctor public BigDecimal(int);
    ctor public BigDecimal(int, java.math.MathContext);
    ctor public BigDecimal(long);
    ctor public BigDecimal(long, java.math.MathContext);
    method public java.math.BigDecimal abs();
    method public java.math.BigDecimal abs(java.math.MathContext);
    method public java.math.BigDecimal add(java.math.BigDecimal);
    method public java.math.BigDecimal add(java.math.BigDecimal, java.math.MathContext);
    method public byte byteValueExact();
    method public int compareTo(java.math.BigDecimal);
    method @Deprecated public java.math.BigDecimal divide(java.math.BigDecimal, int, int);
    method public java.math.BigDecimal divide(java.math.BigDecimal, int, java.math.RoundingMode);
    method @Deprecated public java.math.BigDecimal divide(java.math.BigDecimal, int);
    method public java.math.BigDecimal divide(java.math.BigDecimal, java.math.RoundingMode);
    method public java.math.BigDecimal divide(java.math.BigDecimal);
    method public java.math.BigDecimal divide(java.math.BigDecimal, java.math.MathContext);
    method public java.math.BigDecimal[] divideAndRemainder(java.math.BigDecimal);
    method public java.math.BigDecimal[] divideAndRemainder(java.math.BigDecimal, java.math.MathContext);
    method public java.math.BigDecimal divideToIntegralValue(java.math.BigDecimal);
    method public java.math.BigDecimal divideToIntegralValue(java.math.BigDecimal, java.math.MathContext);
    method public double doubleValue();
    method public float floatValue();
    method public int intValue();
    method public int intValueExact();
    method public long longValue();
    method public long longValueExact();
    method public java.math.BigDecimal max(java.math.BigDecimal);
    method public java.math.BigDecimal min(java.math.BigDecimal);
    method public java.math.BigDecimal movePointLeft(int);
    method public java.math.BigDecimal movePointRight(int);
    method public java.math.BigDecimal multiply(java.math.BigDecimal);
    method public java.math.BigDecimal multiply(java.math.BigDecimal, java.math.MathContext);
    method public java.math.BigDecimal negate();
    method public java.math.BigDecimal negate(java.math.MathContext);
    method public java.math.BigDecimal plus();
    method public java.math.BigDecimal plus(java.math.MathContext);
    method public java.math.BigDecimal pow(int);
    method public java.math.BigDecimal pow(int, java.math.MathContext);
    method public int precision();
    method public java.math.BigDecimal remainder(java.math.BigDecimal);
    method public java.math.BigDecimal remainder(java.math.BigDecimal, java.math.MathContext);
    method public java.math.BigDecimal round(java.math.MathContext);
    method public int scale();
    method public java.math.BigDecimal scaleByPowerOfTen(int);
    method public java.math.BigDecimal setScale(int, java.math.RoundingMode);
    method @Deprecated public java.math.BigDecimal setScale(int, int);
    method public java.math.BigDecimal setScale(int);
    method public short shortValueExact();
    method public int signum();
    method public java.math.BigDecimal sqrt(java.math.MathContext);
    method public java.math.BigDecimal stripTrailingZeros();
    method public java.math.BigDecimal subtract(java.math.BigDecimal);
    method public java.math.BigDecimal subtract(java.math.BigDecimal, java.math.MathContext);
    method public java.math.BigInteger toBigInteger();
    method public java.math.BigInteger toBigIntegerExact();
    method public String toEngineeringString();
    method public String toPlainString();
    method public java.math.BigDecimal ulp();
    method public java.math.BigInteger unscaledValue();
    method public static java.math.BigDecimal valueOf(long, int);
    method public static java.math.BigDecimal valueOf(long);
    method public static java.math.BigDecimal valueOf(double);
    field public static final java.math.BigDecimal ONE;
    field @Deprecated public static final int ROUND_CEILING = 2; // 0x2
    field @Deprecated public static final int ROUND_DOWN = 1; // 0x1
    field @Deprecated public static final int ROUND_FLOOR = 3; // 0x3
    field @Deprecated public static final int ROUND_HALF_DOWN = 5; // 0x5
    field @Deprecated public static final int ROUND_HALF_EVEN = 6; // 0x6
    field @Deprecated public static final int ROUND_HALF_UP = 4; // 0x4
    field @Deprecated public static final int ROUND_UNNECESSARY = 7; // 0x7
    field @Deprecated public static final int ROUND_UP = 0; // 0x0
    field public static final java.math.BigDecimal TEN;
    field public static final java.math.BigDecimal ZERO;
  }

  public class BigInteger extends java.lang.Number implements java.lang.Comparable<java.math.BigInteger> {
    ctor public BigInteger(byte[], int, int);
    ctor public BigInteger(byte[]);
    ctor public BigInteger(int, byte[], int, int);
    ctor public BigInteger(int, byte[]);
    ctor public BigInteger(@NonNull String, int);
    ctor public BigInteger(@NonNull String);
    ctor public BigInteger(int, @NonNull java.util.Random);
    ctor public BigInteger(int, int, @NonNull java.util.Random);
    method @NonNull public java.math.BigInteger abs();
    method @NonNull public java.math.BigInteger add(@NonNull java.math.BigInteger);
    method @NonNull public java.math.BigInteger and(@NonNull java.math.BigInteger);
    method @NonNull public java.math.BigInteger andNot(@NonNull java.math.BigInteger);
    method public int bitCount();
    method public int bitLength();
    method public byte byteValueExact();
    method @NonNull public java.math.BigInteger clearBit(int);
    method public int compareTo(@NonNull java.math.BigInteger);
    method @NonNull public java.math.BigInteger divide(@NonNull java.math.BigInteger);
    method @NonNull public java.math.BigInteger[] divideAndRemainder(@NonNull java.math.BigInteger);
    method public double doubleValue();
    method @NonNull public java.math.BigInteger flipBit(int);
    method public float floatValue();
    method @NonNull public java.math.BigInteger gcd(@NonNull java.math.BigInteger);
    method public int getLowestSetBit();
    method public int intValue();
    method public int intValueExact();
    method public boolean isProbablePrime(int);
    method public long longValue();
    method public long longValueExact();
    method @NonNull public java.math.BigInteger max(@NonNull java.math.BigInteger);
    method @NonNull public java.math.BigInteger min(@NonNull java.math.BigInteger);
    method @NonNull public java.math.BigInteger mod(@NonNull java.math.BigInteger);
    method @NonNull public java.math.BigInteger modInverse(@NonNull java.math.BigInteger);
    method @NonNull public java.math.BigInteger modPow(@NonNull java.math.BigInteger, @NonNull java.math.BigInteger);
    method @NonNull public java.math.BigInteger multiply(@NonNull java.math.BigInteger);
    method @NonNull public java.math.BigInteger negate();
    method @NonNull public java.math.BigInteger nextProbablePrime();
    method @NonNull public java.math.BigInteger not();
    method @NonNull public java.math.BigInteger or(@NonNull java.math.BigInteger);
    method @NonNull public java.math.BigInteger pow(int);
    method @NonNull public static java.math.BigInteger probablePrime(int, @NonNull java.util.Random);
    method @NonNull public java.math.BigInteger remainder(@NonNull java.math.BigInteger);
    method @NonNull public java.math.BigInteger setBit(int);
    method @NonNull public java.math.BigInteger shiftLeft(int);
    method @NonNull public java.math.BigInteger shiftRight(int);
    method public short shortValueExact();
    method public int signum();
    method @NonNull public java.math.BigInteger sqrt();
    method @NonNull public java.math.BigInteger[] sqrtAndRemainder();
    method @NonNull public java.math.BigInteger subtract(@NonNull java.math.BigInteger);
    method public boolean testBit(int);
    method public byte[] toByteArray();
    method @NonNull public String toString(int);
    method @NonNull public static java.math.BigInteger valueOf(long);
    method @NonNull public java.math.BigInteger xor(@NonNull java.math.BigInteger);
    field @NonNull public static final java.math.BigInteger ONE;
    field @NonNull public static final java.math.BigInteger TEN;
    field @NonNull public static final java.math.BigInteger TWO;
    field @NonNull public static final java.math.BigInteger ZERO;
  }

  public final class MathContext implements java.io.Serializable {
    ctor public MathContext(int);
    ctor public MathContext(int, java.math.RoundingMode);
    ctor public MathContext(String);
    method public int getPrecision();
    method public java.math.RoundingMode getRoundingMode();
    field public static final java.math.MathContext DECIMAL128;
    field public static final java.math.MathContext DECIMAL32;
    field public static final java.math.MathContext DECIMAL64;
    field public static final java.math.MathContext UNLIMITED;
  }

  public enum RoundingMode {
    method public static java.math.RoundingMode valueOf(int);
    enum_constant public static final java.math.RoundingMode CEILING;
    enum_constant public static final java.math.RoundingMode DOWN;
    enum_constant public static final java.math.RoundingMode FLOOR;
    enum_constant public static final java.math.RoundingMode HALF_DOWN;
    enum_constant public static final java.math.RoundingMode HALF_EVEN;
    enum_constant public static final java.math.RoundingMode HALF_UP;
    enum_constant public static final java.math.RoundingMode UNNECESSARY;
    enum_constant public static final java.math.RoundingMode UP;
  }

}

package java.net {

  public abstract class Authenticator {
    ctor public Authenticator();
    method protected java.net.PasswordAuthentication getPasswordAuthentication();
    method protected final String getRequestingHost();
    method protected final int getRequestingPort();
    method protected final String getRequestingPrompt();
    method protected final String getRequestingProtocol();
    method protected final String getRequestingScheme();
    method protected final java.net.InetAddress getRequestingSite();
    method protected java.net.URL getRequestingURL();
    method protected java.net.Authenticator.RequestorType getRequestorType();
    method public static java.net.PasswordAuthentication requestPasswordAuthentication(java.net.InetAddress, int, String, String, String);
    method public static java.net.PasswordAuthentication requestPasswordAuthentication(String, java.net.InetAddress, int, String, String, String);
    method public static java.net.PasswordAuthentication requestPasswordAuthentication(String, java.net.InetAddress, int, String, String, String, java.net.URL, java.net.Authenticator.RequestorType);
    method public static void setDefault(java.net.Authenticator);
  }

  public enum Authenticator.RequestorType {
    enum_constant public static final java.net.Authenticator.RequestorType PROXY;
    enum_constant public static final java.net.Authenticator.RequestorType SERVER;
  }

  public class BindException extends java.net.SocketException {
    ctor public BindException(String);
    ctor public BindException();
  }

  public abstract class CacheRequest {
    ctor public CacheRequest();
    method public abstract void abort();
    method public abstract java.io.OutputStream getBody() throws java.io.IOException;
  }

  public abstract class CacheResponse {
    ctor public CacheResponse();
    method public abstract java.io.InputStream getBody() throws java.io.IOException;
    method public abstract java.util.Map<java.lang.String,java.util.List<java.lang.String>> getHeaders() throws java.io.IOException;
  }

  public class ConnectException extends java.net.SocketException {
    ctor public ConnectException(String);
    ctor public ConnectException();
  }

  public abstract class ContentHandler {
    ctor public ContentHandler();
    method public abstract Object getContent(java.net.URLConnection) throws java.io.IOException;
    method public Object getContent(java.net.URLConnection, Class[]) throws java.io.IOException;
  }

  public interface ContentHandlerFactory {
    method public java.net.ContentHandler createContentHandler(String);
  }

  public abstract class CookieHandler {
    ctor public CookieHandler();
    method public abstract java.util.Map<java.lang.String,java.util.List<java.lang.String>> get(java.net.URI, java.util.Map<java.lang.String,java.util.List<java.lang.String>>) throws java.io.IOException;
    method public static java.net.CookieHandler getDefault();
    method public abstract void put(java.net.URI, java.util.Map<java.lang.String,java.util.List<java.lang.String>>) throws java.io.IOException;
    method public static void setDefault(java.net.CookieHandler);
  }

  public class CookieManager extends java.net.CookieHandler {
    ctor public CookieManager();
    ctor public CookieManager(java.net.CookieStore, java.net.CookiePolicy);
    method public java.util.Map<java.lang.String,java.util.List<java.lang.String>> get(java.net.URI, java.util.Map<java.lang.String,java.util.List<java.lang.String>>) throws java.io.IOException;
    method public java.net.CookieStore getCookieStore();
    method public void put(java.net.URI, java.util.Map<java.lang.String,java.util.List<java.lang.String>>) throws java.io.IOException;
    method public void setCookiePolicy(java.net.CookiePolicy);
  }

  public interface CookiePolicy {
    method public boolean shouldAccept(java.net.URI, java.net.HttpCookie);
    field public static final java.net.CookiePolicy ACCEPT_ALL;
    field public static final java.net.CookiePolicy ACCEPT_NONE;
    field public static final java.net.CookiePolicy ACCEPT_ORIGINAL_SERVER;
  }

  public interface CookieStore {
    method public void add(java.net.URI, java.net.HttpCookie);
    method public java.util.List<java.net.HttpCookie> get(java.net.URI);
    method public java.util.List<java.net.HttpCookie> getCookies();
    method public java.util.List<java.net.URI> getURIs();
    method public boolean remove(java.net.URI, java.net.HttpCookie);
    method public boolean removeAll();
  }

  public final class DatagramPacket {
    ctor public DatagramPacket(byte[], int, int);
    ctor public DatagramPacket(byte[], int);
    ctor public DatagramPacket(byte[], int, int, java.net.InetAddress, int);
    ctor public DatagramPacket(byte[], int, int, java.net.SocketAddress);
    ctor public DatagramPacket(byte[], int, java.net.InetAddress, int);
    ctor public DatagramPacket(byte[], int, java.net.SocketAddress);
    method public java.net.InetAddress getAddress();
    method public byte[] getData();
    method public int getLength();
    method public int getOffset();
    method public int getPort();
    method public java.net.SocketAddress getSocketAddress();
    method public void setAddress(java.net.InetAddress);
    method public void setData(byte[], int, int);
    method public void setData(byte[]);
    method public void setLength(int);
    method public void setPort(int);
    method public void setSocketAddress(java.net.SocketAddress);
  }

  public class DatagramSocket implements java.io.Closeable {
    ctor public DatagramSocket() throws java.net.SocketException;
    ctor protected DatagramSocket(java.net.DatagramSocketImpl);
    ctor public DatagramSocket(java.net.SocketAddress) throws java.net.SocketException;
    ctor public DatagramSocket(int) throws java.net.SocketException;
    ctor public DatagramSocket(int, java.net.InetAddress) throws java.net.SocketException;
    method public void bind(java.net.SocketAddress) throws java.net.SocketException;
    method public void close();
    method public void connect(java.net.InetAddress, int);
    method public void connect(java.net.SocketAddress) throws java.net.SocketException;
    method public void disconnect();
    method public boolean getBroadcast() throws java.net.SocketException;
    method public java.nio.channels.DatagramChannel getChannel();
    method public java.net.InetAddress getInetAddress();
    method public java.net.InetAddress getLocalAddress();
    method public int getLocalPort();
    method public java.net.SocketAddress getLocalSocketAddress();
    method public <T> T getOption(java.net.SocketOption<T>) throws java.io.IOException;
    method public int getPort();
    method public int getReceiveBufferSize() throws java.net.SocketException;
    method public java.net.SocketAddress getRemoteSocketAddress();
    method public boolean getReuseAddress() throws java.net.SocketException;
    method public int getSendBufferSize() throws java.net.SocketException;
    method public int getSoTimeout() throws java.net.SocketException;
    method public int getTrafficClass() throws java.net.SocketException;
    method public boolean isBound();
    method public boolean isClosed();
    method public boolean isConnected();
    method public void receive(java.net.DatagramPacket) throws java.io.IOException;
    method public void send(java.net.DatagramPacket) throws java.io.IOException;
    method public void setBroadcast(boolean) throws java.net.SocketException;
    method public static void setDatagramSocketImplFactory(java.net.DatagramSocketImplFactory) throws java.io.IOException;
    method public <T> java.net.DatagramSocket setOption(java.net.SocketOption<T>, T) throws java.io.IOException;
    method public void setReceiveBufferSize(int) throws java.net.SocketException;
    method public void setReuseAddress(boolean) throws java.net.SocketException;
    method public void setSendBufferSize(int) throws java.net.SocketException;
    method public void setSoTimeout(int) throws java.net.SocketException;
    method public void setTrafficClass(int) throws java.net.SocketException;
    method public java.util.Set<java.net.SocketOption<?>> supportedOptions();
  }

  public abstract class DatagramSocketImpl implements java.net.SocketOptions {
    ctor public DatagramSocketImpl();
    method protected abstract void bind(int, java.net.InetAddress) throws java.net.SocketException;
    method protected abstract void close();
    method protected void connect(java.net.InetAddress, int) throws java.net.SocketException;
    method protected abstract void create() throws java.net.SocketException;
    method protected void disconnect();
    method protected java.io.FileDescriptor getFileDescriptor();
    method protected int getLocalPort();
    method protected <T> T getOption(java.net.SocketOption<T>) throws java.io.IOException;
    method @Deprecated protected abstract byte getTTL() throws java.io.IOException;
    method protected abstract int getTimeToLive() throws java.io.IOException;
    method protected abstract void join(java.net.InetAddress) throws java.io.IOException;
    method protected abstract void joinGroup(java.net.SocketAddress, java.net.NetworkInterface) throws java.io.IOException;
    method protected abstract void leave(java.net.InetAddress) throws java.io.IOException;
    method protected abstract void leaveGroup(java.net.SocketAddress, java.net.NetworkInterface) throws java.io.IOException;
    method protected abstract int peek(java.net.InetAddress) throws java.io.IOException;
    method protected abstract int peekData(java.net.DatagramPacket) throws java.io.IOException;
    method protected abstract void receive(java.net.DatagramPacket) throws java.io.IOException;
    method protected abstract void send(java.net.DatagramPacket) throws java.io.IOException;
    method protected <T> void setOption(java.net.SocketOption<T>, T) throws java.io.IOException;
    method @Deprecated protected abstract void setTTL(byte) throws java.io.IOException;
    method protected abstract void setTimeToLive(int) throws java.io.IOException;
    method protected java.util.Set<java.net.SocketOption<?>> supportedOptions();
    field protected java.io.FileDescriptor fd;
    field protected int localPort;
  }

  public interface DatagramSocketImplFactory {
    method public java.net.DatagramSocketImpl createDatagramSocketImpl();
  }

  public interface FileNameMap {
    method public String getContentTypeFor(String);
  }

  public final class HttpCookie implements java.lang.Cloneable {
    ctor public HttpCookie(String, String);
    method public Object clone();
    method public static boolean domainMatches(String, String);
    method public String getComment();
    method public String getCommentURL();
    method public boolean getDiscard();
    method public String getDomain();
    method public long getMaxAge();
    method public String getName();
    method public String getPath();
    method public String getPortlist();
    method public boolean getSecure();
    method public String getValue();
    method public int getVersion();
    method public boolean hasExpired();
    method public boolean isHttpOnly();
    method public static java.util.List<java.net.HttpCookie> parse(String);
    method public void setComment(String);
    method public void setCommentURL(String);
    method public void setDiscard(boolean);
    method public void setDomain(String);
    method public void setHttpOnly(boolean);
    method public void setMaxAge(long);
    method public void setPath(String);
    method public void setPortlist(String);
    method public void setSecure(boolean);
    method public void setValue(String);
    method public void setVersion(int);
  }

  public class HttpRetryException extends java.io.IOException {
    ctor public HttpRetryException(String, int);
    ctor public HttpRetryException(String, int, String);
    method public String getLocation();
    method public String getReason();
    method public int responseCode();
  }

  public abstract class HttpURLConnection extends java.net.URLConnection {
    ctor protected HttpURLConnection(java.net.URL);
    method public abstract void disconnect();
    method public java.io.InputStream getErrorStream();
    method public static boolean getFollowRedirects();
    method public boolean getInstanceFollowRedirects();
    method public String getRequestMethod();
    method public int getResponseCode() throws java.io.IOException;
    method public String getResponseMessage() throws java.io.IOException;
    method public void setChunkedStreamingMode(int);
    method public void setFixedLengthStreamingMode(int);
    method public void setFixedLengthStreamingMode(long);
    method public static void setFollowRedirects(boolean);
    method public void setInstanceFollowRedirects(boolean);
    method public void setRequestMethod(String) throws java.net.ProtocolException;
    method public abstract boolean usingProxy();
    field public static final int HTTP_ACCEPTED = 202; // 0xca
    field public static final int HTTP_BAD_GATEWAY = 502; // 0x1f6
    field public static final int HTTP_BAD_METHOD = 405; // 0x195
    field public static final int HTTP_BAD_REQUEST = 400; // 0x190
    field public static final int HTTP_CLIENT_TIMEOUT = 408; // 0x198
    field public static final int HTTP_CONFLICT = 409; // 0x199
    field public static final int HTTP_CREATED = 201; // 0xc9
    field public static final int HTTP_ENTITY_TOO_LARGE = 413; // 0x19d
    field public static final int HTTP_FORBIDDEN = 403; // 0x193
    field public static final int HTTP_GATEWAY_TIMEOUT = 504; // 0x1f8
    field public static final int HTTP_GONE = 410; // 0x19a
    field public static final int HTTP_INTERNAL_ERROR = 500; // 0x1f4
    field public static final int HTTP_LENGTH_REQUIRED = 411; // 0x19b
    field public static final int HTTP_MOVED_PERM = 301; // 0x12d
    field public static final int HTTP_MOVED_TEMP = 302; // 0x12e
    field public static final int HTTP_MULT_CHOICE = 300; // 0x12c
    field public static final int HTTP_NOT_ACCEPTABLE = 406; // 0x196
    field public static final int HTTP_NOT_AUTHORITATIVE = 203; // 0xcb
    field public static final int HTTP_NOT_FOUND = 404; // 0x194
    field public static final int HTTP_NOT_IMPLEMENTED = 501; // 0x1f5
    field public static final int HTTP_NOT_MODIFIED = 304; // 0x130
    field public static final int HTTP_NO_CONTENT = 204; // 0xcc
    field public static final int HTTP_OK = 200; // 0xc8
    field public static final int HTTP_PARTIAL = 206; // 0xce
    field public static final int HTTP_PAYMENT_REQUIRED = 402; // 0x192
    field public static final int HTTP_PRECON_FAILED = 412; // 0x19c
    field public static final int HTTP_PROXY_AUTH = 407; // 0x197
    field public static final int HTTP_REQ_TOO_LONG = 414; // 0x19e
    field public static final int HTTP_RESET = 205; // 0xcd
    field public static final int HTTP_SEE_OTHER = 303; // 0x12f
    field @Deprecated public static final int HTTP_SERVER_ERROR = 500; // 0x1f4
    field public static final int HTTP_UNAUTHORIZED = 401; // 0x191
    field public static final int HTTP_UNAVAILABLE = 503; // 0x1f7
    field public static final int HTTP_UNSUPPORTED_TYPE = 415; // 0x19f
    field public static final int HTTP_USE_PROXY = 305; // 0x131
    field public static final int HTTP_VERSION = 505; // 0x1f9
    field protected int chunkLength;
    field protected int fixedContentLength;
    field protected long fixedContentLengthLong;
    field protected boolean instanceFollowRedirects;
    field protected String method;
    field protected int responseCode;
    field protected String responseMessage;
  }

  public final class IDN {
    method public static String toASCII(String, int);
    method public static String toASCII(String);
    method public static String toUnicode(String, int);
    method public static String toUnicode(String);
    field public static final int ALLOW_UNASSIGNED = 1; // 0x1
    field public static final int USE_STD3_ASCII_RULES = 2; // 0x2
  }

  public final class Inet4Address extends java.net.InetAddress {
  }

  public final class Inet6Address extends java.net.InetAddress {
    method public static java.net.Inet6Address getByAddress(String, byte[], java.net.NetworkInterface) throws java.net.UnknownHostException;
    method public static java.net.Inet6Address getByAddress(String, byte[], int) throws java.net.UnknownHostException;
    method public int getScopeId();
    method public java.net.NetworkInterface getScopedInterface();
    method public boolean isIPv4CompatibleAddress();
  }

  public class InetAddress implements java.io.Serializable {
    method public byte[] getAddress();
    method public static java.net.InetAddress[] getAllByName(@Nullable String) throws java.net.UnknownHostException;
    method @NonNull public static java.net.InetAddress getByAddress(@Nullable String, byte[]) throws java.net.UnknownHostException;
    method @NonNull public static java.net.InetAddress getByAddress(byte[]) throws java.net.UnknownHostException;
    method @NonNull public static java.net.InetAddress getByName(@Nullable String) throws java.net.UnknownHostException;
    method @NonNull public String getCanonicalHostName();
    method @Nullable public String getHostAddress();
    method @NonNull public String getHostName();
    method @NonNull public static java.net.InetAddress getLocalHost() throws java.net.UnknownHostException;
    method @NonNull public static java.net.InetAddress getLoopbackAddress();
    method public boolean isAnyLocalAddress();
    method public boolean isLinkLocalAddress();
    method public boolean isLoopbackAddress();
    method public boolean isMCGlobal();
    method public boolean isMCLinkLocal();
    method public boolean isMCNodeLocal();
    method public boolean isMCOrgLocal();
    method public boolean isMCSiteLocal();
    method public boolean isMulticastAddress();
    method public boolean isReachable(int) throws java.io.IOException;
    method public boolean isReachable(@Nullable java.net.NetworkInterface, int, int) throws java.io.IOException;
    method public boolean isSiteLocalAddress();
  }

  public class InetSocketAddress extends java.net.SocketAddress {
    ctor public InetSocketAddress(int);
    ctor public InetSocketAddress(java.net.InetAddress, int);
    ctor public InetSocketAddress(String, int);
    method public static java.net.InetSocketAddress createUnresolved(String, int);
    method public final boolean equals(Object);
    method public final java.net.InetAddress getAddress();
    method public final String getHostName();
    method public final String getHostString();
    method public final int getPort();
    method public final int hashCode();
    method public final boolean isUnresolved();
  }

  public class InterfaceAddress {
    method public java.net.InetAddress getAddress();
    method public java.net.InetAddress getBroadcast();
    method public short getNetworkPrefixLength();
  }

  public abstract class JarURLConnection extends java.net.URLConnection {
    ctor protected JarURLConnection(java.net.URL) throws java.net.MalformedURLException;
    method public java.util.jar.Attributes getAttributes() throws java.io.IOException;
    method public java.security.cert.Certificate[] getCertificates() throws java.io.IOException;
    method public String getEntryName();
    method public java.util.jar.JarEntry getJarEntry() throws java.io.IOException;
    method public abstract java.util.jar.JarFile getJarFile() throws java.io.IOException;
    method public java.net.URL getJarFileURL();
    method public java.util.jar.Attributes getMainAttributes() throws java.io.IOException;
    method public java.util.jar.Manifest getManifest() throws java.io.IOException;
    field protected java.net.URLConnection jarFileURLConnection;
  }

  public class MalformedURLException extends java.io.IOException {
    ctor public MalformedURLException();
    ctor public MalformedURLException(String);
  }

  public class MulticastSocket extends java.net.DatagramSocket {
    ctor public MulticastSocket() throws java.io.IOException;
    ctor public MulticastSocket(int) throws java.io.IOException;
    ctor public MulticastSocket(java.net.SocketAddress) throws java.io.IOException;
    method public java.net.InetAddress getInterface() throws java.net.SocketException;
    method public boolean getLoopbackMode() throws java.net.SocketException;
    method public java.net.NetworkInterface getNetworkInterface() throws java.net.SocketException;
    method @Deprecated public byte getTTL() throws java.io.IOException;
    method public int getTimeToLive() throws java.io.IOException;
    method public void joinGroup(java.net.InetAddress) throws java.io.IOException;
    method public void joinGroup(java.net.SocketAddress, java.net.NetworkInterface) throws java.io.IOException;
    method public void leaveGroup(java.net.InetAddress) throws java.io.IOException;
    method public void leaveGroup(java.net.SocketAddress, java.net.NetworkInterface) throws java.io.IOException;
    method @Deprecated public void send(java.net.DatagramPacket, byte) throws java.io.IOException;
    method public void setInterface(java.net.InetAddress) throws java.net.SocketException;
    method public void setLoopbackMode(boolean) throws java.net.SocketException;
    method public void setNetworkInterface(java.net.NetworkInterface) throws java.net.SocketException;
    method @Deprecated public void setTTL(byte) throws java.io.IOException;
    method public void setTimeToLive(int) throws java.io.IOException;
  }

  public final class NetPermission extends java.security.BasicPermission {
    ctor public NetPermission(String);
    ctor public NetPermission(String, String);
  }

  public final class NetworkInterface {
    method public static java.net.NetworkInterface getByIndex(int) throws java.net.SocketException;
    method public static java.net.NetworkInterface getByInetAddress(java.net.InetAddress) throws java.net.SocketException;
    method public static java.net.NetworkInterface getByName(String) throws java.net.SocketException;
    method public String getDisplayName();
    method public byte[] getHardwareAddress() throws java.net.SocketException;
    method public int getIndex();
    method public java.util.Enumeration<java.net.InetAddress> getInetAddresses();
    method public java.util.List<java.net.InterfaceAddress> getInterfaceAddresses();
    method public int getMTU() throws java.net.SocketException;
    method public String getName();
    method public static java.util.Enumeration<java.net.NetworkInterface> getNetworkInterfaces() throws java.net.SocketException;
    method public java.net.NetworkInterface getParent();
    method public java.util.Enumeration<java.net.NetworkInterface> getSubInterfaces();
    method public boolean isLoopback() throws java.net.SocketException;
    method public boolean isPointToPoint() throws java.net.SocketException;
    method public boolean isUp() throws java.net.SocketException;
    method public boolean isVirtual();
    method public boolean supportsMulticast() throws java.net.SocketException;
  }

  public class NoRouteToHostException extends java.net.SocketException {
    ctor public NoRouteToHostException(String);
    ctor public NoRouteToHostException();
  }

  public final class PasswordAuthentication {
    ctor public PasswordAuthentication(String, char[]);
    method public char[] getPassword();
    method public String getUserName();
  }

  public class PortUnreachableException extends java.net.SocketException {
    ctor public PortUnreachableException(String);
    ctor public PortUnreachableException();
  }

  public class ProtocolException extends java.io.IOException {
    ctor public ProtocolException(String);
    ctor public ProtocolException();
  }

  public interface ProtocolFamily {
    method public String name();
  }

  public class Proxy {
    ctor public Proxy(java.net.Proxy.Type, java.net.SocketAddress);
    method public java.net.SocketAddress address();
    method public final boolean equals(Object);
    method public final int hashCode();
    method public java.net.Proxy.Type type();
    field public static final java.net.Proxy NO_PROXY;
  }

  public enum Proxy.Type {
    enum_constant public static final java.net.Proxy.Type DIRECT;
    enum_constant public static final java.net.Proxy.Type HTTP;
    enum_constant public static final java.net.Proxy.Type SOCKS;
  }

  public abstract class ProxySelector {
    ctor public ProxySelector();
    method public abstract void connectFailed(java.net.URI, java.net.SocketAddress, java.io.IOException);
    method public static java.net.ProxySelector getDefault();
    method public abstract java.util.List<java.net.Proxy> select(java.net.URI);
    method public static void setDefault(java.net.ProxySelector);
  }

  public abstract class ResponseCache {
    ctor public ResponseCache();
    method public abstract java.net.CacheResponse get(java.net.URI, String, java.util.Map<java.lang.String,java.util.List<java.lang.String>>) throws java.io.IOException;
    method public static java.net.ResponseCache getDefault();
    method public abstract java.net.CacheRequest put(java.net.URI, java.net.URLConnection) throws java.io.IOException;
    method public static void setDefault(java.net.ResponseCache);
  }

  public abstract class SecureCacheResponse extends java.net.CacheResponse {
    ctor public SecureCacheResponse();
    method public abstract String getCipherSuite();
    method public abstract java.util.List<java.security.cert.Certificate> getLocalCertificateChain();
    method public abstract java.security.Principal getLocalPrincipal();
    method public abstract java.security.Principal getPeerPrincipal() throws javax.net.ssl.SSLPeerUnverifiedException;
    method public abstract java.util.List<java.security.cert.Certificate> getServerCertificateChain() throws javax.net.ssl.SSLPeerUnverifiedException;
  }

  public class ServerSocket implements java.io.Closeable {
    ctor public ServerSocket() throws java.io.IOException;
    ctor public ServerSocket(int) throws java.io.IOException;
    ctor public ServerSocket(int, int) throws java.io.IOException;
    ctor public ServerSocket(int, int, java.net.InetAddress) throws java.io.IOException;
    method public java.net.Socket accept() throws java.io.IOException;
    method public void bind(java.net.SocketAddress) throws java.io.IOException;
    method public void bind(java.net.SocketAddress, int) throws java.io.IOException;
    method public void close() throws java.io.IOException;
    method public java.nio.channels.ServerSocketChannel getChannel();
    method public java.net.InetAddress getInetAddress();
    method public int getLocalPort();
    method public java.net.SocketAddress getLocalSocketAddress();
    method public <T> T getOption(java.net.SocketOption<T>) throws java.io.IOException;
    method public int getReceiveBufferSize() throws java.net.SocketException;
    method public boolean getReuseAddress() throws java.net.SocketException;
    method public int getSoTimeout() throws java.io.IOException;
    method protected final void implAccept(java.net.Socket) throws java.io.IOException;
    method public boolean isBound();
    method public boolean isClosed();
    method public <T> java.net.ServerSocket setOption(java.net.SocketOption<T>, T) throws java.io.IOException;
    method public void setPerformancePreferences(int, int, int);
    method public void setReceiveBufferSize(int) throws java.net.SocketException;
    method public void setReuseAddress(boolean) throws java.net.SocketException;
    method public void setSoTimeout(int) throws java.net.SocketException;
    method public static void setSocketFactory(java.net.SocketImplFactory) throws java.io.IOException;
    method public java.util.Set<java.net.SocketOption<?>> supportedOptions();
  }

  public class Socket implements java.io.Closeable {
    ctor public Socket();
    ctor public Socket(java.net.Proxy);
    ctor protected Socket(java.net.SocketImpl) throws java.net.SocketException;
    ctor public Socket(String, int) throws java.io.IOException, java.net.UnknownHostException;
    ctor public Socket(java.net.InetAddress, int) throws java.io.IOException;
    ctor public Socket(String, int, java.net.InetAddress, int) throws java.io.IOException;
    ctor public Socket(java.net.InetAddress, int, java.net.InetAddress, int) throws java.io.IOException;
    ctor @Deprecated public Socket(String, int, boolean) throws java.io.IOException;
    ctor @Deprecated public Socket(java.net.InetAddress, int, boolean) throws java.io.IOException;
    method public void bind(java.net.SocketAddress) throws java.io.IOException;
    method public void close() throws java.io.IOException;
    method public void connect(java.net.SocketAddress) throws java.io.IOException;
    method public void connect(java.net.SocketAddress, int) throws java.io.IOException;
    method public java.nio.channels.SocketChannel getChannel();
    method public java.net.InetAddress getInetAddress();
    method public java.io.InputStream getInputStream() throws java.io.IOException;
    method public boolean getKeepAlive() throws java.net.SocketException;
    method public java.net.InetAddress getLocalAddress();
    method public int getLocalPort();
    method public java.net.SocketAddress getLocalSocketAddress();
    method public boolean getOOBInline() throws java.net.SocketException;
    method public <T> T getOption(java.net.SocketOption<T>) throws java.io.IOException;
    method public java.io.OutputStream getOutputStream() throws java.io.IOException;
    method public int getPort();
    method public int getReceiveBufferSize() throws java.net.SocketException;
    method public java.net.SocketAddress getRemoteSocketAddress();
    method public boolean getReuseAddress() throws java.net.SocketException;
    method public int getSendBufferSize() throws java.net.SocketException;
    method public int getSoLinger() throws java.net.SocketException;
    method public int getSoTimeout() throws java.net.SocketException;
    method public boolean getTcpNoDelay() throws java.net.SocketException;
    method public int getTrafficClass() throws java.net.SocketException;
    method public boolean isBound();
    method public boolean isClosed();
    method public boolean isConnected();
    method public boolean isInputShutdown();
    method public boolean isOutputShutdown();
    method public void sendUrgentData(int) throws java.io.IOException;
    method public void setKeepAlive(boolean) throws java.net.SocketException;
    method public void setOOBInline(boolean) throws java.net.SocketException;
    method public <T> java.net.Socket setOption(java.net.SocketOption<T>, T) throws java.io.IOException;
    method public void setPerformancePreferences(int, int, int);
    method public void setReceiveBufferSize(int) throws java.net.SocketException;
    method public void setReuseAddress(boolean) throws java.net.SocketException;
    method public void setSendBufferSize(int) throws java.net.SocketException;
    method public void setSoLinger(boolean, int) throws java.net.SocketException;
    method public void setSoTimeout(int) throws java.net.SocketException;
    method public static void setSocketImplFactory(java.net.SocketImplFactory) throws java.io.IOException;
    method public void setTcpNoDelay(boolean) throws java.net.SocketException;
    method public void setTrafficClass(int) throws java.net.SocketException;
    method public void shutdownInput() throws java.io.IOException;
    method public void shutdownOutput() throws java.io.IOException;
    method public java.util.Set<java.net.SocketOption<?>> supportedOptions();
  }

  public abstract class SocketAddress implements java.io.Serializable {
    ctor public SocketAddress();
  }

  public class SocketException extends java.io.IOException {
    ctor public SocketException(String);
    ctor public SocketException();
  }

  public abstract class SocketImpl implements java.net.SocketOptions {
    ctor public SocketImpl();
    method protected abstract void accept(java.net.SocketImpl) throws java.io.IOException;
    method protected abstract int available() throws java.io.IOException;
    method protected abstract void bind(java.net.InetAddress, int) throws java.io.IOException;
    method protected abstract void close() throws java.io.IOException;
    method protected abstract void connect(String, int) throws java.io.IOException;
    method protected abstract void connect(java.net.InetAddress, int) throws java.io.IOException;
    method protected abstract void connect(java.net.SocketAddress, int) throws java.io.IOException;
    method protected abstract void create(boolean) throws java.io.IOException;
    method protected java.io.FileDescriptor getFileDescriptor();
    method protected java.net.InetAddress getInetAddress();
    method protected abstract java.io.InputStream getInputStream() throws java.io.IOException;
    method protected int getLocalPort();
    method protected <T> T getOption(java.net.SocketOption<T>) throws java.io.IOException;
    method protected abstract java.io.OutputStream getOutputStream() throws java.io.IOException;
    method protected int getPort();
    method protected abstract void listen(int) throws java.io.IOException;
    method protected abstract void sendUrgentData(int) throws java.io.IOException;
    method protected <T> void setOption(java.net.SocketOption<T>, T) throws java.io.IOException;
    method protected void setPerformancePreferences(int, int, int);
    method protected void shutdownInput() throws java.io.IOException;
    method protected void shutdownOutput() throws java.io.IOException;
    method protected java.util.Set<java.net.SocketOption<?>> supportedOptions();
    method protected boolean supportsUrgentData();
    field protected java.net.InetAddress address;
    field protected java.io.FileDescriptor fd;
    field protected int localport;
    field protected int port;
  }

  public interface SocketImplFactory {
    method public java.net.SocketImpl createSocketImpl();
  }

  public interface SocketOption<T> {
    method public String name();
    method public Class<T> type();
  }

  public interface SocketOptions {
    method public Object getOption(int) throws java.net.SocketException;
    method public void setOption(int, Object) throws java.net.SocketException;
    field public static final int IP_MULTICAST_IF = 16; // 0x10
    field public static final int IP_MULTICAST_IF2 = 31; // 0x1f
    field public static final int IP_MULTICAST_LOOP = 18; // 0x12
    field public static final int IP_TOS = 3; // 0x3
    field public static final int SO_BINDADDR = 15; // 0xf
    field public static final int SO_BROADCAST = 32; // 0x20
    field public static final int SO_KEEPALIVE = 8; // 0x8
    field public static final int SO_LINGER = 128; // 0x80
    field public static final int SO_OOBINLINE = 4099; // 0x1003
    field public static final int SO_RCVBUF = 4098; // 0x1002
    field public static final int SO_REUSEADDR = 4; // 0x4
    field public static final int SO_REUSEPORT = 14; // 0xe
    field public static final int SO_SNDBUF = 4097; // 0x1001
    field public static final int SO_TIMEOUT = 4102; // 0x1006
    field public static final int TCP_NODELAY = 1; // 0x1
  }

  public final class SocketPermission extends java.security.Permission implements java.io.Serializable {
    ctor public SocketPermission(String, String);
    method public String getActions();
    method public boolean implies(java.security.Permission);
  }

  public class SocketTimeoutException extends java.io.InterruptedIOException {
    ctor public SocketTimeoutException(String);
    ctor public SocketTimeoutException();
  }

  public enum StandardProtocolFamily implements java.net.ProtocolFamily {
    enum_constant public static final java.net.StandardProtocolFamily INET;
    enum_constant public static final java.net.StandardProtocolFamily INET6;
    enum_constant public static final java.net.StandardProtocolFamily UNIX;
  }

  public final class StandardSocketOptions {
    field public static final java.net.SocketOption<java.net.NetworkInterface> IP_MULTICAST_IF;
    field public static final java.net.SocketOption<java.lang.Boolean> IP_MULTICAST_LOOP;
    field public static final java.net.SocketOption<java.lang.Integer> IP_MULTICAST_TTL;
    field public static final java.net.SocketOption<java.lang.Integer> IP_TOS;
    field public static final java.net.SocketOption<java.lang.Boolean> SO_BROADCAST;
    field public static final java.net.SocketOption<java.lang.Boolean> SO_KEEPALIVE;
    field public static final java.net.SocketOption<java.lang.Integer> SO_LINGER;
    field public static final java.net.SocketOption<java.lang.Integer> SO_RCVBUF;
    field public static final java.net.SocketOption<java.lang.Boolean> SO_REUSEADDR;
    field public static final java.net.SocketOption<java.lang.Boolean> SO_REUSEPORT;
    field public static final java.net.SocketOption<java.lang.Integer> SO_SNDBUF;
    field public static final java.net.SocketOption<java.lang.Boolean> TCP_NODELAY;
  }

  public final class URI implements java.lang.Comparable<java.net.URI> java.io.Serializable {
    ctor public URI(String) throws java.net.URISyntaxException;
    ctor public URI(String, String, String, int, String, String, String) throws java.net.URISyntaxException;
    ctor public URI(String, String, String, String, String) throws java.net.URISyntaxException;
    ctor public URI(String, String, String, String) throws java.net.URISyntaxException;
    ctor public URI(String, String, String) throws java.net.URISyntaxException;
    method public int compareTo(java.net.URI);
    method public static java.net.URI create(String);
    method public String getAuthority();
    method public String getFragment();
    method public String getHost();
    method public String getPath();
    method public int getPort();
    method public String getQuery();
    method public String getRawAuthority();
    method public String getRawFragment();
    method public String getRawPath();
    method public String getRawQuery();
    method public String getRawSchemeSpecificPart();
    method public String getRawUserInfo();
    method public String getScheme();
    method public String getSchemeSpecificPart();
    method public String getUserInfo();
    method public boolean isAbsolute();
    method public boolean isOpaque();
    method public java.net.URI normalize();
    method public java.net.URI parseServerAuthority() throws java.net.URISyntaxException;
    method public java.net.URI relativize(java.net.URI);
    method public java.net.URI resolve(java.net.URI);
    method public java.net.URI resolve(String);
    method public String toASCIIString();
    method public java.net.URL toURL() throws java.net.MalformedURLException;
  }

  public class URISyntaxException extends java.lang.Exception {
    ctor public URISyntaxException(String, String, int);
    ctor public URISyntaxException(String, String);
    method public int getIndex();
    method public String getInput();
    method public String getReason();
  }

  public final class URL implements java.io.Serializable {
    ctor public URL(String, String, int, String) throws java.net.MalformedURLException;
    ctor public URL(String, String, String) throws java.net.MalformedURLException;
    ctor public URL(String, String, int, String, java.net.URLStreamHandler) throws java.net.MalformedURLException;
    ctor public URL(String) throws java.net.MalformedURLException;
    ctor public URL(java.net.URL, String) throws java.net.MalformedURLException;
    ctor public URL(java.net.URL, String, java.net.URLStreamHandler) throws java.net.MalformedURLException;
    method public String getAuthority();
    method public Object getContent() throws java.io.IOException;
    method public Object getContent(Class[]) throws java.io.IOException;
    method public int getDefaultPort();
    method public String getFile();
    method public String getHost();
    method public String getPath();
    method public int getPort();
    method public String getProtocol();
    method public String getQuery();
    method public String getRef();
    method public String getUserInfo();
    method public java.net.URLConnection openConnection() throws java.io.IOException;
    method public java.net.URLConnection openConnection(java.net.Proxy) throws java.io.IOException;
    method public java.io.InputStream openStream() throws java.io.IOException;
    method public boolean sameFile(java.net.URL);
    method public static void setURLStreamHandlerFactory(java.net.URLStreamHandlerFactory);
    method public String toExternalForm();
    method public java.net.URI toURI() throws java.net.URISyntaxException;
  }

  public class URLClassLoader extends java.security.SecureClassLoader implements java.io.Closeable {
    ctor public URLClassLoader(java.net.URL[], ClassLoader);
    ctor public URLClassLoader(java.net.URL[]);
    ctor public URLClassLoader(java.net.URL[], ClassLoader, java.net.URLStreamHandlerFactory);
    method protected void addURL(java.net.URL);
    method public void close() throws java.io.IOException;
    method protected Package definePackage(String, java.util.jar.Manifest, java.net.URL) throws java.lang.IllegalArgumentException;
    method public java.net.URL findResource(String);
    method public java.util.Enumeration<java.net.URL> findResources(String) throws java.io.IOException;
    method public java.net.URL[] getURLs();
    method public static java.net.URLClassLoader newInstance(java.net.URL[], ClassLoader);
    method public static java.net.URLClassLoader newInstance(java.net.URL[]);
  }

  public abstract class URLConnection {
    ctor protected URLConnection(java.net.URL);
    method public void addRequestProperty(String, String);
    method public abstract void connect() throws java.io.IOException;
    method public boolean getAllowUserInteraction();
    method public int getConnectTimeout();
    method public Object getContent() throws java.io.IOException;
    method public Object getContent(Class[]) throws java.io.IOException;
    method public String getContentEncoding();
    method public int getContentLength();
    method public long getContentLengthLong();
    method public String getContentType();
    method public long getDate();
    method public static boolean getDefaultAllowUserInteraction();
    method @Deprecated public static String getDefaultRequestProperty(String);
    method public boolean getDefaultUseCaches();
    method public boolean getDoInput();
    method public boolean getDoOutput();
    method public long getExpiration();
    method public static java.net.FileNameMap getFileNameMap();
    method public String getHeaderField(String);
    method public String getHeaderField(int);
    method public long getHeaderFieldDate(String, long);
    method public int getHeaderFieldInt(String, int);
    method public String getHeaderFieldKey(int);
    method public long getHeaderFieldLong(String, long);
    method public java.util.Map<java.lang.String,java.util.List<java.lang.String>> getHeaderFields();
    method public long getIfModifiedSince();
    method public java.io.InputStream getInputStream() throws java.io.IOException;
    method public long getLastModified();
    method public java.io.OutputStream getOutputStream() throws java.io.IOException;
    method public java.security.Permission getPermission() throws java.io.IOException;
    method public int getReadTimeout();
    method public java.util.Map<java.lang.String,java.util.List<java.lang.String>> getRequestProperties();
    method public String getRequestProperty(String);
    method public java.net.URL getURL();
    method public boolean getUseCaches();
    method public static String guessContentTypeFromName(String);
    method public static String guessContentTypeFromStream(java.io.InputStream) throws java.io.IOException;
    method public void setAllowUserInteraction(boolean);
    method public void setConnectTimeout(int);
    method public static void setContentHandlerFactory(java.net.ContentHandlerFactory);
    method public static void setDefaultAllowUserInteraction(boolean);
    method @Deprecated public static void setDefaultRequestProperty(String, String);
    method public void setDefaultUseCaches(boolean);
    method public void setDoInput(boolean);
    method public void setDoOutput(boolean);
    method public static void setFileNameMap(java.net.FileNameMap);
    method public void setIfModifiedSince(long);
    method public void setReadTimeout(int);
    method public void setRequestProperty(String, String);
    method public void setUseCaches(boolean);
    field protected boolean allowUserInteraction;
    field protected boolean connected;
    field protected boolean doInput;
    field protected boolean doOutput;
    field protected long ifModifiedSince;
    field protected java.net.URL url;
    field protected boolean useCaches;
  }

  public class URLDecoder {
    ctor public URLDecoder();
    method @Deprecated public static String decode(String);
    method public static String decode(String, String) throws java.io.UnsupportedEncodingException;
    method public static String decode(String, java.nio.charset.Charset);
  }

  public class URLEncoder {
    method @Deprecated public static String encode(String);
    method public static String encode(String, String) throws java.io.UnsupportedEncodingException;
    method public static String encode(String, java.nio.charset.Charset);
  }

  public abstract class URLStreamHandler {
    ctor public URLStreamHandler();
    method protected boolean equals(java.net.URL, java.net.URL);
    method protected int getDefaultPort();
    method protected java.net.InetAddress getHostAddress(java.net.URL);
    method protected int hashCode(java.net.URL);
    method protected boolean hostsEqual(java.net.URL, java.net.URL);
    method protected abstract java.net.URLConnection openConnection(java.net.URL) throws java.io.IOException;
    method protected java.net.URLConnection openConnection(java.net.URL, java.net.Proxy) throws java.io.IOException;
    method protected void parseURL(java.net.URL, String, int, int);
    method protected boolean sameFile(java.net.URL, java.net.URL);
    method protected void setURL(java.net.URL, String, String, int, String, String, String, String, String);
    method @Deprecated protected void setURL(java.net.URL, String, String, int, String, String);
    method protected String toExternalForm(java.net.URL);
  }

  public interface URLStreamHandlerFactory {
    method public java.net.URLStreamHandler createURLStreamHandler(String);
  }

  public class UnknownHostException extends java.io.IOException {
    ctor public UnknownHostException(String);
    ctor public UnknownHostException();
  }

  public class UnknownServiceException extends java.io.IOException {
    ctor public UnknownServiceException();
    ctor public UnknownServiceException(String);
  }

}

package java.nio {

  public abstract class Buffer {
    method public abstract Object array();
    method public abstract int arrayOffset();
    method public final int capacity();
    method public java.nio.Buffer clear();
    method public abstract java.nio.Buffer duplicate();
    method public java.nio.Buffer flip();
    method public abstract boolean hasArray();
    method public final boolean hasRemaining();
    method public abstract boolean isDirect();
    method public abstract boolean isReadOnly();
    method public final int limit();
    method public java.nio.Buffer limit(int);
    method public java.nio.Buffer mark();
    method public final int position();
    method public java.nio.Buffer position(int);
    method public final int remaining();
    method public java.nio.Buffer reset();
    method public java.nio.Buffer rewind();
    method public abstract java.nio.Buffer slice();
    method public abstract java.nio.Buffer slice(int, int);
  }

  public class BufferOverflowException extends java.lang.RuntimeException {
    ctor public BufferOverflowException();
  }

  public class BufferUnderflowException extends java.lang.RuntimeException {
    ctor public BufferUnderflowException();
  }

  public abstract class ByteBuffer extends java.nio.Buffer implements java.lang.Comparable<java.nio.ByteBuffer> {
    method @NonNull public final java.nio.ByteBuffer alignedSlice(int);
    method public final int alignmentOffset(int, int);
    method @NonNull public static java.nio.ByteBuffer allocate(int);
    method @NonNull public static java.nio.ByteBuffer allocateDirect(int);
    method @NonNull public final byte[] array();
    method public final int arrayOffset();
    method @NonNull public abstract java.nio.CharBuffer asCharBuffer();
    method @NonNull public abstract java.nio.DoubleBuffer asDoubleBuffer();
    method @NonNull public abstract java.nio.FloatBuffer asFloatBuffer();
    method @NonNull public abstract java.nio.IntBuffer asIntBuffer();
    method @NonNull public abstract java.nio.LongBuffer asLongBuffer();
    method @NonNull public abstract java.nio.ByteBuffer asReadOnlyBuffer();
    method @NonNull public abstract java.nio.ShortBuffer asShortBuffer();
    method @NonNull public abstract java.nio.ByteBuffer compact();
    method public int compareTo(@NonNull java.nio.ByteBuffer);
    method @NonNull public abstract java.nio.ByteBuffer duplicate();
    method public abstract byte get();
    method public abstract byte get(int);
    method @NonNull public java.nio.ByteBuffer get(@NonNull byte[], int, int);
    method @NonNull public java.nio.ByteBuffer get(@NonNull byte[]);
    method @FlaggedApi("com.android.libcore.v_apis") @NonNull public java.nio.ByteBuffer get(int, @NonNull byte[], int, int);
    method @FlaggedApi("com.android.libcore.v_apis") @NonNull public java.nio.ByteBuffer get(int, @NonNull byte[]);
    method public abstract char getChar();
    method public abstract char getChar(int);
    method public abstract double getDouble();
    method public abstract double getDouble(int);
    method public abstract float getFloat();
    method public abstract float getFloat(int);
    method public abstract int getInt();
    method public abstract int getInt(int);
    method public abstract long getLong();
    method public abstract long getLong(int);
    method public abstract short getShort();
    method public abstract short getShort(int);
    method public final boolean hasArray();
    method public int mismatch(@NonNull java.nio.ByteBuffer);
    method @NonNull public final java.nio.ByteOrder order();
    method @NonNull public final java.nio.ByteBuffer order(@NonNull java.nio.ByteOrder);
    method @NonNull public abstract java.nio.ByteBuffer put(byte);
    method @NonNull public abstract java.nio.ByteBuffer put(int, byte);
    method @NonNull public java.nio.ByteBuffer put(@NonNull java.nio.ByteBuffer);
    method @FlaggedApi("com.android.libcore.v_apis") @NonNull public java.nio.ByteBuffer put(int, @NonNull java.nio.ByteBuffer, int, int);
    method @NonNull public java.nio.ByteBuffer put(@NonNull byte[], int, int);
    method @NonNull public final java.nio.ByteBuffer put(@NonNull byte[]);
    method @FlaggedApi("com.android.libcore.v_apis") @NonNull public java.nio.ByteBuffer put(int, @NonNull byte[], int, int);
    method @FlaggedApi("com.android.libcore.v_apis") @NonNull public java.nio.ByteBuffer put(int, @NonNull byte[]);
    method @NonNull public abstract java.nio.ByteBuffer putChar(char);
    method @NonNull public abstract java.nio.ByteBuffer putChar(int, char);
    method @NonNull public abstract java.nio.ByteBuffer putDouble(double);
    method @NonNull public abstract java.nio.ByteBuffer putDouble(int, double);
    method @NonNull public abstract java.nio.ByteBuffer putFloat(float);
    method @NonNull public abstract java.nio.ByteBuffer putFloat(int, float);
    method @NonNull public abstract java.nio.ByteBuffer putInt(int);
    method @NonNull public abstract java.nio.ByteBuffer putInt(int, int);
    method @NonNull public abstract java.nio.ByteBuffer putLong(long);
    method @NonNull public abstract java.nio.ByteBuffer putLong(int, long);
    method @NonNull public abstract java.nio.ByteBuffer putShort(short);
    method @NonNull public abstract java.nio.ByteBuffer putShort(int, short);
    method @NonNull public abstract java.nio.ByteBuffer slice();
    method @NonNull public abstract java.nio.ByteBuffer slice(int, int);
    method @NonNull public static java.nio.ByteBuffer wrap(@NonNull byte[], int, int);
    method @NonNull public static java.nio.ByteBuffer wrap(@NonNull byte[]);
  }

  public final class ByteOrder {
    method public static java.nio.ByteOrder nativeOrder();
    field public static final java.nio.ByteOrder BIG_ENDIAN;
    field public static final java.nio.ByteOrder LITTLE_ENDIAN;
  }

  public abstract class CharBuffer extends java.nio.Buffer implements java.lang.Appendable java.lang.CharSequence java.lang.Comparable<java.nio.CharBuffer> java.lang.Readable {
    method public static java.nio.CharBuffer allocate(int);
    method public java.nio.CharBuffer append(CharSequence);
    method public java.nio.CharBuffer append(CharSequence, int, int);
    method public java.nio.CharBuffer append(char);
    method public final char[] array();
    method public final int arrayOffset();
    method public abstract java.nio.CharBuffer asReadOnlyBuffer();
    method public final char charAt(int);
    method public java.util.stream.IntStream chars();
    method public abstract java.nio.CharBuffer compact();
    method public int compareTo(java.nio.CharBuffer);
    method public abstract java.nio.CharBuffer duplicate();
    method public abstract char get();
    method public abstract char get(int);
    method public java.nio.CharBuffer get(char[], int, int);
    method public java.nio.CharBuffer get(char[]);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.CharBuffer get(int, char[], int, int);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.CharBuffer get(int, char[]);
    method public final boolean hasArray();
    method public final boolean isEmpty();
    method public final int length();
    method public int mismatch(java.nio.CharBuffer);
    method public abstract java.nio.ByteOrder order();
    method public abstract java.nio.CharBuffer put(char);
    method public abstract java.nio.CharBuffer put(int, char);
    method public java.nio.CharBuffer put(java.nio.CharBuffer);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.CharBuffer put(int, java.nio.CharBuffer, int, int);
    method public java.nio.CharBuffer put(char[], int, int);
    method public final java.nio.CharBuffer put(char[]);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.CharBuffer put(int, char[], int, int);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.CharBuffer put(int, char[]);
    method public java.nio.CharBuffer put(String, int, int);
    method public final java.nio.CharBuffer put(String);
    method public int read(java.nio.CharBuffer) throws java.io.IOException;
    method public abstract java.nio.CharBuffer slice();
    method public abstract java.nio.CharBuffer slice(int, int);
    method public abstract java.nio.CharBuffer subSequence(int, int);
    method public String toString();
    method public static java.nio.CharBuffer wrap(char[], int, int);
    method public static java.nio.CharBuffer wrap(char[]);
    method public static java.nio.CharBuffer wrap(CharSequence, int, int);
    method public static java.nio.CharBuffer wrap(CharSequence);
  }

  public abstract class DoubleBuffer extends java.nio.Buffer implements java.lang.Comparable<java.nio.DoubleBuffer> {
    method public static java.nio.DoubleBuffer allocate(int);
    method public final double[] array();
    method public final int arrayOffset();
    method public abstract java.nio.DoubleBuffer asReadOnlyBuffer();
    method public abstract java.nio.DoubleBuffer compact();
    method public int compareTo(java.nio.DoubleBuffer);
    method public abstract java.nio.DoubleBuffer duplicate();
    method public abstract double get();
    method public abstract double get(int);
    method public java.nio.DoubleBuffer get(double[], int, int);
    method public java.nio.DoubleBuffer get(double[]);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.DoubleBuffer get(int, double[], int, int);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.DoubleBuffer get(int, double[]);
    method public final boolean hasArray();
    method public int mismatch(java.nio.DoubleBuffer);
    method public abstract java.nio.ByteOrder order();
    method public abstract java.nio.DoubleBuffer put(double);
    method public abstract java.nio.DoubleBuffer put(int, double);
    method public java.nio.DoubleBuffer put(java.nio.DoubleBuffer);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.DoubleBuffer put(int, java.nio.DoubleBuffer, int, int);
    method public java.nio.DoubleBuffer put(double[], int, int);
    method public final java.nio.DoubleBuffer put(double[]);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.DoubleBuffer put(int, double[], int, int);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.DoubleBuffer put(int, double[]);
    method public abstract java.nio.DoubleBuffer slice();
    method public abstract java.nio.DoubleBuffer slice(int, int);
    method public static java.nio.DoubleBuffer wrap(double[], int, int);
    method public static java.nio.DoubleBuffer wrap(double[]);
  }

  public abstract class FloatBuffer extends java.nio.Buffer implements java.lang.Comparable<java.nio.FloatBuffer> {
    method public static java.nio.FloatBuffer allocate(int);
    method public final float[] array();
    method public final int arrayOffset();
    method public abstract java.nio.FloatBuffer asReadOnlyBuffer();
    method public abstract java.nio.FloatBuffer compact();
    method public int compareTo(java.nio.FloatBuffer);
    method public abstract java.nio.FloatBuffer duplicate();
    method public abstract float get();
    method public abstract float get(int);
    method public java.nio.FloatBuffer get(float[], int, int);
    method public java.nio.FloatBuffer get(float[]);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.FloatBuffer get(int, float[], int, int);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.FloatBuffer get(int, float[]);
    method public final boolean hasArray();
    method public int mismatch(java.nio.FloatBuffer);
    method public abstract java.nio.ByteOrder order();
    method public abstract java.nio.FloatBuffer put(float);
    method public abstract java.nio.FloatBuffer put(int, float);
    method public java.nio.FloatBuffer put(java.nio.FloatBuffer);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.FloatBuffer put(int, java.nio.FloatBuffer, int, int);
    method public java.nio.FloatBuffer put(float[], int, int);
    method public final java.nio.FloatBuffer put(float[]);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.FloatBuffer put(int, float[], int, int);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.FloatBuffer put(int, float[]);
    method public abstract java.nio.FloatBuffer slice();
    method public abstract java.nio.FloatBuffer slice(int, int);
    method public static java.nio.FloatBuffer wrap(float[], int, int);
    method public static java.nio.FloatBuffer wrap(float[]);
  }

  public abstract class IntBuffer extends java.nio.Buffer implements java.lang.Comparable<java.nio.IntBuffer> {
    method public static java.nio.IntBuffer allocate(int);
    method public final int[] array();
    method public final int arrayOffset();
    method public abstract java.nio.IntBuffer asReadOnlyBuffer();
    method public abstract java.nio.IntBuffer compact();
    method public int compareTo(java.nio.IntBuffer);
    method public abstract java.nio.IntBuffer duplicate();
    method public abstract int get();
    method public abstract int get(int);
    method public java.nio.IntBuffer get(int[], int, int);
    method public java.nio.IntBuffer get(int[]);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.IntBuffer get(int, int[], int, int);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.IntBuffer get(int, int[]);
    method public final boolean hasArray();
    method public int mismatch(java.nio.IntBuffer);
    method public abstract java.nio.ByteOrder order();
    method public abstract java.nio.IntBuffer put(int);
    method public abstract java.nio.IntBuffer put(int, int);
    method public java.nio.IntBuffer put(java.nio.IntBuffer);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.IntBuffer put(int, java.nio.IntBuffer, int, int);
    method public java.nio.IntBuffer put(int[], int, int);
    method public final java.nio.IntBuffer put(int[]);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.IntBuffer put(int, int[], int, int);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.IntBuffer put(int, int[]);
    method public abstract java.nio.IntBuffer slice();
    method public abstract java.nio.IntBuffer slice(int, int);
    method public static java.nio.IntBuffer wrap(int[], int, int);
    method public static java.nio.IntBuffer wrap(int[]);
  }

  public class InvalidMarkException extends java.lang.IllegalStateException {
    ctor public InvalidMarkException();
  }

  public abstract class LongBuffer extends java.nio.Buffer implements java.lang.Comparable<java.nio.LongBuffer> {
    method public static java.nio.LongBuffer allocate(int);
    method public final long[] array();
    method public final int arrayOffset();
    method public abstract java.nio.LongBuffer asReadOnlyBuffer();
    method public abstract java.nio.LongBuffer compact();
    method public int compareTo(java.nio.LongBuffer);
    method public abstract java.nio.LongBuffer duplicate();
    method public abstract long get();
    method public abstract long get(int);
    method public java.nio.LongBuffer get(long[], int, int);
    method public java.nio.LongBuffer get(long[]);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.LongBuffer get(int, long[], int, int);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.LongBuffer get(int, long[]);
    method public final boolean hasArray();
    method public int mismatch(java.nio.LongBuffer);
    method public abstract java.nio.ByteOrder order();
    method public abstract java.nio.LongBuffer put(long);
    method public abstract java.nio.LongBuffer put(int, long);
    method public java.nio.LongBuffer put(java.nio.LongBuffer);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.LongBuffer put(int, java.nio.LongBuffer, int, int);
    method public java.nio.LongBuffer put(long[], int, int);
    method public final java.nio.LongBuffer put(long[]);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.LongBuffer put(int, long[], int, int);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.LongBuffer put(int, long[]);
    method public abstract java.nio.LongBuffer slice();
    method public abstract java.nio.LongBuffer slice(int, int);
    method public static java.nio.LongBuffer wrap(long[], int, int);
    method public static java.nio.LongBuffer wrap(long[]);
  }

  public abstract class MappedByteBuffer extends java.nio.ByteBuffer {
    method public final java.nio.Buffer clear();
    method public final java.nio.Buffer flip();
    method public final java.nio.MappedByteBuffer force();
    method @FlaggedApi("com.android.libcore.v_apis") public final java.nio.MappedByteBuffer force(int, int);
    method public final boolean isLoaded();
    method public final java.nio.Buffer limit(int);
    method public final java.nio.MappedByteBuffer load();
    method public final java.nio.Buffer mark();
    method public final java.nio.Buffer position(int);
    method public final java.nio.Buffer reset();
    method public final java.nio.Buffer rewind();
    method public abstract java.nio.MappedByteBuffer slice(int, int);
  }

  public class ReadOnlyBufferException extends java.lang.UnsupportedOperationException {
    ctor public ReadOnlyBufferException();
  }

  public abstract class ShortBuffer extends java.nio.Buffer implements java.lang.Comparable<java.nio.ShortBuffer> {
    method public static java.nio.ShortBuffer allocate(int);
    method public final short[] array();
    method public final int arrayOffset();
    method public abstract java.nio.ShortBuffer asReadOnlyBuffer();
    method public abstract java.nio.ShortBuffer compact();
    method public int compareTo(java.nio.ShortBuffer);
    method public abstract java.nio.ShortBuffer duplicate();
    method public abstract short get();
    method public abstract short get(int);
    method public java.nio.ShortBuffer get(short[], int, int);
    method public java.nio.ShortBuffer get(short[]);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.ShortBuffer get(int, short[], int, int);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.ShortBuffer get(int, short[]);
    method public final boolean hasArray();
    method public int mismatch(java.nio.ShortBuffer);
    method public abstract java.nio.ByteOrder order();
    method public abstract java.nio.ShortBuffer put(short);
    method public abstract java.nio.ShortBuffer put(int, short);
    method public java.nio.ShortBuffer put(java.nio.ShortBuffer);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.ShortBuffer put(int, java.nio.ShortBuffer, int, int);
    method public java.nio.ShortBuffer put(short[], int, int);
    method public final java.nio.ShortBuffer put(short[]);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.ShortBuffer put(int, short[], int, int);
    method @FlaggedApi("com.android.libcore.v_apis") public java.nio.ShortBuffer put(int, short[]);
    method public abstract java.nio.ShortBuffer slice();
    method public abstract java.nio.ShortBuffer slice(int, int);
    method public static java.nio.ShortBuffer wrap(short[], int, int);
    method public static java.nio.ShortBuffer wrap(short[]);
  }

}

package java.nio.channels {

  public class AcceptPendingException extends java.lang.IllegalStateException {
    ctor public AcceptPendingException();
  }

  public class AlreadyBoundException extends java.lang.IllegalStateException {
    ctor public AlreadyBoundException();
  }

  public class AlreadyConnectedException extends java.lang.IllegalStateException {
    ctor public AlreadyConnectedException();
  }

  public interface AsynchronousByteChannel extends java.nio.channels.AsynchronousChannel {
    method public <A> void read(java.nio.ByteBuffer, A, java.nio.channels.CompletionHandler<java.lang.Integer,? super A>);
    method public java.util.concurrent.Future<java.lang.Integer> read(java.nio.ByteBuffer);
    method public <A> void write(java.nio.ByteBuffer, A, java.nio.channels.CompletionHandler<java.lang.Integer,? super A>);
    method public java.util.concurrent.Future<java.lang.Integer> write(java.nio.ByteBuffer);
  }

  public interface AsynchronousChannel extends java.nio.channels.Channel {
  }

  public abstract class AsynchronousChannelGroup {
    ctor protected AsynchronousChannelGroup(java.nio.channels.spi.AsynchronousChannelProvider);
    method public abstract boolean awaitTermination(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public abstract boolean isShutdown();
    method public abstract boolean isTerminated();
    method public final java.nio.channels.spi.AsynchronousChannelProvider provider();
    method public abstract void shutdown();
    method public abstract void shutdownNow() throws java.io.IOException;
    method public static java.nio.channels.AsynchronousChannelGroup withCachedThreadPool(java.util.concurrent.ExecutorService, int) throws java.io.IOException;
    method public static java.nio.channels.AsynchronousChannelGroup withFixedThreadPool(int, java.util.concurrent.ThreadFactory) throws java.io.IOException;
    method public static java.nio.channels.AsynchronousChannelGroup withThreadPool(java.util.concurrent.ExecutorService) throws java.io.IOException;
  }

  public class AsynchronousCloseException extends java.nio.channels.ClosedChannelException {
    ctor public AsynchronousCloseException();
  }

  public abstract class AsynchronousFileChannel implements java.nio.channels.AsynchronousChannel {
    ctor protected AsynchronousFileChannel();
    method public abstract void force(boolean) throws java.io.IOException;
    method public abstract <A> void lock(long, long, boolean, A, java.nio.channels.CompletionHandler<java.nio.channels.FileLock,? super A>);
    method public final <A> void lock(A, java.nio.channels.CompletionHandler<java.nio.channels.FileLock,? super A>);
    method public abstract java.util.concurrent.Future<java.nio.channels.FileLock> lock(long, long, boolean);
    method public final java.util.concurrent.Future<java.nio.channels.FileLock> lock();
    method public static java.nio.channels.AsynchronousFileChannel open(java.nio.file.Path, java.util.Set<? extends java.nio.file.OpenOption>, java.util.concurrent.ExecutorService, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public static java.nio.channels.AsynchronousFileChannel open(java.nio.file.Path, java.nio.file.OpenOption...) throws java.io.IOException;
    method public abstract <A> void read(java.nio.ByteBuffer, long, A, java.nio.channels.CompletionHandler<java.lang.Integer,? super A>);
    method public abstract java.util.concurrent.Future<java.lang.Integer> read(java.nio.ByteBuffer, long);
    method public abstract long size() throws java.io.IOException;
    method public abstract java.nio.channels.AsynchronousFileChannel truncate(long) throws java.io.IOException;
    method public abstract java.nio.channels.FileLock tryLock(long, long, boolean) throws java.io.IOException;
    method public final java.nio.channels.FileLock tryLock() throws java.io.IOException;
    method public abstract <A> void write(java.nio.ByteBuffer, long, A, java.nio.channels.CompletionHandler<java.lang.Integer,? super A>);
    method public abstract java.util.concurrent.Future<java.lang.Integer> write(java.nio.ByteBuffer, long);
  }

  public abstract class AsynchronousServerSocketChannel implements java.nio.channels.AsynchronousChannel java.nio.channels.NetworkChannel {
    ctor protected AsynchronousServerSocketChannel(java.nio.channels.spi.AsynchronousChannelProvider);
    method public abstract <A> void accept(A, java.nio.channels.CompletionHandler<java.nio.channels.AsynchronousSocketChannel,? super A>);
    method public abstract java.util.concurrent.Future<java.nio.channels.AsynchronousSocketChannel> accept();
    method public final java.nio.channels.AsynchronousServerSocketChannel bind(java.net.SocketAddress) throws java.io.IOException;
    method public abstract java.nio.channels.AsynchronousServerSocketChannel bind(java.net.SocketAddress, int) throws java.io.IOException;
    method public static java.nio.channels.AsynchronousServerSocketChannel open(java.nio.channels.AsynchronousChannelGroup) throws java.io.IOException;
    method public static java.nio.channels.AsynchronousServerSocketChannel open() throws java.io.IOException;
    method public final java.nio.channels.spi.AsynchronousChannelProvider provider();
    method public abstract <T> java.nio.channels.AsynchronousServerSocketChannel setOption(java.net.SocketOption<T>, T) throws java.io.IOException;
  }

  public abstract class AsynchronousSocketChannel implements java.nio.channels.AsynchronousByteChannel java.nio.channels.NetworkChannel {
    ctor protected AsynchronousSocketChannel(java.nio.channels.spi.AsynchronousChannelProvider);
    method public abstract java.nio.channels.AsynchronousSocketChannel bind(java.net.SocketAddress) throws java.io.IOException;
    method public abstract <A> void connect(java.net.SocketAddress, A, java.nio.channels.CompletionHandler<java.lang.Void,? super A>);
    method public abstract java.util.concurrent.Future<java.lang.Void> connect(java.net.SocketAddress);
    method public abstract java.net.SocketAddress getRemoteAddress() throws java.io.IOException;
    method public static java.nio.channels.AsynchronousSocketChannel open(java.nio.channels.AsynchronousChannelGroup) throws java.io.IOException;
    method public static java.nio.channels.AsynchronousSocketChannel open() throws java.io.IOException;
    method public final java.nio.channels.spi.AsynchronousChannelProvider provider();
    method public abstract <A> void read(java.nio.ByteBuffer, long, java.util.concurrent.TimeUnit, A, java.nio.channels.CompletionHandler<java.lang.Integer,? super A>);
    method public final <A> void read(java.nio.ByteBuffer, A, java.nio.channels.CompletionHandler<java.lang.Integer,? super A>);
    method public abstract <A> void read(java.nio.ByteBuffer[], int, int, long, java.util.concurrent.TimeUnit, A, java.nio.channels.CompletionHandler<java.lang.Long,? super A>);
    method public abstract <T> java.nio.channels.AsynchronousSocketChannel setOption(java.net.SocketOption<T>, T) throws java.io.IOException;
    method public abstract java.nio.channels.AsynchronousSocketChannel shutdownInput() throws java.io.IOException;
    method public abstract java.nio.channels.AsynchronousSocketChannel shutdownOutput() throws java.io.IOException;
    method public abstract <A> void write(java.nio.ByteBuffer, long, java.util.concurrent.TimeUnit, A, java.nio.channels.CompletionHandler<java.lang.Integer,? super A>);
    method public final <A> void write(java.nio.ByteBuffer, A, java.nio.channels.CompletionHandler<java.lang.Integer,? super A>);
    method public abstract <A> void write(java.nio.ByteBuffer[], int, int, long, java.util.concurrent.TimeUnit, A, java.nio.channels.CompletionHandler<java.lang.Long,? super A>);
  }

  public interface ByteChannel extends java.nio.channels.ReadableByteChannel java.nio.channels.WritableByteChannel {
  }

  public class CancelledKeyException extends java.lang.IllegalStateException {
    ctor public CancelledKeyException();
  }

  public interface Channel extends java.io.Closeable {
    method public boolean isOpen();
  }

  public final class Channels {
    method public static java.nio.channels.ReadableByteChannel newChannel(java.io.InputStream);
    method public static java.nio.channels.WritableByteChannel newChannel(java.io.OutputStream);
    method public static java.io.InputStream newInputStream(java.nio.channels.ReadableByteChannel);
    method public static java.io.InputStream newInputStream(java.nio.channels.AsynchronousByteChannel);
    method public static java.io.OutputStream newOutputStream(java.nio.channels.WritableByteChannel);
    method public static java.io.OutputStream newOutputStream(java.nio.channels.AsynchronousByteChannel);
    method public static java.io.Reader newReader(java.nio.channels.ReadableByteChannel, java.nio.charset.CharsetDecoder, int);
    method public static java.io.Reader newReader(java.nio.channels.ReadableByteChannel, String);
    method public static java.io.Reader newReader(java.nio.channels.ReadableByteChannel, java.nio.charset.Charset);
    method public static java.io.Writer newWriter(java.nio.channels.WritableByteChannel, java.nio.charset.CharsetEncoder, int);
    method public static java.io.Writer newWriter(java.nio.channels.WritableByteChannel, String);
    method public static java.io.Writer newWriter(java.nio.channels.WritableByteChannel, java.nio.charset.Charset);
  }

  public class ClosedByInterruptException extends java.nio.channels.AsynchronousCloseException {
    ctor public ClosedByInterruptException();
  }

  public class ClosedChannelException extends java.io.IOException {
    ctor public ClosedChannelException();
  }

  public class ClosedSelectorException extends java.lang.IllegalStateException {
    ctor public ClosedSelectorException();
  }

  public interface CompletionHandler<V, A> {
    method public void completed(V, A);
    method public void failed(Throwable, A);
  }

  public class ConnectionPendingException extends java.lang.IllegalStateException {
    ctor public ConnectionPendingException();
  }

  public abstract class DatagramChannel extends java.nio.channels.spi.AbstractSelectableChannel implements java.nio.channels.ByteChannel java.nio.channels.GatheringByteChannel java.nio.channels.MulticastChannel java.nio.channels.ScatteringByteChannel {
    ctor protected DatagramChannel(java.nio.channels.spi.SelectorProvider);
    method public abstract java.nio.channels.DatagramChannel bind(java.net.SocketAddress) throws java.io.IOException;
    method public abstract java.nio.channels.DatagramChannel connect(java.net.SocketAddress) throws java.io.IOException;
    method public abstract java.nio.channels.DatagramChannel disconnect() throws java.io.IOException;
    method public abstract java.net.SocketAddress getRemoteAddress() throws java.io.IOException;
    method public abstract boolean isConnected();
    method public static java.nio.channels.DatagramChannel open() throws java.io.IOException;
    method public static java.nio.channels.DatagramChannel open(java.net.ProtocolFamily) throws java.io.IOException;
    method public final long read(java.nio.ByteBuffer[]) throws java.io.IOException;
    method public abstract java.net.SocketAddress receive(java.nio.ByteBuffer) throws java.io.IOException;
    method public abstract int send(java.nio.ByteBuffer, java.net.SocketAddress) throws java.io.IOException;
    method public abstract <T> java.nio.channels.DatagramChannel setOption(java.net.SocketOption<T>, T) throws java.io.IOException;
    method public abstract java.net.DatagramSocket socket();
    method public final int validOps();
    method public final long write(java.nio.ByteBuffer[]) throws java.io.IOException;
  }

  public abstract class FileChannel extends java.nio.channels.spi.AbstractInterruptibleChannel implements java.nio.channels.GatheringByteChannel java.nio.channels.ScatteringByteChannel java.nio.channels.SeekableByteChannel {
    ctor protected FileChannel();
    method public abstract void force(boolean) throws java.io.IOException;
    method public abstract java.nio.channels.FileLock lock(long, long, boolean) throws java.io.IOException;
    method public final java.nio.channels.FileLock lock() throws java.io.IOException;
    method public abstract java.nio.MappedByteBuffer map(java.nio.channels.FileChannel.MapMode, long, long) throws java.io.IOException;
    method public static java.nio.channels.FileChannel open(java.nio.file.Path, java.util.Set<? extends java.nio.file.OpenOption>, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public static java.nio.channels.FileChannel open(java.nio.file.Path, java.nio.file.OpenOption...) throws java.io.IOException;
    method public abstract java.nio.channels.FileChannel position(long) throws java.io.IOException;
    method public final long read(java.nio.ByteBuffer[]) throws java.io.IOException;
    method public abstract int read(java.nio.ByteBuffer, long) throws java.io.IOException;
    method public abstract long transferFrom(java.nio.channels.ReadableByteChannel, long, long) throws java.io.IOException;
    method public abstract long transferTo(long, long, java.nio.channels.WritableByteChannel) throws java.io.IOException;
    method public abstract java.nio.channels.FileChannel truncate(long) throws java.io.IOException;
    method public abstract java.nio.channels.FileLock tryLock(long, long, boolean) throws java.io.IOException;
    method public final java.nio.channels.FileLock tryLock() throws java.io.IOException;
    method public final long write(java.nio.ByteBuffer[]) throws java.io.IOException;
    method public abstract int write(java.nio.ByteBuffer, long) throws java.io.IOException;
  }

  public static class FileChannel.MapMode {
    field public static final java.nio.channels.FileChannel.MapMode PRIVATE;
    field public static final java.nio.channels.FileChannel.MapMode READ_ONLY;
    field public static final java.nio.channels.FileChannel.MapMode READ_WRITE;
  }

  public abstract class FileLock implements java.lang.AutoCloseable {
    ctor protected FileLock(java.nio.channels.FileChannel, long, long, boolean);
    ctor protected FileLock(java.nio.channels.AsynchronousFileChannel, long, long, boolean);
    method public java.nio.channels.Channel acquiredBy();
    method public final java.nio.channels.FileChannel channel();
    method public final void close() throws java.io.IOException;
    method public final boolean isShared();
    method public abstract boolean isValid();
    method public final boolean overlaps(long, long);
    method public final long position();
    method public abstract void release() throws java.io.IOException;
    method public final long size();
    method public final String toString();
  }

  public class FileLockInterruptionException extends java.io.IOException {
    ctor public FileLockInterruptionException();
  }

  public interface GatheringByteChannel extends java.nio.channels.WritableByteChannel {
    method public long write(java.nio.ByteBuffer[], int, int) throws java.io.IOException;
    method public long write(java.nio.ByteBuffer[]) throws java.io.IOException;
  }

  public class IllegalBlockingModeException extends java.lang.IllegalStateException {
    ctor public IllegalBlockingModeException();
  }

  public class IllegalChannelGroupException extends java.lang.IllegalArgumentException {
    ctor public IllegalChannelGroupException();
  }

  public class IllegalSelectorException extends java.lang.IllegalArgumentException {
    ctor public IllegalSelectorException();
  }

  public class InterruptedByTimeoutException extends java.io.IOException {
    ctor public InterruptedByTimeoutException();
  }

  public interface InterruptibleChannel extends java.nio.channels.Channel {
  }

  public abstract class MembershipKey {
    ctor protected MembershipKey();
    method public abstract java.nio.channels.MembershipKey block(java.net.InetAddress) throws java.io.IOException;
    method public abstract java.nio.channels.MulticastChannel channel();
    method public abstract void drop();
    method public abstract java.net.InetAddress group();
    method public abstract boolean isValid();
    method public abstract java.net.NetworkInterface networkInterface();
    method public abstract java.net.InetAddress sourceAddress();
    method public abstract java.nio.channels.MembershipKey unblock(java.net.InetAddress);
  }

  public interface MulticastChannel extends java.nio.channels.NetworkChannel {
    method public java.nio.channels.MembershipKey join(java.net.InetAddress, java.net.NetworkInterface) throws java.io.IOException;
    method public java.nio.channels.MembershipKey join(java.net.InetAddress, java.net.NetworkInterface, java.net.InetAddress) throws java.io.IOException;
  }

  public interface NetworkChannel extends java.nio.channels.Channel {
    method public java.nio.channels.NetworkChannel bind(java.net.SocketAddress) throws java.io.IOException;
    method public java.net.SocketAddress getLocalAddress() throws java.io.IOException;
    method public <T> T getOption(java.net.SocketOption<T>) throws java.io.IOException;
    method public <T> java.nio.channels.NetworkChannel setOption(java.net.SocketOption<T>, T) throws java.io.IOException;
    method public java.util.Set<java.net.SocketOption<?>> supportedOptions();
  }

  public class NoConnectionPendingException extends java.lang.IllegalStateException {
    ctor public NoConnectionPendingException();
  }

  public class NonReadableChannelException extends java.lang.IllegalStateException {
    ctor public NonReadableChannelException();
  }

  public class NonWritableChannelException extends java.lang.IllegalStateException {
    ctor public NonWritableChannelException();
  }

  public class NotYetBoundException extends java.lang.IllegalStateException {
    ctor public NotYetBoundException();
  }

  public class NotYetConnectedException extends java.lang.IllegalStateException {
    ctor public NotYetConnectedException();
  }

  public class OverlappingFileLockException extends java.lang.IllegalStateException {
    ctor public OverlappingFileLockException();
  }

  public abstract class Pipe {
    ctor protected Pipe();
    method public static java.nio.channels.Pipe open() throws java.io.IOException;
    method public abstract java.nio.channels.Pipe.SinkChannel sink();
    method public abstract java.nio.channels.Pipe.SourceChannel source();
  }

  public abstract static class Pipe.SinkChannel extends java.nio.channels.spi.AbstractSelectableChannel implements java.nio.channels.GatheringByteChannel java.nio.channels.WritableByteChannel {
    ctor protected Pipe.SinkChannel(java.nio.channels.spi.SelectorProvider);
    method public final int validOps();
  }

  public abstract static class Pipe.SourceChannel extends java.nio.channels.spi.AbstractSelectableChannel implements java.nio.channels.ReadableByteChannel java.nio.channels.ScatteringByteChannel {
    ctor protected Pipe.SourceChannel(java.nio.channels.spi.SelectorProvider);
    method public final int validOps();
  }

  public class ReadPendingException extends java.lang.IllegalStateException {
    ctor public ReadPendingException();
  }

  public interface ReadableByteChannel extends java.nio.channels.Channel {
    method public int read(java.nio.ByteBuffer) throws java.io.IOException;
  }

  public interface ScatteringByteChannel extends java.nio.channels.ReadableByteChannel {
    method public long read(java.nio.ByteBuffer[], int, int) throws java.io.IOException;
    method public long read(java.nio.ByteBuffer[]) throws java.io.IOException;
  }

  public interface SeekableByteChannel extends java.nio.channels.ByteChannel {
    method public long position() throws java.io.IOException;
    method public java.nio.channels.SeekableByteChannel position(long) throws java.io.IOException;
    method public long size() throws java.io.IOException;
    method public java.nio.channels.SeekableByteChannel truncate(long) throws java.io.IOException;
  }

  public abstract class SelectableChannel extends java.nio.channels.spi.AbstractInterruptibleChannel implements java.nio.channels.Channel {
    ctor protected SelectableChannel();
    method public abstract Object blockingLock();
    method public abstract java.nio.channels.SelectableChannel configureBlocking(boolean) throws java.io.IOException;
    method public abstract boolean isBlocking();
    method public abstract boolean isRegistered();
    method public abstract java.nio.channels.SelectionKey keyFor(java.nio.channels.Selector);
    method public abstract java.nio.channels.spi.SelectorProvider provider();
    method public abstract java.nio.channels.SelectionKey register(java.nio.channels.Selector, int, Object) throws java.nio.channels.ClosedChannelException;
    method public final java.nio.channels.SelectionKey register(java.nio.channels.Selector, int) throws java.nio.channels.ClosedChannelException;
    method public abstract int validOps();
  }

  public abstract class SelectionKey {
    ctor protected SelectionKey();
    method public final Object attach(Object);
    method public final Object attachment();
    method public abstract void cancel();
    method public abstract java.nio.channels.SelectableChannel channel();
    method public abstract int interestOps();
    method public abstract java.nio.channels.SelectionKey interestOps(int);
    method public int interestOpsAnd(int);
    method public int interestOpsOr(int);
    method public final boolean isAcceptable();
    method public final boolean isConnectable();
    method public final boolean isReadable();
    method public abstract boolean isValid();
    method public final boolean isWritable();
    method public abstract int readyOps();
    method public abstract java.nio.channels.Selector selector();
    field public static final int OP_ACCEPT = 16; // 0x10
    field public static final int OP_CONNECT = 8; // 0x8
    field public static final int OP_READ = 1; // 0x1
    field public static final int OP_WRITE = 4; // 0x4
  }

  public abstract class Selector implements java.io.Closeable {
    ctor protected Selector();
    method public abstract boolean isOpen();
    method public abstract java.util.Set<java.nio.channels.SelectionKey> keys();
    method public static java.nio.channels.Selector open() throws java.io.IOException;
    method public abstract java.nio.channels.spi.SelectorProvider provider();
    method public abstract int select(long) throws java.io.IOException;
    method public abstract int select() throws java.io.IOException;
    method public int select(java.util.function.Consumer<java.nio.channels.SelectionKey>, long) throws java.io.IOException;
    method public int select(java.util.function.Consumer<java.nio.channels.SelectionKey>) throws java.io.IOException;
    method public abstract int selectNow() throws java.io.IOException;
    method public int selectNow(java.util.function.Consumer<java.nio.channels.SelectionKey>) throws java.io.IOException;
    method public abstract java.util.Set<java.nio.channels.SelectionKey> selectedKeys();
    method public abstract java.nio.channels.Selector wakeup();
  }

  public abstract class ServerSocketChannel extends java.nio.channels.spi.AbstractSelectableChannel implements java.nio.channels.NetworkChannel {
    ctor protected ServerSocketChannel(java.nio.channels.spi.SelectorProvider);
    method public abstract java.nio.channels.SocketChannel accept() throws java.io.IOException;
    method public final java.nio.channels.ServerSocketChannel bind(java.net.SocketAddress) throws java.io.IOException;
    method public abstract java.nio.channels.ServerSocketChannel bind(java.net.SocketAddress, int) throws java.io.IOException;
    method public static java.nio.channels.ServerSocketChannel open() throws java.io.IOException;
    method public abstract <T> java.nio.channels.ServerSocketChannel setOption(java.net.SocketOption<T>, T) throws java.io.IOException;
    method public abstract java.net.ServerSocket socket();
    method public final int validOps();
  }

  public class ShutdownChannelGroupException extends java.lang.IllegalStateException {
    ctor public ShutdownChannelGroupException();
  }

  public abstract class SocketChannel extends java.nio.channels.spi.AbstractSelectableChannel implements java.nio.channels.ByteChannel java.nio.channels.GatheringByteChannel java.nio.channels.NetworkChannel java.nio.channels.ScatteringByteChannel {
    ctor protected SocketChannel(java.nio.channels.spi.SelectorProvider);
    method public abstract java.nio.channels.SocketChannel bind(java.net.SocketAddress) throws java.io.IOException;
    method public abstract boolean connect(java.net.SocketAddress) throws java.io.IOException;
    method public abstract boolean finishConnect() throws java.io.IOException;
    method public abstract java.net.SocketAddress getRemoteAddress() throws java.io.IOException;
    method public abstract boolean isConnected();
    method public abstract boolean isConnectionPending();
    method public static java.nio.channels.SocketChannel open() throws java.io.IOException;
    method public static java.nio.channels.SocketChannel open(java.net.SocketAddress) throws java.io.IOException;
    method public final long read(java.nio.ByteBuffer[]) throws java.io.IOException;
    method public abstract <T> java.nio.channels.SocketChannel setOption(java.net.SocketOption<T>, T) throws java.io.IOException;
    method public abstract java.nio.channels.SocketChannel shutdownInput() throws java.io.IOException;
    method public abstract java.nio.channels.SocketChannel shutdownOutput() throws java.io.IOException;
    method public abstract java.net.Socket socket();
    method public final int validOps();
    method public final long write(java.nio.ByteBuffer[]) throws java.io.IOException;
  }

  public class UnresolvedAddressException extends java.lang.IllegalArgumentException {
    ctor public UnresolvedAddressException();
  }

  public class UnsupportedAddressTypeException extends java.lang.IllegalArgumentException {
    ctor public UnsupportedAddressTypeException();
  }

  public interface WritableByteChannel extends java.nio.channels.Channel {
    method public int write(java.nio.ByteBuffer) throws java.io.IOException;
  }

  public class WritePendingException extends java.lang.IllegalStateException {
    ctor public WritePendingException();
  }

}

package java.nio.channels.spi {

  public abstract class AbstractInterruptibleChannel implements java.nio.channels.Channel java.nio.channels.InterruptibleChannel {
    ctor protected AbstractInterruptibleChannel();
    method protected final void begin();
    method public final void close() throws java.io.IOException;
    method protected final void end(boolean) throws java.nio.channels.AsynchronousCloseException;
    method protected abstract void implCloseChannel() throws java.io.IOException;
    method public final boolean isOpen();
  }

  public abstract class AbstractSelectableChannel extends java.nio.channels.SelectableChannel {
    ctor protected AbstractSelectableChannel(java.nio.channels.spi.SelectorProvider);
    method public final Object blockingLock();
    method public final java.nio.channels.SelectableChannel configureBlocking(boolean) throws java.io.IOException;
    method protected final void implCloseChannel() throws java.io.IOException;
    method protected abstract void implCloseSelectableChannel() throws java.io.IOException;
    method protected abstract void implConfigureBlocking(boolean) throws java.io.IOException;
    method public final boolean isBlocking();
    method public final boolean isRegistered();
    method public final java.nio.channels.SelectionKey keyFor(java.nio.channels.Selector);
    method public final java.nio.channels.spi.SelectorProvider provider();
    method public final java.nio.channels.SelectionKey register(java.nio.channels.Selector, int, Object) throws java.nio.channels.ClosedChannelException;
  }

  public abstract class AbstractSelectionKey extends java.nio.channels.SelectionKey {
    ctor protected AbstractSelectionKey();
    method public final void cancel();
    method public final boolean isValid();
  }

  public abstract class AbstractSelector extends java.nio.channels.Selector {
    ctor protected AbstractSelector(java.nio.channels.spi.SelectorProvider);
    method protected final void begin();
    method protected final java.util.Set<java.nio.channels.SelectionKey> cancelledKeys();
    method public final void close() throws java.io.IOException;
    method protected final void deregister(java.nio.channels.spi.AbstractSelectionKey);
    method protected final void end();
    method protected abstract void implCloseSelector() throws java.io.IOException;
    method public final boolean isOpen();
    method public final java.nio.channels.spi.SelectorProvider provider();
    method protected abstract java.nio.channels.SelectionKey register(java.nio.channels.spi.AbstractSelectableChannel, int, Object);
  }

  public abstract class AsynchronousChannelProvider {
    ctor protected AsynchronousChannelProvider();
    method public abstract java.nio.channels.AsynchronousChannelGroup openAsynchronousChannelGroup(int, java.util.concurrent.ThreadFactory) throws java.io.IOException;
    method public abstract java.nio.channels.AsynchronousChannelGroup openAsynchronousChannelGroup(java.util.concurrent.ExecutorService, int) throws java.io.IOException;
    method public abstract java.nio.channels.AsynchronousServerSocketChannel openAsynchronousServerSocketChannel(java.nio.channels.AsynchronousChannelGroup) throws java.io.IOException;
    method public abstract java.nio.channels.AsynchronousSocketChannel openAsynchronousSocketChannel(java.nio.channels.AsynchronousChannelGroup) throws java.io.IOException;
    method public static java.nio.channels.spi.AsynchronousChannelProvider provider();
  }

  public abstract class SelectorProvider {
    ctor protected SelectorProvider();
    method public java.nio.channels.Channel inheritedChannel() throws java.io.IOException;
    method public abstract java.nio.channels.DatagramChannel openDatagramChannel() throws java.io.IOException;
    method public abstract java.nio.channels.DatagramChannel openDatagramChannel(java.net.ProtocolFamily) throws java.io.IOException;
    method public abstract java.nio.channels.Pipe openPipe() throws java.io.IOException;
    method public abstract java.nio.channels.spi.AbstractSelector openSelector() throws java.io.IOException;
    method public abstract java.nio.channels.ServerSocketChannel openServerSocketChannel() throws java.io.IOException;
    method public abstract java.nio.channels.SocketChannel openSocketChannel() throws java.io.IOException;
    method public static java.nio.channels.spi.SelectorProvider provider();
  }

}

package java.nio.charset {

  public class CharacterCodingException extends java.io.IOException {
    ctor public CharacterCodingException();
  }

  public abstract class Charset implements java.lang.Comparable<java.nio.charset.Charset> {
    ctor protected Charset(String, String[]);
    method public final java.util.Set<java.lang.String> aliases();
    method public static java.util.SortedMap<java.lang.String,java.nio.charset.Charset> availableCharsets();
    method public boolean canEncode();
    method public final int compareTo(java.nio.charset.Charset);
    method public abstract boolean contains(java.nio.charset.Charset);
    method public final java.nio.CharBuffer decode(java.nio.ByteBuffer);
    method public static java.nio.charset.Charset defaultCharset();
    method public String displayName();
    method public String displayName(java.util.Locale);
    method public final java.nio.ByteBuffer encode(java.nio.CharBuffer);
    method public final java.nio.ByteBuffer encode(String);
    method public final boolean equals(Object);
    method public static java.nio.charset.Charset forName(String);
    method public final int hashCode();
    method public final boolean isRegistered();
    method public static boolean isSupported(String);
    method public final String name();
    method public abstract java.nio.charset.CharsetDecoder newDecoder();
    method public abstract java.nio.charset.CharsetEncoder newEncoder();
    method public final String toString();
  }

  public abstract class CharsetDecoder {
    ctor protected CharsetDecoder(java.nio.charset.Charset, float, float);
    method public final float averageCharsPerByte();
    method public final java.nio.charset.Charset charset();
    method public final java.nio.charset.CoderResult decode(java.nio.ByteBuffer, java.nio.CharBuffer, boolean);
    method public final java.nio.CharBuffer decode(java.nio.ByteBuffer) throws java.nio.charset.CharacterCodingException;
    method protected abstract java.nio.charset.CoderResult decodeLoop(java.nio.ByteBuffer, java.nio.CharBuffer);
    method public java.nio.charset.Charset detectedCharset();
    method public final java.nio.charset.CoderResult flush(java.nio.CharBuffer);
    method protected java.nio.charset.CoderResult implFlush(java.nio.CharBuffer);
    method protected void implOnMalformedInput(java.nio.charset.CodingErrorAction);
    method protected void implOnUnmappableCharacter(java.nio.charset.CodingErrorAction);
    method protected void implReplaceWith(String);
    method protected void implReset();
    method public boolean isAutoDetecting();
    method public boolean isCharsetDetected();
    method public java.nio.charset.CodingErrorAction malformedInputAction();
    method public final float maxCharsPerByte();
    method public final java.nio.charset.CharsetDecoder onMalformedInput(java.nio.charset.CodingErrorAction);
    method public final java.nio.charset.CharsetDecoder onUnmappableCharacter(java.nio.charset.CodingErrorAction);
    method public final java.nio.charset.CharsetDecoder replaceWith(String);
    method public final String replacement();
    method public final java.nio.charset.CharsetDecoder reset();
    method public java.nio.charset.CodingErrorAction unmappableCharacterAction();
  }

  public abstract class CharsetEncoder {
    ctor protected CharsetEncoder(java.nio.charset.Charset, float, float, byte[]);
    ctor protected CharsetEncoder(java.nio.charset.Charset, float, float);
    method public final float averageBytesPerChar();
    method public boolean canEncode(char);
    method public boolean canEncode(CharSequence);
    method public final java.nio.charset.Charset charset();
    method public final java.nio.charset.CoderResult encode(java.nio.CharBuffer, java.nio.ByteBuffer, boolean);
    method public final java.nio.ByteBuffer encode(java.nio.CharBuffer) throws java.nio.charset.CharacterCodingException;
    method protected abstract java.nio.charset.CoderResult encodeLoop(java.nio.CharBuffer, java.nio.ByteBuffer);
    method public final java.nio.charset.CoderResult flush(java.nio.ByteBuffer);
    method protected java.nio.charset.CoderResult implFlush(java.nio.ByteBuffer);
    method protected void implOnMalformedInput(java.nio.charset.CodingErrorAction);
    method protected void implOnUnmappableCharacter(java.nio.charset.CodingErrorAction);
    method protected void implReplaceWith(byte[]);
    method protected void implReset();
    method public boolean isLegalReplacement(byte[]);
    method public java.nio.charset.CodingErrorAction malformedInputAction();
    method public final float maxBytesPerChar();
    method public final java.nio.charset.CharsetEncoder onMalformedInput(java.nio.charset.CodingErrorAction);
    method public final java.nio.charset.CharsetEncoder onUnmappableCharacter(java.nio.charset.CodingErrorAction);
    method public final java.nio.charset.CharsetEncoder replaceWith(byte[]);
    method public final byte[] replacement();
    method public final java.nio.charset.CharsetEncoder reset();
    method public java.nio.charset.CodingErrorAction unmappableCharacterAction();
  }

  public class CoderMalfunctionError extends java.lang.Error {
    ctor public CoderMalfunctionError(Exception);
  }

  public class CoderResult {
    method public boolean isError();
    method public boolean isMalformed();
    method public boolean isOverflow();
    method public boolean isUnderflow();
    method public boolean isUnmappable();
    method public int length();
    method public static java.nio.charset.CoderResult malformedForLength(int);
    method public void throwException() throws java.nio.charset.CharacterCodingException;
    method public static java.nio.charset.CoderResult unmappableForLength(int);
    field public static final java.nio.charset.CoderResult OVERFLOW;
    field public static final java.nio.charset.CoderResult UNDERFLOW;
  }

  public class CodingErrorAction {
    field public static final java.nio.charset.CodingErrorAction IGNORE;
    field public static final java.nio.charset.CodingErrorAction REPLACE;
    field public static final java.nio.charset.CodingErrorAction REPORT;
  }

  public class IllegalCharsetNameException extends java.lang.IllegalArgumentException {
    ctor public IllegalCharsetNameException(String);
    method public String getCharsetName();
  }

  public class MalformedInputException extends java.nio.charset.CharacterCodingException {
    ctor public MalformedInputException(int);
    method public int getInputLength();
  }

  public final class StandardCharsets {
    field public static final java.nio.charset.Charset ISO_8859_1;
    field public static final java.nio.charset.Charset US_ASCII;
    field public static final java.nio.charset.Charset UTF_16;
    field public static final java.nio.charset.Charset UTF_16BE;
    field public static final java.nio.charset.Charset UTF_16LE;
    field public static final java.nio.charset.Charset UTF_8;
  }

  public class UnmappableCharacterException extends java.nio.charset.CharacterCodingException {
    ctor public UnmappableCharacterException(int);
    method public int getInputLength();
  }

  public class UnsupportedCharsetException extends java.lang.IllegalArgumentException {
    ctor public UnsupportedCharsetException(String);
    method public String getCharsetName();
  }

}

package java.nio.charset.spi {

  public abstract class CharsetProvider {
    ctor protected CharsetProvider();
    method public abstract java.nio.charset.Charset charsetForName(String);
    method public abstract java.util.Iterator<java.nio.charset.Charset> charsets();
  }

}

package java.nio.file {

  public class AccessDeniedException extends java.nio.file.FileSystemException {
    ctor public AccessDeniedException(String);
    ctor public AccessDeniedException(String, String, String);
  }

  public enum AccessMode {
    enum_constant public static final java.nio.file.AccessMode EXECUTE;
    enum_constant public static final java.nio.file.AccessMode READ;
    enum_constant public static final java.nio.file.AccessMode WRITE;
  }

  public class AtomicMoveNotSupportedException extends java.nio.file.FileSystemException {
    ctor public AtomicMoveNotSupportedException(String, String, String);
  }

  public class ClosedDirectoryStreamException extends java.lang.IllegalStateException {
    ctor public ClosedDirectoryStreamException();
  }

  public class ClosedFileSystemException extends java.lang.IllegalStateException {
    ctor public ClosedFileSystemException();
  }

  public class ClosedWatchServiceException extends java.lang.IllegalStateException {
    ctor public ClosedWatchServiceException();
  }

  public interface CopyOption {
  }

  public final class DirectoryIteratorException extends java.util.ConcurrentModificationException {
    ctor public DirectoryIteratorException(java.io.IOException);
    method public java.io.IOException getCause();
  }

  public class DirectoryNotEmptyException extends java.nio.file.FileSystemException {
    ctor public DirectoryNotEmptyException(String);
  }

  public interface DirectoryStream<T> extends java.io.Closeable java.lang.Iterable<T> {
  }

  @java.lang.FunctionalInterface public static interface DirectoryStream.Filter<T> {
    method public boolean accept(T) throws java.io.IOException;
  }

  public class FileAlreadyExistsException extends java.nio.file.FileSystemException {
    ctor public FileAlreadyExistsException(String);
    ctor public FileAlreadyExistsException(String, String, String);
  }

  public abstract class FileStore {
    ctor protected FileStore();
    method public abstract Object getAttribute(String) throws java.io.IOException;
    method public long getBlockSize() throws java.io.IOException;
    method public abstract <V extends java.nio.file.attribute.FileStoreAttributeView> V getFileStoreAttributeView(Class<V>);
    method public abstract long getTotalSpace() throws java.io.IOException;
    method public abstract long getUnallocatedSpace() throws java.io.IOException;
    method public abstract long getUsableSpace() throws java.io.IOException;
    method public abstract boolean isReadOnly();
    method public abstract String name();
    method public abstract boolean supportsFileAttributeView(Class<? extends java.nio.file.attribute.FileAttributeView>);
    method public abstract boolean supportsFileAttributeView(String);
    method public abstract String type();
  }

  public abstract class FileSystem implements java.io.Closeable {
    ctor protected FileSystem();
    method public abstract Iterable<java.nio.file.FileStore> getFileStores();
    method public abstract java.nio.file.Path getPath(String, java.lang.String...);
    method public abstract java.nio.file.PathMatcher getPathMatcher(String);
    method public abstract Iterable<java.nio.file.Path> getRootDirectories();
    method public abstract String getSeparator();
    method public abstract java.nio.file.attribute.UserPrincipalLookupService getUserPrincipalLookupService();
    method public abstract boolean isOpen();
    method public abstract boolean isReadOnly();
    method public abstract java.nio.file.WatchService newWatchService() throws java.io.IOException;
    method public abstract java.nio.file.spi.FileSystemProvider provider();
    method public abstract java.util.Set<java.lang.String> supportedFileAttributeViews();
  }

  public class FileSystemAlreadyExistsException extends java.lang.RuntimeException {
    ctor public FileSystemAlreadyExistsException();
    ctor public FileSystemAlreadyExistsException(String);
  }

  public class FileSystemException extends java.io.IOException {
    ctor public FileSystemException(String);
    ctor public FileSystemException(String, String, String);
    method public String getFile();
    method public String getOtherFile();
    method public String getReason();
  }

  public class FileSystemLoopException extends java.nio.file.FileSystemException {
    ctor public FileSystemLoopException(String);
  }

  public class FileSystemNotFoundException extends java.lang.RuntimeException {
    ctor public FileSystemNotFoundException();
    ctor public FileSystemNotFoundException(String);
  }

  public final class FileSystems {
    method public static java.nio.file.FileSystem getDefault();
    method public static java.nio.file.FileSystem getFileSystem(java.net.URI);
    method public static java.nio.file.FileSystem newFileSystem(java.net.URI, java.util.Map<java.lang.String,?>) throws java.io.IOException;
    method public static java.nio.file.FileSystem newFileSystem(java.net.URI, java.util.Map<java.lang.String,?>, ClassLoader) throws java.io.IOException;
    method public static java.nio.file.FileSystem newFileSystem(java.nio.file.Path, ClassLoader) throws java.io.IOException;
  }

  public enum FileVisitOption {
    enum_constant public static final java.nio.file.FileVisitOption FOLLOW_LINKS;
  }

  public enum FileVisitResult {
    enum_constant public static final java.nio.file.FileVisitResult CONTINUE;
    enum_constant public static final java.nio.file.FileVisitResult SKIP_SIBLINGS;
    enum_constant public static final java.nio.file.FileVisitResult SKIP_SUBTREE;
    enum_constant public static final java.nio.file.FileVisitResult TERMINATE;
  }

  public interface FileVisitor<T> {
    method public java.nio.file.FileVisitResult postVisitDirectory(T, java.io.IOException) throws java.io.IOException;
    method public java.nio.file.FileVisitResult preVisitDirectory(T, java.nio.file.attribute.BasicFileAttributes) throws java.io.IOException;
    method public java.nio.file.FileVisitResult visitFile(T, java.nio.file.attribute.BasicFileAttributes) throws java.io.IOException;
    method public java.nio.file.FileVisitResult visitFileFailed(T, java.io.IOException) throws java.io.IOException;
  }

  public final class Files {
    method public static java.nio.file.Path copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...) throws java.io.IOException;
    method public static long copy(java.io.InputStream, java.nio.file.Path, java.nio.file.CopyOption...) throws java.io.IOException;
    method public static long copy(java.nio.file.Path, java.io.OutputStream) throws java.io.IOException;
    method public static java.nio.file.Path createDirectories(java.nio.file.Path, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public static java.nio.file.Path createDirectory(java.nio.file.Path, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public static java.nio.file.Path createFile(java.nio.file.Path, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public static java.nio.file.Path createLink(java.nio.file.Path, java.nio.file.Path) throws java.io.IOException;
    method public static java.nio.file.Path createSymbolicLink(java.nio.file.Path, java.nio.file.Path, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public static java.nio.file.Path createTempDirectory(java.nio.file.Path, String, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public static java.nio.file.Path createTempDirectory(String, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public static java.nio.file.Path createTempFile(java.nio.file.Path, String, String, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public static java.nio.file.Path createTempFile(String, String, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public static void delete(java.nio.file.Path) throws java.io.IOException;
    method public static boolean deleteIfExists(java.nio.file.Path) throws java.io.IOException;
    method public static boolean exists(java.nio.file.Path, java.nio.file.LinkOption...);
    method public static java.util.stream.Stream<java.nio.file.Path> find(java.nio.file.Path, int, java.util.function.BiPredicate<java.nio.file.Path,java.nio.file.attribute.BasicFileAttributes>, java.nio.file.FileVisitOption...) throws java.io.IOException;
    method public static Object getAttribute(java.nio.file.Path, String, java.nio.file.LinkOption...) throws java.io.IOException;
    method public static <V extends java.nio.file.attribute.FileAttributeView> V getFileAttributeView(java.nio.file.Path, Class<V>, java.nio.file.LinkOption...);
    method public static java.nio.file.FileStore getFileStore(java.nio.file.Path) throws java.io.IOException;
    method public static java.nio.file.attribute.FileTime getLastModifiedTime(java.nio.file.Path, java.nio.file.LinkOption...) throws java.io.IOException;
    method public static java.nio.file.attribute.UserPrincipal getOwner(java.nio.file.Path, java.nio.file.LinkOption...) throws java.io.IOException;
    method public static java.util.Set<java.nio.file.attribute.PosixFilePermission> getPosixFilePermissions(java.nio.file.Path, java.nio.file.LinkOption...) throws java.io.IOException;
    method public static boolean isDirectory(java.nio.file.Path, java.nio.file.LinkOption...);
    method public static boolean isExecutable(java.nio.file.Path);
    method public static boolean isHidden(java.nio.file.Path) throws java.io.IOException;
    method public static boolean isReadable(java.nio.file.Path);
    method public static boolean isRegularFile(java.nio.file.Path, java.nio.file.LinkOption...);
    method public static boolean isSameFile(java.nio.file.Path, java.nio.file.Path) throws java.io.IOException;
    method public static boolean isSymbolicLink(java.nio.file.Path);
    method public static boolean isWritable(java.nio.file.Path);
    method public static java.util.stream.Stream<java.lang.String> lines(java.nio.file.Path, java.nio.charset.Charset) throws java.io.IOException;
    method public static java.util.stream.Stream<java.lang.String> lines(java.nio.file.Path) throws java.io.IOException;
    method public static java.util.stream.Stream<java.nio.file.Path> list(java.nio.file.Path) throws java.io.IOException;
    method public static java.nio.file.Path move(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...) throws java.io.IOException;
    method public static java.io.BufferedReader newBufferedReader(java.nio.file.Path, java.nio.charset.Charset) throws java.io.IOException;
    method public static java.io.BufferedReader newBufferedReader(java.nio.file.Path) throws java.io.IOException;
    method public static java.io.BufferedWriter newBufferedWriter(java.nio.file.Path, java.nio.charset.Charset, java.nio.file.OpenOption...) throws java.io.IOException;
    method public static java.io.BufferedWriter newBufferedWriter(java.nio.file.Path, java.nio.file.OpenOption...) throws java.io.IOException;
    method public static java.nio.channels.SeekableByteChannel newByteChannel(java.nio.file.Path, java.util.Set<? extends java.nio.file.OpenOption>, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public static java.nio.channels.SeekableByteChannel newByteChannel(java.nio.file.Path, java.nio.file.OpenOption...) throws java.io.IOException;
    method public static java.nio.file.DirectoryStream<java.nio.file.Path> newDirectoryStream(java.nio.file.Path) throws java.io.IOException;
    method public static java.nio.file.DirectoryStream<java.nio.file.Path> newDirectoryStream(java.nio.file.Path, String) throws java.io.IOException;
    method public static java.nio.file.DirectoryStream<java.nio.file.Path> newDirectoryStream(java.nio.file.Path, java.nio.file.DirectoryStream.Filter<? super java.nio.file.Path>) throws java.io.IOException;
    method public static java.io.InputStream newInputStream(java.nio.file.Path, java.nio.file.OpenOption...) throws java.io.IOException;
    method public static java.io.OutputStream newOutputStream(java.nio.file.Path, java.nio.file.OpenOption...) throws java.io.IOException;
    method public static boolean notExists(java.nio.file.Path, java.nio.file.LinkOption...);
    method public static String probeContentType(java.nio.file.Path) throws java.io.IOException;
    method public static byte[] readAllBytes(java.nio.file.Path) throws java.io.IOException;
    method public static java.util.List<java.lang.String> readAllLines(java.nio.file.Path, java.nio.charset.Charset) throws java.io.IOException;
    method public static java.util.List<java.lang.String> readAllLines(java.nio.file.Path) throws java.io.IOException;
    method public static <A extends java.nio.file.attribute.BasicFileAttributes> A readAttributes(java.nio.file.Path, Class<A>, java.nio.file.LinkOption...) throws java.io.IOException;
    method public static java.util.Map<java.lang.String,java.lang.Object> readAttributes(java.nio.file.Path, String, java.nio.file.LinkOption...) throws java.io.IOException;
    method public static java.nio.file.Path readSymbolicLink(java.nio.file.Path) throws java.io.IOException;
    method public static java.nio.file.Path setAttribute(java.nio.file.Path, String, Object, java.nio.file.LinkOption...) throws java.io.IOException;
    method public static java.nio.file.Path setLastModifiedTime(java.nio.file.Path, java.nio.file.attribute.FileTime) throws java.io.IOException;
    method public static java.nio.file.Path setOwner(java.nio.file.Path, java.nio.file.attribute.UserPrincipal) throws java.io.IOException;
    method public static java.nio.file.Path setPosixFilePermissions(java.nio.file.Path, java.util.Set<java.nio.file.attribute.PosixFilePermission>) throws java.io.IOException;
    method public static long size(java.nio.file.Path) throws java.io.IOException;
    method public static java.util.stream.Stream<java.nio.file.Path> walk(java.nio.file.Path, int, java.nio.file.FileVisitOption...) throws java.io.IOException;
    method public static java.util.stream.Stream<java.nio.file.Path> walk(java.nio.file.Path, java.nio.file.FileVisitOption...) throws java.io.IOException;
    method public static java.nio.file.Path walkFileTree(java.nio.file.Path, java.util.Set<java.nio.file.FileVisitOption>, int, java.nio.file.FileVisitor<? super java.nio.file.Path>) throws java.io.IOException;
    method public static java.nio.file.Path walkFileTree(java.nio.file.Path, java.nio.file.FileVisitor<? super java.nio.file.Path>) throws java.io.IOException;
    method public static java.nio.file.Path write(java.nio.file.Path, byte[], java.nio.file.OpenOption...) throws java.io.IOException;
    method public static java.nio.file.Path write(java.nio.file.Path, Iterable<? extends java.lang.CharSequence>, java.nio.charset.Charset, java.nio.file.OpenOption...) throws java.io.IOException;
    method public static java.nio.file.Path write(java.nio.file.Path, Iterable<? extends java.lang.CharSequence>, java.nio.file.OpenOption...) throws java.io.IOException;
  }

  public class InvalidPathException extends java.lang.IllegalArgumentException {
    ctor public InvalidPathException(String, String, int);
    ctor public InvalidPathException(String, String);
    method public int getIndex();
    method public String getInput();
    method public String getReason();
  }

  public enum LinkOption implements java.nio.file.CopyOption java.nio.file.OpenOption {
    enum_constant public static final java.nio.file.LinkOption NOFOLLOW_LINKS;
  }

  public final class LinkPermission extends java.security.BasicPermission {
    ctor public LinkPermission(String);
    ctor public LinkPermission(String, String);
  }

  public class NoSuchFileException extends java.nio.file.FileSystemException {
    ctor public NoSuchFileException(String);
    ctor public NoSuchFileException(String, String, String);
  }

  public class NotDirectoryException extends java.nio.file.FileSystemException {
    ctor public NotDirectoryException(String);
  }

  public class NotLinkException extends java.nio.file.FileSystemException {
    ctor public NotLinkException(String);
    ctor public NotLinkException(String, String, String);
  }

  public interface OpenOption {
  }

  public interface Path extends java.lang.Comparable<java.nio.file.Path> java.lang.Iterable<java.nio.file.Path> java.nio.file.Watchable {
    method public int compareTo(java.nio.file.Path);
    method public boolean endsWith(java.nio.file.Path);
    method public boolean endsWith(String);
    method public boolean equals(Object);
    method public java.nio.file.Path getFileName();
    method public java.nio.file.FileSystem getFileSystem();
    method public java.nio.file.Path getName(int);
    method public int getNameCount();
    method public java.nio.file.Path getParent();
    method public java.nio.file.Path getRoot();
    method public int hashCode();
    method public boolean isAbsolute();
    method public java.util.Iterator<java.nio.file.Path> iterator();
    method public java.nio.file.Path normalize();
    method public static java.nio.file.Path of(String, java.lang.String...);
    method public static java.nio.file.Path of(java.net.URI);
    method public java.nio.file.Path relativize(java.nio.file.Path);
    method public java.nio.file.Path resolve(java.nio.file.Path);
    method public java.nio.file.Path resolve(String);
    method public java.nio.file.Path resolveSibling(java.nio.file.Path);
    method public java.nio.file.Path resolveSibling(String);
    method public boolean startsWith(java.nio.file.Path);
    method public boolean startsWith(String);
    method public java.nio.file.Path subpath(int, int);
    method public java.nio.file.Path toAbsolutePath();
    method public java.io.File toFile();
    method public java.nio.file.Path toRealPath(java.nio.file.LinkOption...) throws java.io.IOException;
    method public String toString();
    method public java.net.URI toUri();
  }

  @java.lang.FunctionalInterface public interface PathMatcher {
    method public boolean matches(java.nio.file.Path);
  }

  public final class Paths {
    method public static java.nio.file.Path get(String, java.lang.String...);
    method public static java.nio.file.Path get(java.net.URI);
  }

  public class ProviderMismatchException extends java.lang.IllegalArgumentException {
    ctor public ProviderMismatchException();
    ctor public ProviderMismatchException(String);
  }

  public class ProviderNotFoundException extends java.lang.RuntimeException {
    ctor public ProviderNotFoundException();
    ctor public ProviderNotFoundException(String);
  }

  public class ReadOnlyFileSystemException extends java.lang.UnsupportedOperationException {
    ctor public ReadOnlyFileSystemException();
  }

  public interface SecureDirectoryStream<T> extends java.nio.file.DirectoryStream<T> {
    method public void deleteDirectory(T) throws java.io.IOException;
    method public void deleteFile(T) throws java.io.IOException;
    method public <V extends java.nio.file.attribute.FileAttributeView> V getFileAttributeView(Class<V>);
    method public <V extends java.nio.file.attribute.FileAttributeView> V getFileAttributeView(T, Class<V>, java.nio.file.LinkOption...);
    method public void move(T, java.nio.file.SecureDirectoryStream<T>, T) throws java.io.IOException;
    method public java.nio.channels.SeekableByteChannel newByteChannel(T, java.util.Set<? extends java.nio.file.OpenOption>, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public java.nio.file.SecureDirectoryStream<T> newDirectoryStream(T, java.nio.file.LinkOption...) throws java.io.IOException;
  }

  public class SimpleFileVisitor<T> implements java.nio.file.FileVisitor<T> {
    ctor protected SimpleFileVisitor();
    method public java.nio.file.FileVisitResult postVisitDirectory(T, java.io.IOException) throws java.io.IOException;
    method public java.nio.file.FileVisitResult preVisitDirectory(T, java.nio.file.attribute.BasicFileAttributes) throws java.io.IOException;
    method public java.nio.file.FileVisitResult visitFile(T, java.nio.file.attribute.BasicFileAttributes) throws java.io.IOException;
    method public java.nio.file.FileVisitResult visitFileFailed(T, java.io.IOException) throws java.io.IOException;
  }

  public enum StandardCopyOption implements java.nio.file.CopyOption {
    enum_constant public static final java.nio.file.StandardCopyOption ATOMIC_MOVE;
    enum_constant public static final java.nio.file.StandardCopyOption COPY_ATTRIBUTES;
    enum_constant public static final java.nio.file.StandardCopyOption REPLACE_EXISTING;
  }

  public enum StandardOpenOption implements java.nio.file.OpenOption {
    enum_constant public static final java.nio.file.StandardOpenOption APPEND;
    enum_constant public static final java.nio.file.StandardOpenOption CREATE;
    enum_constant public static final java.nio.file.StandardOpenOption CREATE_NEW;
    enum_constant public static final java.nio.file.StandardOpenOption DELETE_ON_CLOSE;
    enum_constant public static final java.nio.file.StandardOpenOption DSYNC;
    enum_constant public static final java.nio.file.StandardOpenOption READ;
    enum_constant public static final java.nio.file.StandardOpenOption SPARSE;
    enum_constant public static final java.nio.file.StandardOpenOption SYNC;
    enum_constant public static final java.nio.file.StandardOpenOption TRUNCATE_EXISTING;
    enum_constant public static final java.nio.file.StandardOpenOption WRITE;
  }

  public final class StandardWatchEventKinds {
    field public static final java.nio.file.WatchEvent.Kind<java.nio.file.Path> ENTRY_CREATE;
    field public static final java.nio.file.WatchEvent.Kind<java.nio.file.Path> ENTRY_DELETE;
    field public static final java.nio.file.WatchEvent.Kind<java.nio.file.Path> ENTRY_MODIFY;
    field public static final java.nio.file.WatchEvent.Kind<java.lang.Object> OVERFLOW;
  }

  public interface WatchEvent<T> {
    method public T context();
    method public int count();
    method public java.nio.file.WatchEvent.Kind<T> kind();
  }

  public static interface WatchEvent.Kind<T> {
    method public String name();
    method public Class<T> type();
  }

  public static interface WatchEvent.Modifier {
    method public String name();
  }

  public interface WatchKey {
    method public void cancel();
    method public boolean isValid();
    method public java.util.List<java.nio.file.WatchEvent<?>> pollEvents();
    method public boolean reset();
    method public java.nio.file.Watchable watchable();
  }

  public interface WatchService extends java.io.Closeable {
    method public java.nio.file.WatchKey poll();
    method public java.nio.file.WatchKey poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public java.nio.file.WatchKey take() throws java.lang.InterruptedException;
  }

  public interface Watchable {
    method public java.nio.file.WatchKey register(java.nio.file.WatchService, java.nio.file.WatchEvent.Kind<?>[], java.nio.file.WatchEvent.Modifier...) throws java.io.IOException;
    method public java.nio.file.WatchKey register(java.nio.file.WatchService, java.nio.file.WatchEvent.Kind<?>...) throws java.io.IOException;
  }

}

package java.nio.file.attribute {

  public final class AclEntry {
    method public java.util.Set<java.nio.file.attribute.AclEntryFlag> flags();
    method public static java.nio.file.attribute.AclEntry.Builder newBuilder();
    method public static java.nio.file.attribute.AclEntry.Builder newBuilder(java.nio.file.attribute.AclEntry);
    method public java.util.Set<java.nio.file.attribute.AclEntryPermission> permissions();
    method public java.nio.file.attribute.UserPrincipal principal();
    method public java.nio.file.attribute.AclEntryType type();
  }

  public static final class AclEntry.Builder {
    method public java.nio.file.attribute.AclEntry build();
    method public java.nio.file.attribute.AclEntry.Builder setFlags(java.util.Set<java.nio.file.attribute.AclEntryFlag>);
    method public java.nio.file.attribute.AclEntry.Builder setFlags(java.nio.file.attribute.AclEntryFlag...);
    method public java.nio.file.attribute.AclEntry.Builder setPermissions(java.util.Set<java.nio.file.attribute.AclEntryPermission>);
    method public java.nio.file.attribute.AclEntry.Builder setPermissions(java.nio.file.attribute.AclEntryPermission...);
    method public java.nio.file.attribute.AclEntry.Builder setPrincipal(java.nio.file.attribute.UserPrincipal);
    method public java.nio.file.attribute.AclEntry.Builder setType(java.nio.file.attribute.AclEntryType);
  }

  public enum AclEntryFlag {
    enum_constant public static final java.nio.file.attribute.AclEntryFlag DIRECTORY_INHERIT;
    enum_constant public static final java.nio.file.attribute.AclEntryFlag FILE_INHERIT;
    enum_constant public static final java.nio.file.attribute.AclEntryFlag INHERIT_ONLY;
    enum_constant public static final java.nio.file.attribute.AclEntryFlag NO_PROPAGATE_INHERIT;
  }

  public enum AclEntryPermission {
    enum_constant public static final java.nio.file.attribute.AclEntryPermission APPEND_DATA;
    enum_constant public static final java.nio.file.attribute.AclEntryPermission DELETE;
    enum_constant public static final java.nio.file.attribute.AclEntryPermission DELETE_CHILD;
    enum_constant public static final java.nio.file.attribute.AclEntryPermission EXECUTE;
    enum_constant public static final java.nio.file.attribute.AclEntryPermission READ_ACL;
    enum_constant public static final java.nio.file.attribute.AclEntryPermission READ_ATTRIBUTES;
    enum_constant public static final java.nio.file.attribute.AclEntryPermission READ_DATA;
    enum_constant public static final java.nio.file.attribute.AclEntryPermission READ_NAMED_ATTRS;
    enum_constant public static final java.nio.file.attribute.AclEntryPermission SYNCHRONIZE;
    enum_constant public static final java.nio.file.attribute.AclEntryPermission WRITE_ACL;
    enum_constant public static final java.nio.file.attribute.AclEntryPermission WRITE_ATTRIBUTES;
    enum_constant public static final java.nio.file.attribute.AclEntryPermission WRITE_DATA;
    enum_constant public static final java.nio.file.attribute.AclEntryPermission WRITE_NAMED_ATTRS;
    enum_constant public static final java.nio.file.attribute.AclEntryPermission WRITE_OWNER;
    field public static final java.nio.file.attribute.AclEntryPermission ADD_FILE;
    field public static final java.nio.file.attribute.AclEntryPermission ADD_SUBDIRECTORY;
    field public static final java.nio.file.attribute.AclEntryPermission LIST_DIRECTORY;
  }

  public enum AclEntryType {
    enum_constant public static final java.nio.file.attribute.AclEntryType ALARM;
    enum_constant public static final java.nio.file.attribute.AclEntryType ALLOW;
    enum_constant public static final java.nio.file.attribute.AclEntryType AUDIT;
    enum_constant public static final java.nio.file.attribute.AclEntryType DENY;
  }

  public interface AclFileAttributeView extends java.nio.file.attribute.FileOwnerAttributeView {
    method public java.util.List<java.nio.file.attribute.AclEntry> getAcl() throws java.io.IOException;
    method public void setAcl(java.util.List<java.nio.file.attribute.AclEntry>) throws java.io.IOException;
  }

  public interface AttributeView {
    method public String name();
  }

  public interface BasicFileAttributeView extends java.nio.file.attribute.FileAttributeView {
    method public java.nio.file.attribute.BasicFileAttributes readAttributes() throws java.io.IOException;
    method public void setTimes(java.nio.file.attribute.FileTime, java.nio.file.attribute.FileTime, java.nio.file.attribute.FileTime) throws java.io.IOException;
  }

  public interface BasicFileAttributes {
    method public java.nio.file.attribute.FileTime creationTime();
    method public Object fileKey();
    method public boolean isDirectory();
    method public boolean isOther();
    method public boolean isRegularFile();
    method public boolean isSymbolicLink();
    method public java.nio.file.attribute.FileTime lastAccessTime();
    method public java.nio.file.attribute.FileTime lastModifiedTime();
    method public long size();
  }

  public interface DosFileAttributeView extends java.nio.file.attribute.BasicFileAttributeView {
    method public java.nio.file.attribute.DosFileAttributes readAttributes() throws java.io.IOException;
    method public void setArchive(boolean) throws java.io.IOException;
    method public void setHidden(boolean) throws java.io.IOException;
    method public void setReadOnly(boolean) throws java.io.IOException;
    method public void setSystem(boolean) throws java.io.IOException;
  }

  public interface DosFileAttributes extends java.nio.file.attribute.BasicFileAttributes {
    method public boolean isArchive();
    method public boolean isHidden();
    method public boolean isReadOnly();
    method public boolean isSystem();
  }

  public interface FileAttribute<T> {
    method public String name();
    method public T value();
  }

  public interface FileAttributeView extends java.nio.file.attribute.AttributeView {
  }

  public interface FileOwnerAttributeView extends java.nio.file.attribute.FileAttributeView {
    method public java.nio.file.attribute.UserPrincipal getOwner() throws java.io.IOException;
    method public void setOwner(java.nio.file.attribute.UserPrincipal) throws java.io.IOException;
  }

  public interface FileStoreAttributeView extends java.nio.file.attribute.AttributeView {
  }

  public final class FileTime implements java.lang.Comparable<java.nio.file.attribute.FileTime> {
    method public int compareTo(java.nio.file.attribute.FileTime);
    method public static java.nio.file.attribute.FileTime from(long, java.util.concurrent.TimeUnit);
    method public static java.nio.file.attribute.FileTime from(java.time.Instant);
    method public static java.nio.file.attribute.FileTime fromMillis(long);
    method public long to(java.util.concurrent.TimeUnit);
    method public java.time.Instant toInstant();
    method public long toMillis();
  }

  public interface GroupPrincipal extends java.nio.file.attribute.UserPrincipal {
  }

  public interface PosixFileAttributeView extends java.nio.file.attribute.BasicFileAttributeView java.nio.file.attribute.FileOwnerAttributeView {
    method public String name();
    method public java.nio.file.attribute.PosixFileAttributes readAttributes() throws java.io.IOException;
    method public void setGroup(java.nio.file.attribute.GroupPrincipal) throws java.io.IOException;
    method public void setPermissions(java.util.Set<java.nio.file.attribute.PosixFilePermission>) throws java.io.IOException;
  }

  public interface PosixFileAttributes extends java.nio.file.attribute.BasicFileAttributes {
    method public java.nio.file.attribute.GroupPrincipal group();
    method public java.nio.file.attribute.UserPrincipal owner();
    method public java.util.Set<java.nio.file.attribute.PosixFilePermission> permissions();
  }

  public enum PosixFilePermission {
    enum_constant public static final java.nio.file.attribute.PosixFilePermission GROUP_EXECUTE;
    enum_constant public static final java.nio.file.attribute.PosixFilePermission GROUP_READ;
    enum_constant public static final java.nio.file.attribute.PosixFilePermission GROUP_WRITE;
    enum_constant public static final java.nio.file.attribute.PosixFilePermission OTHERS_EXECUTE;
    enum_constant public static final java.nio.file.attribute.PosixFilePermission OTHERS_READ;
    enum_constant public static final java.nio.file.attribute.PosixFilePermission OTHERS_WRITE;
    enum_constant public static final java.nio.file.attribute.PosixFilePermission OWNER_EXECUTE;
    enum_constant public static final java.nio.file.attribute.PosixFilePermission OWNER_READ;
    enum_constant public static final java.nio.file.attribute.PosixFilePermission OWNER_WRITE;
  }

  public final class PosixFilePermissions {
    method public static java.nio.file.attribute.FileAttribute<java.util.Set<java.nio.file.attribute.PosixFilePermission>> asFileAttribute(java.util.Set<java.nio.file.attribute.PosixFilePermission>);
    method public static java.util.Set<java.nio.file.attribute.PosixFilePermission> fromString(String);
    method public static String toString(java.util.Set<java.nio.file.attribute.PosixFilePermission>);
  }

  public interface UserDefinedFileAttributeView extends java.nio.file.attribute.FileAttributeView {
    method public void delete(String) throws java.io.IOException;
    method public java.util.List<java.lang.String> list() throws java.io.IOException;
    method public int read(String, java.nio.ByteBuffer) throws java.io.IOException;
    method public int size(String) throws java.io.IOException;
    method public int write(String, java.nio.ByteBuffer) throws java.io.IOException;
  }

  public interface UserPrincipal extends java.security.Principal {
  }

  public abstract class UserPrincipalLookupService {
    ctor protected UserPrincipalLookupService();
    method public abstract java.nio.file.attribute.GroupPrincipal lookupPrincipalByGroupName(String) throws java.io.IOException;
    method public abstract java.nio.file.attribute.UserPrincipal lookupPrincipalByName(String) throws java.io.IOException;
  }

  public class UserPrincipalNotFoundException extends java.io.IOException {
    ctor public UserPrincipalNotFoundException(String);
    method public String getName();
  }

}

package java.nio.file.spi {

  public abstract class FileSystemProvider {
    ctor protected FileSystemProvider();
    method public abstract void checkAccess(java.nio.file.Path, java.nio.file.AccessMode...) throws java.io.IOException;
    method public abstract void copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...) throws java.io.IOException;
    method public abstract void createDirectory(java.nio.file.Path, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public void createLink(java.nio.file.Path, java.nio.file.Path) throws java.io.IOException;
    method public void createSymbolicLink(java.nio.file.Path, java.nio.file.Path, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public abstract void delete(java.nio.file.Path) throws java.io.IOException;
    method public boolean deleteIfExists(java.nio.file.Path) throws java.io.IOException;
    method public abstract <V extends java.nio.file.attribute.FileAttributeView> V getFileAttributeView(java.nio.file.Path, Class<V>, java.nio.file.LinkOption...);
    method public abstract java.nio.file.FileStore getFileStore(java.nio.file.Path) throws java.io.IOException;
    method public abstract java.nio.file.FileSystem getFileSystem(java.net.URI);
    method public abstract java.nio.file.Path getPath(java.net.URI);
    method public abstract String getScheme();
    method public static java.util.List<java.nio.file.spi.FileSystemProvider> installedProviders();
    method public abstract boolean isHidden(java.nio.file.Path) throws java.io.IOException;
    method public abstract boolean isSameFile(java.nio.file.Path, java.nio.file.Path) throws java.io.IOException;
    method public abstract void move(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...) throws java.io.IOException;
    method public java.nio.channels.AsynchronousFileChannel newAsynchronousFileChannel(java.nio.file.Path, java.util.Set<? extends java.nio.file.OpenOption>, java.util.concurrent.ExecutorService, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public abstract java.nio.channels.SeekableByteChannel newByteChannel(java.nio.file.Path, java.util.Set<? extends java.nio.file.OpenOption>, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public abstract java.nio.file.DirectoryStream<java.nio.file.Path> newDirectoryStream(java.nio.file.Path, java.nio.file.DirectoryStream.Filter<? super java.nio.file.Path>) throws java.io.IOException;
    method public java.nio.channels.FileChannel newFileChannel(java.nio.file.Path, java.util.Set<? extends java.nio.file.OpenOption>, java.nio.file.attribute.FileAttribute<?>...) throws java.io.IOException;
    method public abstract java.nio.file.FileSystem newFileSystem(java.net.URI, java.util.Map<java.lang.String,?>) throws java.io.IOException;
    method public java.nio.file.FileSystem newFileSystem(java.nio.file.Path, java.util.Map<java.lang.String,?>) throws java.io.IOException;
    method public java.io.InputStream newInputStream(java.nio.file.Path, java.nio.file.OpenOption...) throws java.io.IOException;
    method public java.io.OutputStream newOutputStream(java.nio.file.Path, java.nio.file.OpenOption...) throws java.io.IOException;
    method public abstract <A extends java.nio.file.attribute.BasicFileAttributes> A readAttributes(java.nio.file.Path, Class<A>, java.nio.file.LinkOption...) throws java.io.IOException;
    method public abstract java.util.Map<java.lang.String,java.lang.Object> readAttributes(java.nio.file.Path, String, java.nio.file.LinkOption...) throws java.io.IOException;
    method public java.nio.file.Path readSymbolicLink(java.nio.file.Path) throws java.io.IOException;
    method public abstract void setAttribute(java.nio.file.Path, String, Object, java.nio.file.LinkOption...) throws java.io.IOException;
  }

  public abstract class FileTypeDetector {
    ctor protected FileTypeDetector();
    method public abstract String probeContentType(java.nio.file.Path) throws java.io.IOException;
  }

}

package java.security {

  public final class AccessControlContext {
    ctor public AccessControlContext(java.security.ProtectionDomain[]);
    ctor public AccessControlContext(java.security.AccessControlContext, java.security.DomainCombiner);
    method public void checkPermission(java.security.Permission) throws java.security.AccessControlException;
    method public java.security.DomainCombiner getDomainCombiner();
  }

  public class AccessControlException extends java.lang.SecurityException {
    ctor public AccessControlException(String);
    ctor public AccessControlException(String, java.security.Permission);
    method public java.security.Permission getPermission();
  }

  public final class AccessController {
    method public static void checkPermission(java.security.Permission) throws java.security.AccessControlException;
    method public static <T> T doPrivileged(java.security.PrivilegedAction<T>);
    method public static <T> T doPrivileged(java.security.PrivilegedAction<T>, java.security.AccessControlContext);
    method public static <T> T doPrivileged(java.security.PrivilegedExceptionAction<T>) throws java.security.PrivilegedActionException;
    method public static <T> T doPrivileged(java.security.PrivilegedExceptionAction<T>, java.security.AccessControlContext) throws java.security.PrivilegedActionException;
    method public static <T> T doPrivilegedWithCombiner(java.security.PrivilegedAction<T>);
    method public static <T> T doPrivilegedWithCombiner(java.security.PrivilegedExceptionAction<T>) throws java.security.PrivilegedActionException;
    method public static java.security.AccessControlContext getContext();
  }

  public interface AlgorithmConstraints {
    method public boolean permits(java.util.Set<java.security.CryptoPrimitive>, String, java.security.AlgorithmParameters);
    method public boolean permits(java.util.Set<java.security.CryptoPrimitive>, java.security.Key);
    method public boolean permits(java.util.Set<java.security.CryptoPrimitive>, String, java.security.Key, java.security.AlgorithmParameters);
  }

  public class AlgorithmParameterGenerator {
    ctor protected AlgorithmParameterGenerator(java.security.AlgorithmParameterGeneratorSpi, java.security.Provider, String);
    method public final java.security.AlgorithmParameters generateParameters();
    method public final String getAlgorithm();
    method public static java.security.AlgorithmParameterGenerator getInstance(String) throws java.security.NoSuchAlgorithmException;
    method public static java.security.AlgorithmParameterGenerator getInstance(String, String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public static java.security.AlgorithmParameterGenerator getInstance(String, java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method public final java.security.Provider getProvider();
    method public final void init(int);
    method public final void init(int, java.security.SecureRandom);
    method public final void init(java.security.spec.AlgorithmParameterSpec) throws java.security.InvalidAlgorithmParameterException;
    method public final void init(java.security.spec.AlgorithmParameterSpec, java.security.SecureRandom) throws java.security.InvalidAlgorithmParameterException;
  }

  public abstract class AlgorithmParameterGeneratorSpi {
    ctor public AlgorithmParameterGeneratorSpi();
    method protected abstract java.security.AlgorithmParameters engineGenerateParameters();
    method protected abstract void engineInit(int, java.security.SecureRandom);
    method protected abstract void engineInit(java.security.spec.AlgorithmParameterSpec, java.security.SecureRandom) throws java.security.InvalidAlgorithmParameterException;
  }

  public class AlgorithmParameters {
    ctor protected AlgorithmParameters(java.security.AlgorithmParametersSpi, java.security.Provider, String);
    method public final String getAlgorithm();
    method public final byte[] getEncoded() throws java.io.IOException;
    method public final byte[] getEncoded(String) throws java.io.IOException;
    method public static java.security.AlgorithmParameters getInstance(String) throws java.security.NoSuchAlgorithmException;
    method public static java.security.AlgorithmParameters getInstance(String, String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public static java.security.AlgorithmParameters getInstance(String, java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method public final <T extends java.security.spec.AlgorithmParameterSpec> T getParameterSpec(Class<T>) throws java.security.spec.InvalidParameterSpecException;
    method public final java.security.Provider getProvider();
    method public final void init(java.security.spec.AlgorithmParameterSpec) throws java.security.spec.InvalidParameterSpecException;
    method public final void init(byte[]) throws java.io.IOException;
    method public final void init(byte[], String) throws java.io.IOException;
    method public final String toString();
  }

  public abstract class AlgorithmParametersSpi {
    ctor public AlgorithmParametersSpi();
    method protected abstract byte[] engineGetEncoded() throws java.io.IOException;
    method protected abstract byte[] engineGetEncoded(String) throws java.io.IOException;
    method protected abstract <T extends java.security.spec.AlgorithmParameterSpec> T engineGetParameterSpec(Class<T>) throws java.security.spec.InvalidParameterSpecException;
    method protected abstract void engineInit(java.security.spec.AlgorithmParameterSpec) throws java.security.spec.InvalidParameterSpecException;
    method protected abstract void engineInit(byte[]) throws java.io.IOException;
    method protected abstract void engineInit(byte[], String) throws java.io.IOException;
    method protected abstract String engineToString();
  }

  public final class AllPermission extends java.security.Permission {
    ctor public AllPermission();
    ctor public AllPermission(String, String);
    method public String getActions();
    method public boolean implies(java.security.Permission);
  }

  public abstract class AuthProvider extends java.security.Provider {
    ctor protected AuthProvider(String, double, String);
    method public abstract void login(javax.security.auth.Subject, javax.security.auth.callback.CallbackHandler) throws javax.security.auth.login.LoginException;
    method public abstract void logout() throws javax.security.auth.login.LoginException;
    method public abstract void setCallbackHandler(javax.security.auth.callback.CallbackHandler);
  }

  public abstract class BasicPermission extends java.security.Permission implements java.io.Serializable {
    ctor public BasicPermission(String);
    ctor public BasicPermission(String, String);
    method public String getActions();
    method public boolean implies(java.security.Permission);
  }

  @Deprecated public interface Certificate {
    method @Deprecated public void decode(java.io.InputStream) throws java.io.IOException, java.security.KeyException;
    method @Deprecated public void encode(java.io.OutputStream) throws java.io.IOException, java.security.KeyException;
    method @Deprecated public String getFormat();
    method @Deprecated public java.security.Principal getGuarantor();
    method @Deprecated public java.security.Principal getPrincipal();
    method @Deprecated public java.security.PublicKey getPublicKey();
    method @Deprecated public String toString(boolean);
  }

  public final class CodeSigner implements java.io.Serializable {
    ctor public CodeSigner(java.security.cert.CertPath, java.security.Timestamp);
    method public java.security.cert.CertPath getSignerCertPath();
    method public java.security.Timestamp getTimestamp();
  }

  public class CodeSource implements java.io.Serializable {
    ctor public CodeSource(java.net.URL, java.security.cert.Certificate[]);
    ctor public CodeSource(java.net.URL, java.security.CodeSigner[]);
    method public final java.security.cert.Certificate[] getCertificates();
    method public final java.security.CodeSigner[] getCodeSigners();
    method public final java.net.URL getLocation();
    method public boolean implies(java.security.CodeSource);
  }

  public enum CryptoPrimitive {
    enum_constant public static final java.security.CryptoPrimitive BLOCK_CIPHER;
    enum_constant public static final java.security.CryptoPrimitive KEY_AGREEMENT;
    enum_constant public static final java.security.CryptoPrimitive KEY_ENCAPSULATION;
    enum_constant public static final java.security.CryptoPrimitive KEY_WRAP;
    enum_constant public static final java.security.CryptoPrimitive MAC;
    enum_constant public static final java.security.CryptoPrimitive MESSAGE_DIGEST;
    enum_constant public static final java.security.CryptoPrimitive PUBLIC_KEY_ENCRYPTION;
    enum_constant public static final java.security.CryptoPrimitive SECURE_RANDOM;
    enum_constant public static final java.security.CryptoPrimitive SIGNATURE;
    enum_constant public static final java.security.CryptoPrimitive STREAM_CIPHER;
  }

  public class DigestException extends java.security.GeneralSecurityException {
    ctor public DigestException();
    ctor public DigestException(String);
    ctor public DigestException(String, Throwable);
    ctor public DigestException(Throwable);
  }

  public class DigestInputStream extends java.io.FilterInputStream {
    ctor public DigestInputStream(java.io.InputStream, java.security.MessageDigest);
    method public java.security.MessageDigest getMessageDigest();
    method public void on(boolean);
    method public void setMessageDigest(java.security.MessageDigest);
    field protected java.security.MessageDigest digest;
  }

  public class DigestOutputStream extends java.io.FilterOutputStream {
    ctor public DigestOutputStream(java.io.OutputStream, java.security.MessageDigest);
    method public java.security.MessageDigest getMessageDigest();
    method public void on(boolean);
    method public void setMessageDigest(java.security.MessageDigest);
    field protected java.security.MessageDigest digest;
  }

  public interface DomainCombiner {
    method public java.security.ProtectionDomain[] combine(java.security.ProtectionDomain[], java.security.ProtectionDomain[]);
  }

  public final class DomainLoadStoreParameter implements java.security.KeyStore.LoadStoreParameter {
    ctor public DomainLoadStoreParameter(java.net.URI, java.util.Map<java.lang.String,java.security.KeyStore.ProtectionParameter>);
    method public java.net.URI getConfiguration();
    method public java.security.KeyStore.ProtectionParameter getProtectionParameter();
    method public java.util.Map<java.lang.String,java.security.KeyStore.ProtectionParameter> getProtectionParams();
  }

  @FlaggedApi("com.android.libcore.v_apis") public class DrbgParameters {
    method public static java.security.DrbgParameters.Instantiation instantiation(int, java.security.DrbgParameters.Capability, byte[]);
    method public static java.security.DrbgParameters.NextBytes nextBytes(int, boolean, byte[]);
    method public static java.security.DrbgParameters.Reseed reseed(boolean, byte[]);
  }

  @FlaggedApi("com.android.libcore.v_apis") public enum DrbgParameters.Capability {
    method public boolean supportsPredictionResistance();
    method public boolean supportsReseeding();
    enum_constant public static final java.security.DrbgParameters.Capability NONE;
    enum_constant public static final java.security.DrbgParameters.Capability PR_AND_RESEED;
    enum_constant public static final java.security.DrbgParameters.Capability RESEED_ONLY;
  }

  @FlaggedApi("com.android.libcore.v_apis") public static final class DrbgParameters.Instantiation implements java.security.SecureRandomParameters {
    method public java.security.DrbgParameters.Capability getCapability();
    method public byte[] getPersonalizationString();
    method public int getStrength();
  }

  @FlaggedApi("com.android.libcore.v_apis") public static final class DrbgParameters.NextBytes implements java.security.SecureRandomParameters {
    method public byte[] getAdditionalInput();
    method public boolean getPredictionResistance();
    method public int getStrength();
  }

  @FlaggedApi("com.android.libcore.v_apis") public static final class DrbgParameters.Reseed implements java.security.SecureRandomParameters {
    method public byte[] getAdditionalInput();
    method public boolean getPredictionResistance();
  }

  public class GeneralSecurityException extends java.lang.Exception {
    ctor public GeneralSecurityException();
    ctor public GeneralSecurityException(String);
    ctor public GeneralSecurityException(String, Throwable);
    ctor public GeneralSecurityException(Throwable);
  }

  public interface Guard {
    method public void checkGuard(Object) throws java.lang.SecurityException;
  }

  public class GuardedObject implements java.io.Serializable {
    ctor public GuardedObject(Object, java.security.Guard);
    method public Object getObject() throws java.lang.SecurityException;
  }

  @Deprecated public abstract class Identity implements java.security.Principal java.io.Serializable {
    ctor @Deprecated protected Identity();
    ctor @Deprecated public Identity(String, java.security.IdentityScope) throws java.security.KeyManagementException;
    ctor @Deprecated public Identity(String);
    method @Deprecated public void addCertificate(java.security.Certificate) throws java.security.KeyManagementException;
    method @Deprecated public java.security.Certificate[] certificates();
    method @Deprecated public final boolean equals(Object);
    method @Deprecated public String getInfo();
    method @Deprecated public final String getName();
    method @Deprecated public java.security.PublicKey getPublicKey();
    method @Deprecated public final java.security.IdentityScope getScope();
    method @Deprecated public int hashCode();
    method @Deprecated protected boolean identityEquals(java.security.Identity);
    method @Deprecated public void removeCertificate(java.security.Certificate) throws java.security.KeyManagementException;
    method @Deprecated public void setInfo(String);
    method @Deprecated public void setPublicKey(java.security.PublicKey) throws java.security.KeyManagementException;
    method @Deprecated public String toString();
    method @Deprecated public String toString(boolean);
  }

  @Deprecated public abstract class IdentityScope extends java.security.Identity {
    ctor @Deprecated protected IdentityScope();
    ctor @Deprecated public IdentityScope(String);
    ctor @Deprecated public IdentityScope(String, java.security.IdentityScope) throws java.security.KeyManagementException;
    method @Deprecated public abstract void addIdentity(java.security.Identity) throws java.security.KeyManagementException;
    method @Deprecated public abstract java.security.Identity getIdentity(String);
    method @Deprecated public java.security.Identity getIdentity(java.security.Principal);
    method @Deprecated public abstract java.security.Identity getIdentity(java.security.PublicKey);
    method @Deprecated public static java.security.IdentityScope getSystemScope();
    method @Deprecated public abstract java.util.Enumeration<java.security.Identity> identities();
    method @Deprecated public abstract void removeIdentity(java.security.Identity) throws java.security.KeyManagementException;
    method @Deprecated protected static void setSystemScope(java.security.IdentityScope);
    method @Deprecated public abstract int size();
  }

  public class InvalidAlgorithmParameterException extends java.security.GeneralSecurityException {
    ctor public InvalidAlgorithmParameterException();
    ctor public InvalidAlgorithmParameterException(String);
    ctor public InvalidAlgorithmParameterException(String, Throwable);
    ctor public InvalidAlgorithmParameterException(Throwable);
  }

  public class InvalidKeyException extends java.security.KeyException {
    ctor public InvalidKeyException();
    ctor public InvalidKeyException(String);
    ctor public InvalidKeyException(String, Throwable);
    ctor public InvalidKeyException(Throwable);
  }

  public class InvalidParameterException extends java.lang.IllegalArgumentException {
    ctor public InvalidParameterException();
    ctor public InvalidParameterException(String);
  }

  public interface Key extends java.io.Serializable {
    method public String getAlgorithm();
    method public byte[] getEncoded();
    method public String getFormat();
    field @Deprecated @java.io.Serial public static final long serialVersionUID = 6603384152749567654L; // 0x5ba3eee69414eea6L
  }

  public class KeyException extends java.security.GeneralSecurityException {
    ctor public KeyException();
    ctor public KeyException(String);
    ctor public KeyException(String, Throwable);
    ctor public KeyException(Throwable);
  }

  public class KeyFactory {
    ctor protected KeyFactory(java.security.KeyFactorySpi, java.security.Provider, String);
    method public final java.security.PrivateKey generatePrivate(java.security.spec.KeySpec) throws java.security.spec.InvalidKeySpecException;
    method public final java.security.PublicKey generatePublic(java.security.spec.KeySpec) throws java.security.spec.InvalidKeySpecException;
    method public final String getAlgorithm();
    method public static java.security.KeyFactory getInstance(String) throws java.security.NoSuchAlgorithmException;
    method public static java.security.KeyFactory getInstance(String, String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public static java.security.KeyFactory getInstance(String, java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method public final <T extends java.security.spec.KeySpec> T getKeySpec(java.security.Key, Class<T>) throws java.security.spec.InvalidKeySpecException;
    method public final java.security.Provider getProvider();
    method public final java.security.Key translateKey(java.security.Key) throws java.security.InvalidKeyException;
  }

  public abstract class KeyFactorySpi {
    ctor public KeyFactorySpi();
    method protected abstract java.security.PrivateKey engineGeneratePrivate(java.security.spec.KeySpec) throws java.security.spec.InvalidKeySpecException;
    method protected abstract java.security.PublicKey engineGeneratePublic(java.security.spec.KeySpec) throws java.security.spec.InvalidKeySpecException;
    method protected abstract <T extends java.security.spec.KeySpec> T engineGetKeySpec(java.security.Key, Class<T>) throws java.security.spec.InvalidKeySpecException;
    method protected abstract java.security.Key engineTranslateKey(java.security.Key) throws java.security.InvalidKeyException;
  }

  public class KeyManagementException extends java.security.KeyException {
    ctor public KeyManagementException();
    ctor public KeyManagementException(String);
    ctor public KeyManagementException(String, Throwable);
    ctor public KeyManagementException(Throwable);
  }

  public final class KeyPair implements java.io.Serializable {
    ctor public KeyPair(java.security.PublicKey, java.security.PrivateKey);
    method public java.security.PrivateKey getPrivate();
    method public java.security.PublicKey getPublic();
  }

  public abstract class KeyPairGenerator extends java.security.KeyPairGeneratorSpi {
    ctor protected KeyPairGenerator(String);
    method public final java.security.KeyPair genKeyPair();
    method public java.security.KeyPair generateKeyPair();
    method public String getAlgorithm();
    method public static java.security.KeyPairGenerator getInstance(String) throws java.security.NoSuchAlgorithmException;
    method public static java.security.KeyPairGenerator getInstance(String, String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public static java.security.KeyPairGenerator getInstance(String, java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method public final java.security.Provider getProvider();
    method public void initialize(int);
    method public void initialize(int, java.security.SecureRandom);
    method public void initialize(java.security.spec.AlgorithmParameterSpec) throws java.security.InvalidAlgorithmParameterException;
  }

  public abstract class KeyPairGeneratorSpi {
    ctor public KeyPairGeneratorSpi();
    method public abstract java.security.KeyPair generateKeyPair();
    method public abstract void initialize(int, java.security.SecureRandom);
    method public void initialize(java.security.spec.AlgorithmParameterSpec, java.security.SecureRandom) throws java.security.InvalidAlgorithmParameterException;
  }

  public class KeyRep implements java.io.Serializable {
    ctor public KeyRep(java.security.KeyRep.Type, String, String, byte[]);
    method protected Object readResolve() throws java.io.ObjectStreamException;
  }

  public enum KeyRep.Type {
    enum_constant public static final java.security.KeyRep.Type PRIVATE;
    enum_constant public static final java.security.KeyRep.Type PUBLIC;
    enum_constant public static final java.security.KeyRep.Type SECRET;
  }

  public class KeyStore {
    ctor protected KeyStore(java.security.KeyStoreSpi, java.security.Provider, String);
    method public final java.util.Enumeration<java.lang.String> aliases() throws java.security.KeyStoreException;
    method public final boolean containsAlias(String) throws java.security.KeyStoreException;
    method public final void deleteEntry(String) throws java.security.KeyStoreException;
    method public final boolean entryInstanceOf(String, Class<? extends java.security.KeyStore.Entry>) throws java.security.KeyStoreException;
    method public final java.security.cert.Certificate getCertificate(String) throws java.security.KeyStoreException;
    method public final String getCertificateAlias(java.security.cert.Certificate) throws java.security.KeyStoreException;
    method public final java.security.cert.Certificate[] getCertificateChain(String) throws java.security.KeyStoreException;
    method public final java.util.Date getCreationDate(String) throws java.security.KeyStoreException;
    method public static final String getDefaultType();
    method public final java.security.KeyStore.Entry getEntry(String, java.security.KeyStore.ProtectionParameter) throws java.security.KeyStoreException, java.security.NoSuchAlgorithmException, java.security.UnrecoverableEntryException;
    method public static java.security.KeyStore getInstance(String) throws java.security.KeyStoreException;
    method public static java.security.KeyStore getInstance(String, String) throws java.security.KeyStoreException, java.security.NoSuchProviderException;
    method public static java.security.KeyStore getInstance(String, java.security.Provider) throws java.security.KeyStoreException;
    method public static final java.security.KeyStore getInstance(java.io.File, char[]) throws java.security.cert.CertificateException, java.io.IOException, java.security.KeyStoreException, java.security.NoSuchAlgorithmException;
    method public static final java.security.KeyStore getInstance(java.io.File, java.security.KeyStore.LoadStoreParameter) throws java.security.cert.CertificateException, java.io.IOException, java.security.KeyStoreException, java.security.NoSuchAlgorithmException;
    method public final java.security.Key getKey(String, char[]) throws java.security.KeyStoreException, java.security.NoSuchAlgorithmException, java.security.UnrecoverableKeyException;
    method public final java.security.Provider getProvider();
    method public final String getType();
    method public final boolean isCertificateEntry(String) throws java.security.KeyStoreException;
    method public final boolean isKeyEntry(String) throws java.security.KeyStoreException;
    method public final void load(java.io.InputStream, char[]) throws java.security.cert.CertificateException, java.io.IOException, java.security.NoSuchAlgorithmException;
    method public final void load(java.security.KeyStore.LoadStoreParameter) throws java.security.cert.CertificateException, java.io.IOException, java.security.NoSuchAlgorithmException;
    method public final void setCertificateEntry(String, java.security.cert.Certificate) throws java.security.KeyStoreException;
    method public final void setEntry(String, java.security.KeyStore.Entry, java.security.KeyStore.ProtectionParameter) throws java.security.KeyStoreException;
    method public final void setKeyEntry(String, java.security.Key, char[], java.security.cert.Certificate[]) throws java.security.KeyStoreException;
    method public final void setKeyEntry(String, byte[], java.security.cert.Certificate[]) throws java.security.KeyStoreException;
    method public final int size() throws java.security.KeyStoreException;
    method public final void store(java.io.OutputStream, char[]) throws java.security.cert.CertificateException, java.io.IOException, java.security.KeyStoreException, java.security.NoSuchAlgorithmException;
    method public final void store(java.security.KeyStore.LoadStoreParameter) throws java.security.cert.CertificateException, java.io.IOException, java.security.KeyStoreException, java.security.NoSuchAlgorithmException;
  }

  public abstract static class KeyStore.Builder {
    ctor protected KeyStore.Builder();
    method public abstract java.security.KeyStore getKeyStore() throws java.security.KeyStoreException;
    method public abstract java.security.KeyStore.ProtectionParameter getProtectionParameter(String) throws java.security.KeyStoreException;
    method public static java.security.KeyStore.Builder newInstance(java.security.KeyStore, java.security.KeyStore.ProtectionParameter);
    method public static java.security.KeyStore.Builder newInstance(String, java.security.Provider, java.io.File, java.security.KeyStore.ProtectionParameter);
    method public static java.security.KeyStore.Builder newInstance(java.io.File, java.security.KeyStore.ProtectionParameter);
    method public static java.security.KeyStore.Builder newInstance(String, java.security.Provider, java.security.KeyStore.ProtectionParameter);
  }

  public static class KeyStore.CallbackHandlerProtection implements java.security.KeyStore.ProtectionParameter {
    ctor public KeyStore.CallbackHandlerProtection(javax.security.auth.callback.CallbackHandler);
    method public javax.security.auth.callback.CallbackHandler getCallbackHandler();
  }

  public static interface KeyStore.Entry {
    method public default java.util.Set<java.security.KeyStore.Entry.Attribute> getAttributes();
  }

  public static interface KeyStore.Entry.Attribute {
    method public String getName();
    method public String getValue();
  }

  public static interface KeyStore.LoadStoreParameter {
    method public java.security.KeyStore.ProtectionParameter getProtectionParameter();
  }

  public static class KeyStore.PasswordProtection implements javax.security.auth.Destroyable java.security.KeyStore.ProtectionParameter {
    ctor public KeyStore.PasswordProtection(char[]);
    ctor public KeyStore.PasswordProtection(char[], String, java.security.spec.AlgorithmParameterSpec);
    method public void destroy() throws javax.security.auth.DestroyFailedException;
    method public char[] getPassword();
    method public String getProtectionAlgorithm();
    method public java.security.spec.AlgorithmParameterSpec getProtectionParameters();
    method public boolean isDestroyed();
  }

  public static final class KeyStore.PrivateKeyEntry implements java.security.KeyStore.Entry {
    ctor public KeyStore.PrivateKeyEntry(java.security.PrivateKey, java.security.cert.Certificate[]);
    ctor public KeyStore.PrivateKeyEntry(java.security.PrivateKey, java.security.cert.Certificate[], java.util.Set<java.security.KeyStore.Entry.Attribute>);
    method public java.util.Set<java.security.KeyStore.Entry.Attribute> getAttributes();
    method public java.security.cert.Certificate getCertificate();
    method public java.security.cert.Certificate[] getCertificateChain();
    method public java.security.PrivateKey getPrivateKey();
  }

  public static interface KeyStore.ProtectionParameter {
  }

  public static final class KeyStore.SecretKeyEntry implements java.security.KeyStore.Entry {
    ctor public KeyStore.SecretKeyEntry(javax.crypto.SecretKey);
    ctor public KeyStore.SecretKeyEntry(javax.crypto.SecretKey, java.util.Set<java.security.KeyStore.Entry.Attribute>);
    method public java.util.Set<java.security.KeyStore.Entry.Attribute> getAttributes();
    method public javax.crypto.SecretKey getSecretKey();
  }

  public static final class KeyStore.TrustedCertificateEntry implements java.security.KeyStore.Entry {
    ctor public KeyStore.TrustedCertificateEntry(java.security.cert.Certificate);
    ctor public KeyStore.TrustedCertificateEntry(java.security.cert.Certificate, java.util.Set<java.security.KeyStore.Entry.Attribute>);
    method public java.util.Set<java.security.KeyStore.Entry.Attribute> getAttributes();
    method public java.security.cert.Certificate getTrustedCertificate();
  }

  public class KeyStoreException extends java.security.GeneralSecurityException {
    ctor public KeyStoreException();
    ctor public KeyStoreException(String);
    ctor public KeyStoreException(String, Throwable);
    ctor public KeyStoreException(Throwable);
  }

  public abstract class KeyStoreSpi {
    ctor public KeyStoreSpi();
    method public abstract java.util.Enumeration<java.lang.String> engineAliases();
    method public abstract boolean engineContainsAlias(String);
    method public abstract void engineDeleteEntry(String) throws java.security.KeyStoreException;
    method public boolean engineEntryInstanceOf(String, Class<? extends java.security.KeyStore.Entry>);
    method public abstract java.security.cert.Certificate engineGetCertificate(String);
    method public abstract String engineGetCertificateAlias(java.security.cert.Certificate);
    method public abstract java.security.cert.Certificate[] engineGetCertificateChain(String);
    method public abstract java.util.Date engineGetCreationDate(String);
    method public java.security.KeyStore.Entry engineGetEntry(String, java.security.KeyStore.ProtectionParameter) throws java.security.KeyStoreException, java.security.NoSuchAlgorithmException, java.security.UnrecoverableEntryException;
    method public abstract java.security.Key engineGetKey(String, char[]) throws java.security.NoSuchAlgorithmException, java.security.UnrecoverableKeyException;
    method public abstract boolean engineIsCertificateEntry(String);
    method public abstract boolean engineIsKeyEntry(String);
    method public abstract void engineLoad(java.io.InputStream, char[]) throws java.security.cert.CertificateException, java.io.IOException, java.security.NoSuchAlgorithmException;
    method public void engineLoad(java.security.KeyStore.LoadStoreParameter) throws java.security.cert.CertificateException, java.io.IOException, java.security.NoSuchAlgorithmException;
    method public boolean engineProbe(java.io.InputStream) throws java.io.IOException;
    method public abstract void engineSetCertificateEntry(String, java.security.cert.Certificate) throws java.security.KeyStoreException;
    method public void engineSetEntry(String, java.security.KeyStore.Entry, java.security.KeyStore.ProtectionParameter) throws java.security.KeyStoreException;
    method public abstract void engineSetKeyEntry(String, java.security.Key, char[], java.security.cert.Certificate[]) throws java.security.KeyStoreException;
    method public abstract void engineSetKeyEntry(String, byte[], java.security.cert.Certificate[]) throws java.security.KeyStoreException;
    method public abstract int engineSize();
    method public abstract void engineStore(java.io.OutputStream, char[]) throws java.security.cert.CertificateException, java.io.IOException, java.security.NoSuchAlgorithmException;
    method public void engineStore(java.security.KeyStore.LoadStoreParameter) throws java.security.cert.CertificateException, java.io.IOException, java.security.NoSuchAlgorithmException;
  }

  public abstract class MessageDigest extends java.security.MessageDigestSpi {
    ctor protected MessageDigest(@NonNull String);
    method @NonNull public byte[] digest();
    method public int digest(@NonNull byte[], int, int) throws java.security.DigestException;
    method @NonNull public byte[] digest(@NonNull byte[]);
    method @NonNull public final String getAlgorithm();
    method public final int getDigestLength();
    method @NonNull public static java.security.MessageDigest getInstance(@NonNull String) throws java.security.NoSuchAlgorithmException;
    method @NonNull public static java.security.MessageDigest getInstance(@NonNull String, @NonNull String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method @NonNull public static java.security.MessageDigest getInstance(@NonNull String, @NonNull java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method @NonNull public final java.security.Provider getProvider();
    method public static boolean isEqual(@Nullable byte[], @Nullable byte[]);
    method public void reset();
    method public void update(byte);
    method public void update(@NonNull byte[], int, int);
    method public void update(@NonNull byte[]);
    method public final void update(@NonNull java.nio.ByteBuffer);
  }

  public abstract class MessageDigestSpi {
    ctor public MessageDigestSpi();
    method public Object clone() throws java.lang.CloneNotSupportedException;
    method protected abstract byte[] engineDigest();
    method protected int engineDigest(byte[], int, int) throws java.security.DigestException;
    method protected int engineGetDigestLength();
    method protected abstract void engineReset();
    method protected abstract void engineUpdate(byte);
    method protected abstract void engineUpdate(byte[], int, int);
    method protected void engineUpdate(java.nio.ByteBuffer);
  }

  public class NoSuchAlgorithmException extends java.security.GeneralSecurityException {
    ctor public NoSuchAlgorithmException();
    ctor public NoSuchAlgorithmException(String);
    ctor public NoSuchAlgorithmException(String, Throwable);
    ctor public NoSuchAlgorithmException(Throwable);
  }

  public class NoSuchProviderException extends java.security.GeneralSecurityException {
    ctor public NoSuchProviderException();
    ctor public NoSuchProviderException(String);
  }

  public final class PKCS12Attribute implements java.security.KeyStore.Entry.Attribute {
    ctor public PKCS12Attribute(String, String);
    ctor public PKCS12Attribute(byte[]);
    method public byte[] getEncoded();
    method public String getName();
    method public String getValue();
  }

  public abstract class Permission implements java.security.Guard java.io.Serializable {
    ctor public Permission(String);
    method public void checkGuard(Object) throws java.lang.SecurityException;
    method public abstract String getActions();
    method public final String getName();
    method public abstract boolean implies(java.security.Permission);
    method public java.security.PermissionCollection newPermissionCollection();
  }

  public abstract class PermissionCollection implements java.io.Serializable {
    ctor public PermissionCollection();
    method public abstract void add(java.security.Permission);
    method public abstract java.util.Enumeration<java.security.Permission> elements();
    method public abstract boolean implies(java.security.Permission);
    method public boolean isReadOnly();
    method public void setReadOnly();
  }

  public final class Permissions extends java.security.PermissionCollection implements java.io.Serializable {
    ctor public Permissions();
    method public void add(java.security.Permission);
    method public java.util.Enumeration<java.security.Permission> elements();
    method public boolean implies(java.security.Permission);
  }

  public abstract class Policy {
    ctor public Policy();
    method public static java.security.Policy getInstance(String, java.security.Policy.Parameters) throws java.security.NoSuchAlgorithmException;
    method public static java.security.Policy getInstance(String, java.security.Policy.Parameters, String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public static java.security.Policy getInstance(String, java.security.Policy.Parameters, java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method public java.security.Policy.Parameters getParameters();
    method public java.security.PermissionCollection getPermissions(java.security.CodeSource);
    method public java.security.PermissionCollection getPermissions(java.security.ProtectionDomain);
    method public static java.security.Policy getPolicy();
    method public java.security.Provider getProvider();
    method public String getType();
    method public boolean implies(java.security.ProtectionDomain, java.security.Permission);
    method public void refresh();
    method public static void setPolicy(java.security.Policy);
    field public static final java.security.PermissionCollection UNSUPPORTED_EMPTY_COLLECTION;
  }

  public static interface Policy.Parameters {
  }

  public abstract class PolicySpi {
    ctor public PolicySpi();
    method protected java.security.PermissionCollection engineGetPermissions(java.security.CodeSource);
    method protected java.security.PermissionCollection engineGetPermissions(java.security.ProtectionDomain);
    method protected abstract boolean engineImplies(java.security.ProtectionDomain, java.security.Permission);
    method protected void engineRefresh();
  }

  public interface Principal {
    method public boolean equals(Object);
    method public String getName();
    method public int hashCode();
    method public default boolean implies(javax.security.auth.Subject);
    method public String toString();
  }

  public interface PrivateKey extends java.security.Key javax.security.auth.Destroyable {
    field @Deprecated @java.io.Serial public static final long serialVersionUID = 6034044314589513430L; // 0x53bd3b559a12c6d6L
  }

  public interface PrivilegedAction<T> {
    method public T run();
  }

  public class PrivilegedActionException extends java.lang.Exception {
    ctor public PrivilegedActionException(Exception);
    method public Exception getException();
  }

  public interface PrivilegedExceptionAction<T> {
    method public T run() throws java.lang.Exception;
  }

  public class ProtectionDomain {
    ctor public ProtectionDomain(java.security.CodeSource, java.security.PermissionCollection);
    ctor public ProtectionDomain(java.security.CodeSource, java.security.PermissionCollection, ClassLoader, java.security.Principal[]);
    method public final ClassLoader getClassLoader();
    method public final java.security.CodeSource getCodeSource();
    method public final java.security.PermissionCollection getPermissions();
    method public final java.security.Principal[] getPrincipals();
    method public boolean implies(java.security.Permission);
  }

  public abstract class Provider extends java.util.Properties {
    ctor protected Provider(String, double, String);
    method public String getInfo();
    method public String getName();
    method public java.security.Provider.Service getService(String, String);
    method public java.util.Set<java.security.Provider.Service> getServices();
    method public double getVersion();
    method protected void putService(java.security.Provider.Service);
    method protected void removeService(java.security.Provider.Service);
  }

  public static class Provider.Service {
    ctor public Provider.Service(java.security.Provider, String, String, String, java.util.List<java.lang.String>, java.util.Map<java.lang.String,java.lang.String>);
    method public final String getAlgorithm();
    method public final String getAttribute(String);
    method public final String getClassName();
    method public final java.security.Provider getProvider();
    method public final String getType();
    method public Object newInstance(Object) throws java.security.NoSuchAlgorithmException;
    method public boolean supportsParameter(Object);
  }

  public class ProviderException extends java.lang.RuntimeException {
    ctor public ProviderException();
    ctor public ProviderException(String);
    ctor public ProviderException(String, Throwable);
    ctor public ProviderException(Throwable);
  }

  public interface PublicKey extends java.security.Key {
    field @Deprecated @java.io.Serial public static final long serialVersionUID = 7187392471159151072L; // 0x63bebf5f40c219e0L
  }

  public class SecureClassLoader extends java.lang.ClassLoader {
    ctor protected SecureClassLoader(ClassLoader);
    ctor protected SecureClassLoader();
    method protected final Class<?> defineClass(String, byte[], int, int, java.security.CodeSource);
    method protected final Class<?> defineClass(String, java.nio.ByteBuffer, java.security.CodeSource);
    method protected java.security.PermissionCollection getPermissions(java.security.CodeSource);
  }

  public class SecureRandom extends java.util.Random {
    ctor public SecureRandom();
    ctor public SecureRandom(byte[]);
    ctor protected SecureRandom(java.security.SecureRandomSpi, java.security.Provider);
    method public byte[] generateSeed(int);
    method public String getAlgorithm();
    method public static java.security.SecureRandom getInstance(String) throws java.security.NoSuchAlgorithmException;
    method public static java.security.SecureRandom getInstance(String, String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public static java.security.SecureRandom getInstance(String, java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method @FlaggedApi("com.android.libcore.v_apis") public static java.security.SecureRandom getInstance(String, java.security.SecureRandomParameters) throws java.security.NoSuchAlgorithmException;
    method @FlaggedApi("com.android.libcore.v_apis") public static java.security.SecureRandom getInstance(String, java.security.SecureRandomParameters, String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method @FlaggedApi("com.android.libcore.v_apis") public static java.security.SecureRandom getInstance(String, java.security.SecureRandomParameters, java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method public static java.security.SecureRandom getInstanceStrong() throws java.security.NoSuchAlgorithmException;
    method @FlaggedApi("com.android.libcore.v_apis") public java.security.SecureRandomParameters getParameters();
    method public final java.security.Provider getProvider();
    method public static byte[] getSeed(int);
    method protected final int next(int);
    method @FlaggedApi("com.android.libcore.v_apis") public void nextBytes(byte[], java.security.SecureRandomParameters);
    method @FlaggedApi("com.android.libcore.v_apis") public void reseed();
    method @FlaggedApi("com.android.libcore.v_apis") public void reseed(java.security.SecureRandomParameters);
    method public void setSeed(byte[]);
  }

  @FlaggedApi("com.android.libcore.v_apis") public interface SecureRandomParameters {
  }

  public abstract class SecureRandomSpi implements java.io.Serializable {
    ctor public SecureRandomSpi();
    ctor @FlaggedApi("com.android.libcore.v_apis") protected SecureRandomSpi(java.security.SecureRandomParameters);
    method protected abstract byte[] engineGenerateSeed(int);
    method @FlaggedApi("com.android.libcore.v_apis") protected java.security.SecureRandomParameters engineGetParameters();
    method protected abstract void engineNextBytes(byte[]);
    method @FlaggedApi("com.android.libcore.v_apis") protected void engineNextBytes(byte[], java.security.SecureRandomParameters);
    method @FlaggedApi("com.android.libcore.v_apis") protected void engineReseed(java.security.SecureRandomParameters);
    method protected abstract void engineSetSeed(byte[]);
  }

  public final class Security {
    method public static int addProvider(java.security.Provider);
    method @Deprecated public static String getAlgorithmProperty(String, String);
    method public static java.util.Set<java.lang.String> getAlgorithms(String);
    method public static String getProperty(String);
    method public static java.security.Provider getProvider(String);
    method public static java.security.Provider[] getProviders();
    method public static java.security.Provider[] getProviders(String);
    method public static java.security.Provider[] getProviders(java.util.Map<java.lang.String,java.lang.String>);
    method public static int insertProviderAt(java.security.Provider, int);
    method public static void removeProvider(String);
    method public static void setProperty(String, String);
  }

  public final class SecurityPermission extends java.security.BasicPermission {
    ctor public SecurityPermission(String);
    ctor public SecurityPermission(String, String);
  }

  public abstract class Signature extends java.security.SignatureSpi {
    ctor protected Signature(String);
    method public final String getAlgorithm();
    method public static java.security.Signature getInstance(String) throws java.security.NoSuchAlgorithmException;
    method public static java.security.Signature getInstance(String, String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public static java.security.Signature getInstance(String, java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method @Deprecated public final Object getParameter(String) throws java.security.InvalidParameterException;
    method public final java.security.AlgorithmParameters getParameters();
    method public final java.security.Provider getProvider();
    method public final void initSign(java.security.PrivateKey) throws java.security.InvalidKeyException;
    method public final void initSign(java.security.PrivateKey, java.security.SecureRandom) throws java.security.InvalidKeyException;
    method public final void initVerify(java.security.PublicKey) throws java.security.InvalidKeyException;
    method public final void initVerify(java.security.cert.Certificate) throws java.security.InvalidKeyException;
    method @Deprecated public final void setParameter(String, Object) throws java.security.InvalidParameterException;
    method public final void setParameter(java.security.spec.AlgorithmParameterSpec) throws java.security.InvalidAlgorithmParameterException;
    method public final byte[] sign() throws java.security.SignatureException;
    method public final int sign(byte[], int, int) throws java.security.SignatureException;
    method public final void update(byte) throws java.security.SignatureException;
    method public final void update(byte[]) throws java.security.SignatureException;
    method public final void update(byte[], int, int) throws java.security.SignatureException;
    method public final void update(java.nio.ByteBuffer) throws java.security.SignatureException;
    method public final boolean verify(byte[]) throws java.security.SignatureException;
    method public final boolean verify(byte[], int, int) throws java.security.SignatureException;
    field protected static final int SIGN = 2; // 0x2
    field protected static final int UNINITIALIZED = 0; // 0x0
    field protected static final int VERIFY = 3; // 0x3
    field protected int state;
  }

  public class SignatureException extends java.security.GeneralSecurityException {
    ctor public SignatureException();
    ctor public SignatureException(String);
    ctor public SignatureException(String, Throwable);
    ctor public SignatureException(Throwable);
  }

  public abstract class SignatureSpi {
    ctor public SignatureSpi();
    method public Object clone() throws java.lang.CloneNotSupportedException;
    method @Deprecated protected abstract Object engineGetParameter(String) throws java.security.InvalidParameterException;
    method protected java.security.AlgorithmParameters engineGetParameters();
    method protected abstract void engineInitSign(java.security.PrivateKey) throws java.security.InvalidKeyException;
    method protected void engineInitSign(java.security.PrivateKey, java.security.SecureRandom) throws java.security.InvalidKeyException;
    method protected abstract void engineInitVerify(java.security.PublicKey) throws java.security.InvalidKeyException;
    method @Deprecated protected abstract void engineSetParameter(String, Object) throws java.security.InvalidParameterException;
    method protected void engineSetParameter(java.security.spec.AlgorithmParameterSpec) throws java.security.InvalidAlgorithmParameterException;
    method protected abstract byte[] engineSign() throws java.security.SignatureException;
    method protected int engineSign(byte[], int, int) throws java.security.SignatureException;
    method protected abstract void engineUpdate(byte) throws java.security.SignatureException;
    method protected abstract void engineUpdate(byte[], int, int) throws java.security.SignatureException;
    method protected void engineUpdate(java.nio.ByteBuffer);
    method protected abstract boolean engineVerify(byte[]) throws java.security.SignatureException;
    method protected boolean engineVerify(byte[], int, int) throws java.security.SignatureException;
    field protected java.security.SecureRandom appRandom;
  }

  public final class SignedObject implements java.io.Serializable {
    ctor public SignedObject(java.io.Serializable, java.security.PrivateKey, java.security.Signature) throws java.io.IOException, java.security.InvalidKeyException, java.security.SignatureException;
    method public String getAlgorithm();
    method public Object getObject() throws java.lang.ClassNotFoundException, java.io.IOException;
    method public byte[] getSignature();
    method public boolean verify(java.security.PublicKey, java.security.Signature) throws java.security.InvalidKeyException, java.security.SignatureException;
  }

  @Deprecated public abstract class Signer extends java.security.Identity {
    ctor @Deprecated protected Signer();
    ctor @Deprecated public Signer(String);
    ctor @Deprecated public Signer(String, java.security.IdentityScope) throws java.security.KeyManagementException;
    method @Deprecated public java.security.PrivateKey getPrivateKey();
    method @Deprecated public final void setKeyPair(java.security.KeyPair) throws java.security.InvalidParameterException, java.security.KeyException;
  }

  public final class Timestamp implements java.io.Serializable {
    ctor public Timestamp(java.util.Date, java.security.cert.CertPath);
    method public java.security.cert.CertPath getSignerCertPath();
    method public java.util.Date getTimestamp();
  }

  public class UnrecoverableEntryException extends java.security.GeneralSecurityException {
    ctor public UnrecoverableEntryException();
    ctor public UnrecoverableEntryException(String);
  }

  public class UnrecoverableKeyException extends java.security.UnrecoverableEntryException {
    ctor public UnrecoverableKeyException();
    ctor public UnrecoverableKeyException(String);
  }

  public final class UnresolvedPermission extends java.security.Permission implements java.io.Serializable {
    ctor public UnresolvedPermission(String, String, String, java.security.cert.Certificate[]);
    method public String getActions();
    method public String getUnresolvedActions();
    method public java.security.cert.Certificate[] getUnresolvedCerts();
    method public String getUnresolvedName();
    method public String getUnresolvedType();
    method public boolean implies(java.security.Permission);
  }

}

package java.security.acl {

  @Deprecated public interface Acl extends java.security.acl.Owner {
    method @Deprecated public boolean addEntry(java.security.Principal, java.security.acl.AclEntry) throws java.security.acl.NotOwnerException;
    method @Deprecated public boolean checkPermission(java.security.Principal, java.security.acl.Permission);
    method @Deprecated public java.util.Enumeration<java.security.acl.AclEntry> entries();
    method @Deprecated public String getName();
    method @Deprecated public java.util.Enumeration<java.security.acl.Permission> getPermissions(java.security.Principal);
    method @Deprecated public boolean removeEntry(java.security.Principal, java.security.acl.AclEntry) throws java.security.acl.NotOwnerException;
    method @Deprecated public void setName(java.security.Principal, String) throws java.security.acl.NotOwnerException;
    method @Deprecated public String toString();
  }

  @Deprecated public interface AclEntry extends java.lang.Cloneable {
    method @Deprecated public boolean addPermission(java.security.acl.Permission);
    method @Deprecated public boolean checkPermission(java.security.acl.Permission);
    method @Deprecated public Object clone();
    method @Deprecated public java.security.Principal getPrincipal();
    method @Deprecated public boolean isNegative();
    method @Deprecated public java.util.Enumeration<java.security.acl.Permission> permissions();
    method @Deprecated public boolean removePermission(java.security.acl.Permission);
    method @Deprecated public void setNegativePermissions();
    method @Deprecated public boolean setPrincipal(java.security.Principal);
    method @Deprecated public String toString();
  }

  @Deprecated public class AclNotFoundException extends java.lang.Exception {
    ctor @Deprecated public AclNotFoundException();
  }

  @Deprecated public interface Group extends java.security.Principal {
    method @Deprecated public boolean addMember(java.security.Principal);
    method @Deprecated public boolean isMember(java.security.Principal);
    method @Deprecated public java.util.Enumeration<? extends java.security.Principal> members();
    method @Deprecated public boolean removeMember(java.security.Principal);
  }

  @Deprecated public class LastOwnerException extends java.lang.Exception {
    ctor @Deprecated public LastOwnerException();
  }

  @Deprecated public class NotOwnerException extends java.lang.Exception {
    ctor @Deprecated public NotOwnerException();
  }

  @Deprecated public interface Owner {
    method @Deprecated public boolean addOwner(java.security.Principal, java.security.Principal) throws java.security.acl.NotOwnerException;
    method @Deprecated public boolean deleteOwner(java.security.Principal, java.security.Principal) throws java.security.acl.LastOwnerException, java.security.acl.NotOwnerException;
    method @Deprecated public boolean isOwner(java.security.Principal);
  }

  @Deprecated public interface Permission {
  }

}

package java.security.cert {

  public abstract class CRL {
    ctor protected CRL(String);
    method public final String getType();
    method public abstract boolean isRevoked(java.security.cert.Certificate);
    method public abstract String toString();
  }

  public class CRLException extends java.security.GeneralSecurityException {
    ctor public CRLException();
    ctor public CRLException(String);
    ctor public CRLException(String, Throwable);
    ctor public CRLException(Throwable);
  }

  public enum CRLReason {
    enum_constant public static final java.security.cert.CRLReason AA_COMPROMISE;
    enum_constant public static final java.security.cert.CRLReason AFFILIATION_CHANGED;
    enum_constant public static final java.security.cert.CRLReason CA_COMPROMISE;
    enum_constant public static final java.security.cert.CRLReason CERTIFICATE_HOLD;
    enum_constant public static final java.security.cert.CRLReason CESSATION_OF_OPERATION;
    enum_constant public static final java.security.cert.CRLReason KEY_COMPROMISE;
    enum_constant public static final java.security.cert.CRLReason PRIVILEGE_WITHDRAWN;
    enum_constant public static final java.security.cert.CRLReason REMOVE_FROM_CRL;
    enum_constant public static final java.security.cert.CRLReason SUPERSEDED;
    enum_constant public static final java.security.cert.CRLReason UNSPECIFIED;
    enum_constant public static final java.security.cert.CRLReason UNUSED;
  }

  public interface CRLSelector extends java.lang.Cloneable {
    method public Object clone();
    method public boolean match(java.security.cert.CRL);
  }

  public abstract class CertPath implements java.io.Serializable {
    ctor protected CertPath(String);
    method public abstract java.util.List<? extends java.security.cert.Certificate> getCertificates();
    method public abstract byte[] getEncoded() throws java.security.cert.CertificateEncodingException;
    method public abstract byte[] getEncoded(String) throws java.security.cert.CertificateEncodingException;
    method public abstract java.util.Iterator<java.lang.String> getEncodings();
    method public String getType();
    method protected Object writeReplace() throws java.io.ObjectStreamException;
  }

  protected static class CertPath.CertPathRep implements java.io.Serializable {
    ctor protected CertPath.CertPathRep(String, byte[]);
    method protected Object readResolve() throws java.io.ObjectStreamException;
  }

  public class CertPathBuilder {
    ctor protected CertPathBuilder(java.security.cert.CertPathBuilderSpi, java.security.Provider, String);
    method public final java.security.cert.CertPathBuilderResult build(java.security.cert.CertPathParameters) throws java.security.cert.CertPathBuilderException, java.security.InvalidAlgorithmParameterException;
    method public final String getAlgorithm();
    method public static final String getDefaultType();
    method public static java.security.cert.CertPathBuilder getInstance(String) throws java.security.NoSuchAlgorithmException;
    method public static java.security.cert.CertPathBuilder getInstance(String, String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public static java.security.cert.CertPathBuilder getInstance(String, java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method public final java.security.Provider getProvider();
    method public final java.security.cert.CertPathChecker getRevocationChecker();
  }

  public class CertPathBuilderException extends java.security.GeneralSecurityException {
    ctor public CertPathBuilderException();
    ctor public CertPathBuilderException(String);
    ctor public CertPathBuilderException(Throwable);
    ctor public CertPathBuilderException(String, Throwable);
  }

  public interface CertPathBuilderResult extends java.lang.Cloneable {
    method public Object clone();
    method public java.security.cert.CertPath getCertPath();
  }

  public abstract class CertPathBuilderSpi {
    ctor public CertPathBuilderSpi();
    method public abstract java.security.cert.CertPathBuilderResult engineBuild(java.security.cert.CertPathParameters) throws java.security.cert.CertPathBuilderException, java.security.InvalidAlgorithmParameterException;
    method public java.security.cert.CertPathChecker engineGetRevocationChecker();
  }

  public interface CertPathChecker {
    method public void check(java.security.cert.Certificate) throws java.security.cert.CertPathValidatorException;
    method public void init(boolean) throws java.security.cert.CertPathValidatorException;
    method public boolean isForwardCheckingSupported();
  }

  public interface CertPathParameters extends java.lang.Cloneable {
    method public Object clone();
  }

  public class CertPathValidator {
    ctor protected CertPathValidator(java.security.cert.CertPathValidatorSpi, java.security.Provider, String);
    method public final String getAlgorithm();
    method public static final String getDefaultType();
    method public static java.security.cert.CertPathValidator getInstance(String) throws java.security.NoSuchAlgorithmException;
    method public static java.security.cert.CertPathValidator getInstance(String, String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public static java.security.cert.CertPathValidator getInstance(String, java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method public final java.security.Provider getProvider();
    method public final java.security.cert.CertPathChecker getRevocationChecker();
    method public final java.security.cert.CertPathValidatorResult validate(java.security.cert.CertPath, java.security.cert.CertPathParameters) throws java.security.cert.CertPathValidatorException, java.security.InvalidAlgorithmParameterException;
  }

  public class CertPathValidatorException extends java.security.GeneralSecurityException {
    ctor public CertPathValidatorException();
    ctor public CertPathValidatorException(String);
    ctor public CertPathValidatorException(Throwable);
    ctor public CertPathValidatorException(String, Throwable);
    ctor public CertPathValidatorException(String, Throwable, java.security.cert.CertPath, int);
    ctor public CertPathValidatorException(String, Throwable, java.security.cert.CertPath, int, java.security.cert.CertPathValidatorException.Reason);
    method public java.security.cert.CertPath getCertPath();
    method public int getIndex();
    method public java.security.cert.CertPathValidatorException.Reason getReason();
  }

  public enum CertPathValidatorException.BasicReason implements java.security.cert.CertPathValidatorException.Reason {
    enum_constant public static final java.security.cert.CertPathValidatorException.BasicReason ALGORITHM_CONSTRAINED;
    enum_constant public static final java.security.cert.CertPathValidatorException.BasicReason EXPIRED;
    enum_constant public static final java.security.cert.CertPathValidatorException.BasicReason INVALID_SIGNATURE;
    enum_constant public static final java.security.cert.CertPathValidatorException.BasicReason NOT_YET_VALID;
    enum_constant public static final java.security.cert.CertPathValidatorException.BasicReason REVOKED;
    enum_constant public static final java.security.cert.CertPathValidatorException.BasicReason UNDETERMINED_REVOCATION_STATUS;
    enum_constant public static final java.security.cert.CertPathValidatorException.BasicReason UNSPECIFIED;
  }

  public static interface CertPathValidatorException.Reason extends java.io.Serializable {
  }

  public interface CertPathValidatorResult extends java.lang.Cloneable {
    method public Object clone();
  }

  public abstract class CertPathValidatorSpi {
    ctor public CertPathValidatorSpi();
    method public java.security.cert.CertPathChecker engineGetRevocationChecker();
    method public abstract java.security.cert.CertPathValidatorResult engineValidate(java.security.cert.CertPath, java.security.cert.CertPathParameters) throws java.security.cert.CertPathValidatorException, java.security.InvalidAlgorithmParameterException;
  }

  public interface CertSelector extends java.lang.Cloneable {
    method public Object clone();
    method public boolean match(java.security.cert.Certificate);
  }

  public class CertStore {
    ctor protected CertStore(java.security.cert.CertStoreSpi, java.security.Provider, String, java.security.cert.CertStoreParameters);
    method public final java.util.Collection<? extends java.security.cert.CRL> getCRLs(java.security.cert.CRLSelector) throws java.security.cert.CertStoreException;
    method public final java.security.cert.CertStoreParameters getCertStoreParameters();
    method public final java.util.Collection<? extends java.security.cert.Certificate> getCertificates(java.security.cert.CertSelector) throws java.security.cert.CertStoreException;
    method public static final String getDefaultType();
    method public static java.security.cert.CertStore getInstance(String, java.security.cert.CertStoreParameters) throws java.security.InvalidAlgorithmParameterException, java.security.NoSuchAlgorithmException;
    method public static java.security.cert.CertStore getInstance(String, java.security.cert.CertStoreParameters, String) throws java.security.InvalidAlgorithmParameterException, java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public static java.security.cert.CertStore getInstance(String, java.security.cert.CertStoreParameters, java.security.Provider) throws java.security.InvalidAlgorithmParameterException, java.security.NoSuchAlgorithmException;
    method public final java.security.Provider getProvider();
    method public final String getType();
  }

  public class CertStoreException extends java.security.GeneralSecurityException {
    ctor public CertStoreException();
    ctor public CertStoreException(String);
    ctor public CertStoreException(Throwable);
    ctor public CertStoreException(String, Throwable);
  }

  public interface CertStoreParameters extends java.lang.Cloneable {
    method public Object clone();
  }

  public abstract class CertStoreSpi {
    ctor public CertStoreSpi(java.security.cert.CertStoreParameters) throws java.security.InvalidAlgorithmParameterException;
    method public abstract java.util.Collection<? extends java.security.cert.CRL> engineGetCRLs(java.security.cert.CRLSelector) throws java.security.cert.CertStoreException;
    method public abstract java.util.Collection<? extends java.security.cert.Certificate> engineGetCertificates(java.security.cert.CertSelector) throws java.security.cert.CertStoreException;
  }

  public abstract class Certificate implements java.io.Serializable {
    ctor protected Certificate(String);
    method public abstract byte[] getEncoded() throws java.security.cert.CertificateEncodingException;
    method public abstract java.security.PublicKey getPublicKey();
    method public final String getType();
    method public abstract String toString();
    method public abstract void verify(java.security.PublicKey) throws java.security.cert.CertificateException, java.security.InvalidKeyException, java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException, java.security.SignatureException;
    method public abstract void verify(java.security.PublicKey, String) throws java.security.cert.CertificateException, java.security.InvalidKeyException, java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException, java.security.SignatureException;
    method public void verify(java.security.PublicKey, java.security.Provider) throws java.security.cert.CertificateException, java.security.InvalidKeyException, java.security.NoSuchAlgorithmException, java.security.SignatureException;
    method protected Object writeReplace() throws java.io.ObjectStreamException;
  }

  protected static class Certificate.CertificateRep implements java.io.Serializable {
    ctor protected Certificate.CertificateRep(String, byte[]);
    method protected Object readResolve() throws java.io.ObjectStreamException;
  }

  public class CertificateEncodingException extends java.security.cert.CertificateException {
    ctor public CertificateEncodingException();
    ctor public CertificateEncodingException(String);
    ctor public CertificateEncodingException(String, Throwable);
    ctor public CertificateEncodingException(Throwable);
  }

  public class CertificateException extends java.security.GeneralSecurityException {
    ctor public CertificateException();
    ctor public CertificateException(String);
    ctor public CertificateException(String, Throwable);
    ctor public CertificateException(Throwable);
  }

  public class CertificateExpiredException extends java.security.cert.CertificateException {
    ctor public CertificateExpiredException();
    ctor public CertificateExpiredException(String);
  }

  public class CertificateFactory {
    ctor protected CertificateFactory(java.security.cert.CertificateFactorySpi, java.security.Provider, String);
    method public final java.security.cert.CRL generateCRL(java.io.InputStream) throws java.security.cert.CRLException;
    method public final java.util.Collection<? extends java.security.cert.CRL> generateCRLs(java.io.InputStream) throws java.security.cert.CRLException;
    method public final java.security.cert.CertPath generateCertPath(java.io.InputStream) throws java.security.cert.CertificateException;
    method public final java.security.cert.CertPath generateCertPath(java.io.InputStream, String) throws java.security.cert.CertificateException;
    method public final java.security.cert.CertPath generateCertPath(java.util.List<? extends java.security.cert.Certificate>) throws java.security.cert.CertificateException;
    method public final java.security.cert.Certificate generateCertificate(java.io.InputStream) throws java.security.cert.CertificateException;
    method public final java.util.Collection<? extends java.security.cert.Certificate> generateCertificates(java.io.InputStream) throws java.security.cert.CertificateException;
    method public final java.util.Iterator<java.lang.String> getCertPathEncodings();
    method public static final java.security.cert.CertificateFactory getInstance(String) throws java.security.cert.CertificateException;
    method public static final java.security.cert.CertificateFactory getInstance(String, String) throws java.security.cert.CertificateException, java.security.NoSuchProviderException;
    method public static final java.security.cert.CertificateFactory getInstance(String, java.security.Provider) throws java.security.cert.CertificateException;
    method public final java.security.Provider getProvider();
    method public final String getType();
  }

  public abstract class CertificateFactorySpi {
    ctor public CertificateFactorySpi();
    method public abstract java.security.cert.CRL engineGenerateCRL(java.io.InputStream) throws java.security.cert.CRLException;
    method public abstract java.util.Collection<? extends java.security.cert.CRL> engineGenerateCRLs(java.io.InputStream) throws java.security.cert.CRLException;
    method public java.security.cert.CertPath engineGenerateCertPath(java.io.InputStream) throws java.security.cert.CertificateException;
    method public java.security.cert.CertPath engineGenerateCertPath(java.io.InputStream, String) throws java.security.cert.CertificateException;
    method public java.security.cert.CertPath engineGenerateCertPath(java.util.List<? extends java.security.cert.Certificate>) throws java.security.cert.CertificateException;
    method public abstract java.security.cert.Certificate engineGenerateCertificate(java.io.InputStream) throws java.security.cert.CertificateException;
    method public abstract java.util.Collection<? extends java.security.cert.Certificate> engineGenerateCertificates(java.io.InputStream) throws java.security.cert.CertificateException;
    method public java.util.Iterator<java.lang.String> engineGetCertPathEncodings();
  }

  public class CertificateNotYetValidException extends java.security.cert.CertificateException {
    ctor public CertificateNotYetValidException();
    ctor public CertificateNotYetValidException(String);
  }

  public class CertificateParsingException extends java.security.cert.CertificateException {
    ctor public CertificateParsingException();
    ctor public CertificateParsingException(String);
    ctor public CertificateParsingException(String, Throwable);
    ctor public CertificateParsingException(Throwable);
  }

  public class CertificateRevokedException extends java.security.cert.CertificateException {
    ctor public CertificateRevokedException(java.util.Date, java.security.cert.CRLReason, javax.security.auth.x500.X500Principal, java.util.Map<java.lang.String,java.security.cert.Extension>);
    method public javax.security.auth.x500.X500Principal getAuthorityName();
    method public java.util.Map<java.lang.String,java.security.cert.Extension> getExtensions();
    method public java.util.Date getInvalidityDate();
    method public java.util.Date getRevocationDate();
    method public java.security.cert.CRLReason getRevocationReason();
  }

  public class CollectionCertStoreParameters implements java.security.cert.CertStoreParameters {
    ctor public CollectionCertStoreParameters(java.util.Collection<?>);
    ctor public CollectionCertStoreParameters();
    method public Object clone();
    method public java.util.Collection<?> getCollection();
  }

  public interface Extension {
    method public void encode(java.io.OutputStream) throws java.io.IOException;
    method public String getId();
    method public byte[] getValue();
    method public boolean isCritical();
  }

  public class LDAPCertStoreParameters implements java.security.cert.CertStoreParameters {
    ctor public LDAPCertStoreParameters(String, int);
    ctor public LDAPCertStoreParameters(String);
    ctor public LDAPCertStoreParameters();
    method public Object clone();
    method public int getPort();
    method public String getServerName();
  }

  public class PKIXBuilderParameters extends java.security.cert.PKIXParameters {
    ctor public PKIXBuilderParameters(java.util.Set<java.security.cert.TrustAnchor>, java.security.cert.CertSelector) throws java.security.InvalidAlgorithmParameterException;
    ctor public PKIXBuilderParameters(java.security.KeyStore, java.security.cert.CertSelector) throws java.security.InvalidAlgorithmParameterException, java.security.KeyStoreException;
    method public int getMaxPathLength();
    method public void setMaxPathLength(int);
  }

  public class PKIXCertPathBuilderResult extends java.security.cert.PKIXCertPathValidatorResult implements java.security.cert.CertPathBuilderResult {
    ctor public PKIXCertPathBuilderResult(java.security.cert.CertPath, java.security.cert.TrustAnchor, java.security.cert.PolicyNode, java.security.PublicKey);
    method public java.security.cert.CertPath getCertPath();
  }

  public abstract class PKIXCertPathChecker implements java.security.cert.CertPathChecker java.lang.Cloneable {
    ctor protected PKIXCertPathChecker();
    method public abstract void check(java.security.cert.Certificate, java.util.Collection<java.lang.String>) throws java.security.cert.CertPathValidatorException;
    method public void check(java.security.cert.Certificate) throws java.security.cert.CertPathValidatorException;
    method public Object clone();
    method public abstract java.util.Set<java.lang.String> getSupportedExtensions();
  }

  public class PKIXCertPathValidatorResult implements java.security.cert.CertPathValidatorResult {
    ctor public PKIXCertPathValidatorResult(java.security.cert.TrustAnchor, java.security.cert.PolicyNode, java.security.PublicKey);
    method public Object clone();
    method public java.security.cert.PolicyNode getPolicyTree();
    method public java.security.PublicKey getPublicKey();
    method public java.security.cert.TrustAnchor getTrustAnchor();
  }

  public class PKIXParameters implements java.security.cert.CertPathParameters {
    ctor public PKIXParameters(java.util.Set<java.security.cert.TrustAnchor>) throws java.security.InvalidAlgorithmParameterException;
    ctor public PKIXParameters(java.security.KeyStore) throws java.security.InvalidAlgorithmParameterException, java.security.KeyStoreException;
    method public void addCertPathChecker(java.security.cert.PKIXCertPathChecker);
    method public void addCertStore(java.security.cert.CertStore);
    method public Object clone();
    method public java.util.List<java.security.cert.PKIXCertPathChecker> getCertPathCheckers();
    method public java.util.List<java.security.cert.CertStore> getCertStores();
    method public java.util.Date getDate();
    method public java.util.Set<java.lang.String> getInitialPolicies();
    method public boolean getPolicyQualifiersRejected();
    method public String getSigProvider();
    method public java.security.cert.CertSelector getTargetCertConstraints();
    method public java.util.Set<java.security.cert.TrustAnchor> getTrustAnchors();
    method public boolean isAnyPolicyInhibited();
    method public boolean isExplicitPolicyRequired();
    method public boolean isPolicyMappingInhibited();
    method public boolean isRevocationEnabled();
    method public void setAnyPolicyInhibited(boolean);
    method public void setCertPathCheckers(java.util.List<java.security.cert.PKIXCertPathChecker>);
    method public void setCertStores(java.util.List<java.security.cert.CertStore>);
    method public void setDate(java.util.Date);
    method public void setExplicitPolicyRequired(boolean);
    method public void setInitialPolicies(java.util.Set<java.lang.String>);
    method public void setPolicyMappingInhibited(boolean);
    method public void setPolicyQualifiersRejected(boolean);
    method public void setRevocationEnabled(boolean);
    method public void setSigProvider(String);
    method public void setTargetCertConstraints(java.security.cert.CertSelector);
    method public void setTrustAnchors(java.util.Set<java.security.cert.TrustAnchor>) throws java.security.InvalidAlgorithmParameterException;
  }

  public enum PKIXReason implements java.security.cert.CertPathValidatorException.Reason {
    enum_constant public static final java.security.cert.PKIXReason INVALID_KEY_USAGE;
    enum_constant public static final java.security.cert.PKIXReason INVALID_NAME;
    enum_constant public static final java.security.cert.PKIXReason INVALID_POLICY;
    enum_constant public static final java.security.cert.PKIXReason NAME_CHAINING;
    enum_constant public static final java.security.cert.PKIXReason NOT_CA_CERT;
    enum_constant public static final java.security.cert.PKIXReason NO_TRUST_ANCHOR;
    enum_constant public static final java.security.cert.PKIXReason PATH_TOO_LONG;
    enum_constant public static final java.security.cert.PKIXReason UNRECOGNIZED_CRIT_EXT;
  }

  public abstract class PKIXRevocationChecker extends java.security.cert.PKIXCertPathChecker {
    ctor protected PKIXRevocationChecker();
    method public java.security.cert.PKIXRevocationChecker clone();
    method public java.util.List<java.security.cert.Extension> getOcspExtensions();
    method public java.net.URI getOcspResponder();
    method public java.security.cert.X509Certificate getOcspResponderCert();
    method public java.util.Map<java.security.cert.X509Certificate,byte[]> getOcspResponses();
    method public java.util.Set<java.security.cert.PKIXRevocationChecker.Option> getOptions();
    method public abstract java.util.List<java.security.cert.CertPathValidatorException> getSoftFailExceptions();
    method public void setOcspExtensions(java.util.List<java.security.cert.Extension>);
    method public void setOcspResponder(java.net.URI);
    method public void setOcspResponderCert(java.security.cert.X509Certificate);
    method public void setOcspResponses(java.util.Map<java.security.cert.X509Certificate,byte[]>);
    method public void setOptions(java.util.Set<java.security.cert.PKIXRevocationChecker.Option>);
  }

  public enum PKIXRevocationChecker.Option {
    enum_constant public static final java.security.cert.PKIXRevocationChecker.Option NO_FALLBACK;
    enum_constant public static final java.security.cert.PKIXRevocationChecker.Option ONLY_END_ENTITY;
    enum_constant public static final java.security.cert.PKIXRevocationChecker.Option PREFER_CRLS;
    enum_constant public static final java.security.cert.PKIXRevocationChecker.Option SOFT_FAIL;
  }

  public interface PolicyNode {
    method public java.util.Iterator<? extends java.security.cert.PolicyNode> getChildren();
    method public int getDepth();
    method public java.util.Set<java.lang.String> getExpectedPolicies();
    method public java.security.cert.PolicyNode getParent();
    method public java.util.Set<? extends java.security.cert.PolicyQualifierInfo> getPolicyQualifiers();
    method public String getValidPolicy();
    method public boolean isCritical();
  }

  public class PolicyQualifierInfo {
    ctor public PolicyQualifierInfo(byte[]) throws java.io.IOException;
    method public final byte[] getEncoded();
    method public final byte[] getPolicyQualifier();
    method public final String getPolicyQualifierId();
  }

  public class TrustAnchor {
    ctor public TrustAnchor(java.security.cert.X509Certificate, byte[]);
    ctor public TrustAnchor(javax.security.auth.x500.X500Principal, java.security.PublicKey, byte[]);
    ctor public TrustAnchor(String, java.security.PublicKey, byte[]);
    method public final javax.security.auth.x500.X500Principal getCA();
    method public final String getCAName();
    method public final java.security.PublicKey getCAPublicKey();
    method public final byte[] getNameConstraints();
    method public final java.security.cert.X509Certificate getTrustedCert();
  }

  public final class URICertStoreParameters implements java.security.cert.CertStoreParameters {
    ctor public URICertStoreParameters(java.net.URI);
    method public java.security.cert.URICertStoreParameters clone();
    method public java.net.URI getURI();
  }

  public abstract class X509CRL extends java.security.cert.CRL implements java.security.cert.X509Extension {
    ctor protected X509CRL();
    method public abstract byte[] getEncoded() throws java.security.cert.CRLException;
    method public abstract java.security.Principal getIssuerDN();
    method public javax.security.auth.x500.X500Principal getIssuerX500Principal();
    method public abstract java.util.Date getNextUpdate();
    method public abstract java.security.cert.X509CRLEntry getRevokedCertificate(java.math.BigInteger);
    method public java.security.cert.X509CRLEntry getRevokedCertificate(java.security.cert.X509Certificate);
    method public abstract java.util.Set<? extends java.security.cert.X509CRLEntry> getRevokedCertificates();
    method public abstract String getSigAlgName();
    method public abstract String getSigAlgOID();
    method public abstract byte[] getSigAlgParams();
    method public abstract byte[] getSignature();
    method public abstract byte[] getTBSCertList() throws java.security.cert.CRLException;
    method public abstract java.util.Date getThisUpdate();
    method public abstract int getVersion();
    method public abstract void verify(java.security.PublicKey) throws java.security.cert.CRLException, java.security.InvalidKeyException, java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException, java.security.SignatureException;
    method public abstract void verify(java.security.PublicKey, String) throws java.security.cert.CRLException, java.security.InvalidKeyException, java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException, java.security.SignatureException;
    method public void verify(java.security.PublicKey, java.security.Provider) throws java.security.cert.CRLException, java.security.InvalidKeyException, java.security.NoSuchAlgorithmException, java.security.SignatureException;
  }

  public abstract class X509CRLEntry implements java.security.cert.X509Extension {
    ctor public X509CRLEntry();
    method public javax.security.auth.x500.X500Principal getCertificateIssuer();
    method public abstract byte[] getEncoded() throws java.security.cert.CRLException;
    method public abstract java.util.Date getRevocationDate();
    method public java.security.cert.CRLReason getRevocationReason();
    method public abstract java.math.BigInteger getSerialNumber();
    method public abstract boolean hasExtensions();
    method public abstract String toString();
  }

  public class X509CRLSelector implements java.security.cert.CRLSelector {
    ctor public X509CRLSelector();
    method public void addIssuer(javax.security.auth.x500.X500Principal);
    method public void addIssuerName(String) throws java.io.IOException;
    method public void addIssuerName(byte[]) throws java.io.IOException;
    method public Object clone();
    method public java.security.cert.X509Certificate getCertificateChecking();
    method public java.util.Date getDateAndTime();
    method public java.util.Collection<java.lang.Object> getIssuerNames();
    method public java.util.Collection<javax.security.auth.x500.X500Principal> getIssuers();
    method public java.math.BigInteger getMaxCRL();
    method public java.math.BigInteger getMinCRL();
    method public boolean match(java.security.cert.CRL);
    method public void setCertificateChecking(java.security.cert.X509Certificate);
    method public void setDateAndTime(java.util.Date);
    method public void setIssuerNames(java.util.Collection<?>) throws java.io.IOException;
    method public void setIssuers(java.util.Collection<javax.security.auth.x500.X500Principal>);
    method public void setMaxCRLNumber(java.math.BigInteger);
    method public void setMinCRLNumber(java.math.BigInteger);
  }

  public class X509CertSelector implements java.security.cert.CertSelector {
    ctor public X509CertSelector();
    method public void addPathToName(int, String) throws java.io.IOException;
    method public void addPathToName(int, byte[]) throws java.io.IOException;
    method public void addSubjectAlternativeName(int, String) throws java.io.IOException;
    method public void addSubjectAlternativeName(int, byte[]) throws java.io.IOException;
    method public Object clone();
    method public byte[] getAuthorityKeyIdentifier();
    method public int getBasicConstraints();
    method public java.security.cert.X509Certificate getCertificate();
    method public java.util.Date getCertificateValid();
    method public java.util.Set<java.lang.String> getExtendedKeyUsage();
    method public javax.security.auth.x500.X500Principal getIssuer();
    method public byte[] getIssuerAsBytes() throws java.io.IOException;
    method public String getIssuerAsString();
    method public boolean[] getKeyUsage();
    method public boolean getMatchAllSubjectAltNames();
    method public byte[] getNameConstraints();
    method public java.util.Collection<java.util.List<?>> getPathToNames();
    method public java.util.Set<java.lang.String> getPolicy();
    method public java.util.Date getPrivateKeyValid();
    method public java.math.BigInteger getSerialNumber();
    method public javax.security.auth.x500.X500Principal getSubject();
    method public java.util.Collection<java.util.List<?>> getSubjectAlternativeNames();
    method public byte[] getSubjectAsBytes() throws java.io.IOException;
    method public String getSubjectAsString();
    method public byte[] getSubjectKeyIdentifier();
    method public java.security.PublicKey getSubjectPublicKey();
    method public String getSubjectPublicKeyAlgID();
    method public boolean match(java.security.cert.Certificate);
    method public void setAuthorityKeyIdentifier(byte[]);
    method public void setBasicConstraints(int);
    method public void setCertificate(java.security.cert.X509Certificate);
    method public void setCertificateValid(java.util.Date);
    method public void setExtendedKeyUsage(java.util.Set<java.lang.String>) throws java.io.IOException;
    method public void setIssuer(javax.security.auth.x500.X500Principal);
    method public void setIssuer(String) throws java.io.IOException;
    method public void setIssuer(byte[]) throws java.io.IOException;
    method public void setKeyUsage(boolean[]);
    method public void setMatchAllSubjectAltNames(boolean);
    method public void setNameConstraints(byte[]) throws java.io.IOException;
    method public void setPathToNames(java.util.Collection<java.util.List<?>>) throws java.io.IOException;
    method public void setPolicy(java.util.Set<java.lang.String>) throws java.io.IOException;
    method public void setPrivateKeyValid(java.util.Date);
    method public void setSerialNumber(java.math.BigInteger);
    method public void setSubject(javax.security.auth.x500.X500Principal);
    method public void setSubject(String) throws java.io.IOException;
    method public void setSubject(byte[]) throws java.io.IOException;
    method public void setSubjectAlternativeNames(java.util.Collection<java.util.List<?>>) throws java.io.IOException;
    method public void setSubjectKeyIdentifier(byte[]);
    method public void setSubjectPublicKey(java.security.PublicKey);
    method public void setSubjectPublicKey(byte[]) throws java.io.IOException;
    method public void setSubjectPublicKeyAlgID(String) throws java.io.IOException;
  }

  public abstract class X509Certificate extends java.security.cert.Certificate implements java.security.cert.X509Extension {
    ctor protected X509Certificate();
    method public abstract void checkValidity() throws java.security.cert.CertificateExpiredException, java.security.cert.CertificateNotYetValidException;
    method public abstract void checkValidity(java.util.Date) throws java.security.cert.CertificateExpiredException, java.security.cert.CertificateNotYetValidException;
    method public abstract int getBasicConstraints();
    method public java.util.List<java.lang.String> getExtendedKeyUsage() throws java.security.cert.CertificateParsingException;
    method public java.util.Collection<java.util.List<?>> getIssuerAlternativeNames() throws java.security.cert.CertificateParsingException;
    method public abstract java.security.Principal getIssuerDN();
    method public abstract boolean[] getIssuerUniqueID();
    method public javax.security.auth.x500.X500Principal getIssuerX500Principal();
    method public abstract boolean[] getKeyUsage();
    method public abstract java.util.Date getNotAfter();
    method public abstract java.util.Date getNotBefore();
    method public abstract java.math.BigInteger getSerialNumber();
    method public abstract String getSigAlgName();
    method public abstract String getSigAlgOID();
    method public abstract byte[] getSigAlgParams();
    method public abstract byte[] getSignature();
    method public java.util.Collection<java.util.List<?>> getSubjectAlternativeNames() throws java.security.cert.CertificateParsingException;
    method public abstract java.security.Principal getSubjectDN();
    method public abstract boolean[] getSubjectUniqueID();
    method public javax.security.auth.x500.X500Principal getSubjectX500Principal();
    method public abstract byte[] getTBSCertificate() throws java.security.cert.CertificateEncodingException;
    method public abstract int getVersion();
  }

  public interface X509Extension {
    method public java.util.Set<java.lang.String> getCriticalExtensionOIDs();
    method public byte[] getExtensionValue(String);
    method public java.util.Set<java.lang.String> getNonCriticalExtensionOIDs();
    method public boolean hasUnsupportedCriticalExtension();
  }

}

package java.security.interfaces {

  public interface DSAKey {
    method public java.security.interfaces.DSAParams getParams();
  }

  public interface DSAKeyPairGenerator {
    method public void initialize(java.security.interfaces.DSAParams, java.security.SecureRandom) throws java.security.InvalidParameterException;
    method public void initialize(int, boolean, java.security.SecureRandom) throws java.security.InvalidParameterException;
  }

  public interface DSAParams {
    method public java.math.BigInteger getG();
    method public java.math.BigInteger getP();
    method public java.math.BigInteger getQ();
  }

  public interface DSAPrivateKey extends java.security.interfaces.DSAKey java.security.PrivateKey {
    method public java.math.BigInteger getX();
    field @Deprecated @java.io.Serial public static final long serialVersionUID = 7776497482533790279L; // 0x6bebab423b256247L
  }

  public interface DSAPublicKey extends java.security.interfaces.DSAKey java.security.PublicKey {
    method public java.math.BigInteger getY();
    field @Deprecated @java.io.Serial public static final long serialVersionUID = 1234526332779022332L; // 0x1121eb28ab28c7fcL
  }

  public interface ECKey {
    method public java.security.spec.ECParameterSpec getParams();
  }

  public interface ECPrivateKey extends java.security.PrivateKey java.security.interfaces.ECKey {
    method public java.math.BigInteger getS();
    field @Deprecated @java.io.Serial public static final long serialVersionUID = -7896394956925609184L; // 0x926a5e9fa2435b20L
  }

  public interface ECPublicKey extends java.security.PublicKey java.security.interfaces.ECKey {
    method public java.security.spec.ECPoint getW();
    field @Deprecated @java.io.Serial public static final long serialVersionUID = -3314988629879632826L; // 0xd1fecb679990cc46L
  }

  public interface EdECKey {
    method public java.security.spec.NamedParameterSpec getParams();
  }

  public interface EdECPrivateKey extends java.security.interfaces.EdECKey java.security.PrivateKey {
    method public java.util.Optional<byte[]> getBytes();
  }

  public interface EdECPublicKey extends java.security.interfaces.EdECKey java.security.PublicKey {
    method public java.security.spec.EdECPoint getPoint();
  }

  public interface RSAKey {
    method public java.math.BigInteger getModulus();
    method @FlaggedApi("com.android.libcore.v_apis") public default java.security.spec.AlgorithmParameterSpec getParams();
  }

  public interface RSAMultiPrimePrivateCrtKey extends java.security.interfaces.RSAPrivateKey {
    method public java.math.BigInteger getCrtCoefficient();
    method public java.security.spec.RSAOtherPrimeInfo[] getOtherPrimeInfo();
    method public java.math.BigInteger getPrimeExponentP();
    method public java.math.BigInteger getPrimeExponentQ();
    method public java.math.BigInteger getPrimeP();
    method public java.math.BigInteger getPrimeQ();
    method public java.math.BigInteger getPublicExponent();
    field @Deprecated @java.io.Serial public static final long serialVersionUID = 618058533534628008L; // 0x893c8f62dbaf8a8L
  }

  public interface RSAPrivateCrtKey extends java.security.interfaces.RSAPrivateKey {
    method public java.math.BigInteger getCrtCoefficient();
    method public java.math.BigInteger getPrimeExponentP();
    method public java.math.BigInteger getPrimeExponentQ();
    method public java.math.BigInteger getPrimeP();
    method public java.math.BigInteger getPrimeQ();
    method public java.math.BigInteger getPublicExponent();
    field @Deprecated @java.io.Serial public static final long serialVersionUID = -5682214253527700368L; // 0xb124b83df8d1ec70L
  }

  public interface RSAPrivateKey extends java.security.PrivateKey java.security.interfaces.RSAKey {
    method public java.math.BigInteger getPrivateExponent();
    field @Deprecated @java.io.Serial public static final long serialVersionUID = 5187144804936595022L; // 0x47fc70b7a8c2364eL
  }

  public interface RSAPublicKey extends java.security.PublicKey java.security.interfaces.RSAKey {
    method public java.math.BigInteger getPublicExponent();
    field @Deprecated @java.io.Serial public static final long serialVersionUID = -8727434096241101194L; // 0x86e1ecedeceab676L
  }

  public interface XECKey {
    method public java.security.spec.AlgorithmParameterSpec getParams();
  }

  public interface XECPrivateKey extends java.security.interfaces.XECKey java.security.PrivateKey {
    method public java.util.Optional<byte[]> getScalar();
  }

  public interface XECPublicKey extends java.security.interfaces.XECKey java.security.PublicKey {
    method public java.math.BigInteger getU();
  }

}

package java.security.spec {

  public interface AlgorithmParameterSpec {
  }

  @FlaggedApi("com.android.libcore.v_apis") public final class DSAGenParameterSpec implements java.security.spec.AlgorithmParameterSpec {
    ctor public DSAGenParameterSpec(int, int);
    ctor public DSAGenParameterSpec(int, int, int);
    method public int getPrimePLength();
    method public int getSeedLength();
    method public int getSubprimeQLength();
  }

  public class DSAParameterSpec implements java.security.spec.AlgorithmParameterSpec java.security.interfaces.DSAParams {
    ctor public DSAParameterSpec(java.math.BigInteger, java.math.BigInteger, java.math.BigInteger);
    method public java.math.BigInteger getG();
    method public java.math.BigInteger getP();
    method public java.math.BigInteger getQ();
  }

  public class DSAPrivateKeySpec implements java.security.spec.KeySpec {
    ctor public DSAPrivateKeySpec(java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger);
    method public java.math.BigInteger getG();
    method public java.math.BigInteger getP();
    method public java.math.BigInteger getQ();
    method public java.math.BigInteger getX();
  }

  public class DSAPublicKeySpec implements java.security.spec.KeySpec {
    ctor public DSAPublicKeySpec(java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger);
    method public java.math.BigInteger getG();
    method public java.math.BigInteger getP();
    method public java.math.BigInteger getQ();
    method public java.math.BigInteger getY();
  }

  public interface ECField {
    method public int getFieldSize();
  }

  public class ECFieldF2m implements java.security.spec.ECField {
    ctor public ECFieldF2m(int);
    ctor public ECFieldF2m(int, java.math.BigInteger);
    ctor public ECFieldF2m(int, int[]);
    method public int getFieldSize();
    method public int getM();
    method public int[] getMidTermsOfReductionPolynomial();
    method public java.math.BigInteger getReductionPolynomial();
  }

  public class ECFieldFp implements java.security.spec.ECField {
    ctor public ECFieldFp(java.math.BigInteger);
    method public int getFieldSize();
    method public java.math.BigInteger getP();
  }

  public class ECGenParameterSpec extends java.security.spec.NamedParameterSpec implements java.security.spec.AlgorithmParameterSpec {
    ctor public ECGenParameterSpec(String);
  }

  public class ECParameterSpec implements java.security.spec.AlgorithmParameterSpec {
    ctor public ECParameterSpec(java.security.spec.EllipticCurve, java.security.spec.ECPoint, java.math.BigInteger, int);
    method public int getCofactor();
    method public java.security.spec.EllipticCurve getCurve();
    method public java.security.spec.ECPoint getGenerator();
    method public java.math.BigInteger getOrder();
  }

  public class ECPoint {
    ctor public ECPoint(java.math.BigInteger, java.math.BigInteger);
    method public java.math.BigInteger getAffineX();
    method public java.math.BigInteger getAffineY();
    field public static final java.security.spec.ECPoint POINT_INFINITY;
  }

  public class ECPrivateKeySpec implements java.security.spec.KeySpec {
    ctor public ECPrivateKeySpec(java.math.BigInteger, java.security.spec.ECParameterSpec);
    method public java.security.spec.ECParameterSpec getParams();
    method public java.math.BigInteger getS();
  }

  public class ECPublicKeySpec implements java.security.spec.KeySpec {
    ctor public ECPublicKeySpec(java.security.spec.ECPoint, java.security.spec.ECParameterSpec);
    method public java.security.spec.ECParameterSpec getParams();
    method public java.security.spec.ECPoint getW();
  }

  @FlaggedApi("com.android.libcore.v_apis") public class EdDSAParameterSpec implements java.security.spec.AlgorithmParameterSpec {
    ctor public EdDSAParameterSpec(boolean);
    ctor public EdDSAParameterSpec(boolean, byte[]);
    method public java.util.Optional<byte[]> getContext();
    method public boolean isPrehash();
  }

  public final class EdECPoint {
    ctor public EdECPoint(boolean, @NonNull java.math.BigInteger);
    method @NonNull public java.math.BigInteger getY();
    method public boolean isXOdd();
  }

  public final class EdECPrivateKeySpec implements java.security.spec.KeySpec {
    ctor public EdECPrivateKeySpec(@NonNull java.security.spec.NamedParameterSpec, @NonNull byte[]);
    method @NonNull public byte[] getBytes();
    method @NonNull public java.security.spec.NamedParameterSpec getParams();
  }

  public final class EdECPublicKeySpec implements java.security.spec.KeySpec {
    ctor public EdECPublicKeySpec(@NonNull java.security.spec.NamedParameterSpec, @NonNull java.security.spec.EdECPoint);
    method @NonNull public java.security.spec.NamedParameterSpec getParams();
    method @NonNull public java.security.spec.EdECPoint getPoint();
  }

  public class EllipticCurve {
    ctor public EllipticCurve(java.security.spec.ECField, java.math.BigInteger, java.math.BigInteger);
    ctor public EllipticCurve(java.security.spec.ECField, java.math.BigInteger, java.math.BigInteger, byte[]);
    method public java.math.BigInteger getA();
    method public java.math.BigInteger getB();
    method public java.security.spec.ECField getField();
    method public byte[] getSeed();
  }

  public abstract class EncodedKeySpec implements java.security.spec.KeySpec {
    ctor public EncodedKeySpec(byte[]);
    method public byte[] getEncoded();
    method public abstract String getFormat();
  }

  public class InvalidKeySpecException extends java.security.GeneralSecurityException {
    ctor public InvalidKeySpecException();
    ctor public InvalidKeySpecException(String);
    ctor public InvalidKeySpecException(String, Throwable);
    ctor public InvalidKeySpecException(Throwable);
  }

  public class InvalidParameterSpecException extends java.security.GeneralSecurityException {
    ctor public InvalidParameterSpecException();
    ctor public InvalidParameterSpecException(String);
  }

  public interface KeySpec {
  }

  public class MGF1ParameterSpec implements java.security.spec.AlgorithmParameterSpec {
    ctor public MGF1ParameterSpec(String);
    method public String getDigestAlgorithm();
    field public static final java.security.spec.MGF1ParameterSpec SHA1;
    field public static final java.security.spec.MGF1ParameterSpec SHA224;
    field public static final java.security.spec.MGF1ParameterSpec SHA256;
    field public static final java.security.spec.MGF1ParameterSpec SHA384;
    field public static final java.security.spec.MGF1ParameterSpec SHA512;
  }

  public class NamedParameterSpec implements java.security.spec.AlgorithmParameterSpec {
    ctor public NamedParameterSpec(@NonNull String);
    method @NonNull public String getName();
    field public static final java.security.spec.NamedParameterSpec ED25519;
    field public static final java.security.spec.NamedParameterSpec ED448;
    field public static final java.security.spec.NamedParameterSpec X25519;
    field public static final java.security.spec.NamedParameterSpec X448;
  }

  public class PKCS8EncodedKeySpec extends java.security.spec.EncodedKeySpec {
    ctor public PKCS8EncodedKeySpec(byte[]);
    method public final String getFormat();
  }

  public class PSSParameterSpec implements java.security.spec.AlgorithmParameterSpec {
    ctor public PSSParameterSpec(String, String, java.security.spec.AlgorithmParameterSpec, int, int);
    ctor public PSSParameterSpec(int);
    method public String getDigestAlgorithm();
    method public String getMGFAlgorithm();
    method public java.security.spec.AlgorithmParameterSpec getMGFParameters();
    method public int getSaltLength();
    method public int getTrailerField();
    field public static final java.security.spec.PSSParameterSpec DEFAULT;
  }

  public class RSAKeyGenParameterSpec implements java.security.spec.AlgorithmParameterSpec {
    ctor public RSAKeyGenParameterSpec(int, java.math.BigInteger);
    method public int getKeysize();
    method public java.math.BigInteger getPublicExponent();
    field public static final java.math.BigInteger F0;
    field public static final java.math.BigInteger F4;
  }

  public class RSAMultiPrimePrivateCrtKeySpec extends java.security.spec.RSAPrivateKeySpec {
    ctor public RSAMultiPrimePrivateCrtKeySpec(java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.security.spec.RSAOtherPrimeInfo[]);
    method public java.math.BigInteger getCrtCoefficient();
    method public java.security.spec.RSAOtherPrimeInfo[] getOtherPrimeInfo();
    method public java.math.BigInteger getPrimeExponentP();
    method public java.math.BigInteger getPrimeExponentQ();
    method public java.math.BigInteger getPrimeP();
    method public java.math.BigInteger getPrimeQ();
    method public java.math.BigInteger getPublicExponent();
  }

  public class RSAOtherPrimeInfo {
    ctor public RSAOtherPrimeInfo(java.math.BigInteger, java.math.BigInteger, java.math.BigInteger);
    method public final java.math.BigInteger getCrtCoefficient();
    method public final java.math.BigInteger getExponent();
    method public final java.math.BigInteger getPrime();
  }

  public class RSAPrivateCrtKeySpec extends java.security.spec.RSAPrivateKeySpec {
    ctor public RSAPrivateCrtKeySpec(java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger);
    method public java.math.BigInteger getCrtCoefficient();
    method public java.math.BigInteger getPrimeExponentP();
    method public java.math.BigInteger getPrimeExponentQ();
    method public java.math.BigInteger getPrimeP();
    method public java.math.BigInteger getPrimeQ();
    method public java.math.BigInteger getPublicExponent();
  }

  public class RSAPrivateKeySpec implements java.security.spec.KeySpec {
    ctor public RSAPrivateKeySpec(java.math.BigInteger, java.math.BigInteger);
    method public java.math.BigInteger getModulus();
    method public java.math.BigInteger getPrivateExponent();
  }

  public class RSAPublicKeySpec implements java.security.spec.KeySpec {
    ctor public RSAPublicKeySpec(java.math.BigInteger, java.math.BigInteger);
    method public java.math.BigInteger getModulus();
    method public java.math.BigInteger getPublicExponent();
  }

  public class X509EncodedKeySpec extends java.security.spec.EncodedKeySpec {
    ctor public X509EncodedKeySpec(byte[]);
    method public final String getFormat();
  }

  public class XECPrivateKeySpec implements java.security.spec.KeySpec {
    ctor public XECPrivateKeySpec(java.security.spec.AlgorithmParameterSpec, byte[]);
    method public java.security.spec.AlgorithmParameterSpec getParams();
    method public byte[] getScalar();
  }

  public class XECPublicKeySpec implements java.security.spec.KeySpec {
    ctor public XECPublicKeySpec(java.security.spec.AlgorithmParameterSpec, java.math.BigInteger);
    method public java.security.spec.AlgorithmParameterSpec getParams();
    method public java.math.BigInteger getU();
  }

}

package java.sql {

  public interface Array {
    method public void free() throws java.sql.SQLException;
    method public Object getArray() throws java.sql.SQLException;
    method public Object getArray(java.util.Map<java.lang.String,java.lang.Class<?>>) throws java.sql.SQLException;
    method public Object getArray(long, int) throws java.sql.SQLException;
    method public Object getArray(long, int, java.util.Map<java.lang.String,java.lang.Class<?>>) throws java.sql.SQLException;
    method public int getBaseType() throws java.sql.SQLException;
    method public String getBaseTypeName() throws java.sql.SQLException;
    method public java.sql.ResultSet getResultSet() throws java.sql.SQLException;
    method public java.sql.ResultSet getResultSet(java.util.Map<java.lang.String,java.lang.Class<?>>) throws java.sql.SQLException;
    method public java.sql.ResultSet getResultSet(long, int) throws java.sql.SQLException;
    method public java.sql.ResultSet getResultSet(long, int, java.util.Map<java.lang.String,java.lang.Class<?>>) throws java.sql.SQLException;
  }

  public class BatchUpdateException extends java.sql.SQLException {
    ctor public BatchUpdateException(String, String, int, int[]);
    ctor public BatchUpdateException(String, String, int[]);
    ctor public BatchUpdateException(String, int[]);
    ctor public BatchUpdateException(int[]);
    ctor public BatchUpdateException();
    ctor public BatchUpdateException(Throwable);
    ctor public BatchUpdateException(int[], Throwable);
    ctor public BatchUpdateException(String, int[], Throwable);
    ctor public BatchUpdateException(String, String, int[], Throwable);
    ctor public BatchUpdateException(String, String, int, int[], Throwable);
    method public int[] getUpdateCounts();
  }

  public interface Blob {
    method public void free() throws java.sql.SQLException;
    method public java.io.InputStream getBinaryStream() throws java.sql.SQLException;
    method public java.io.InputStream getBinaryStream(long, long) throws java.sql.SQLException;
    method public byte[] getBytes(long, int) throws java.sql.SQLException;
    method public long length() throws java.sql.SQLException;
    method public long position(byte[], long) throws java.sql.SQLException;
    method public long position(java.sql.Blob, long) throws java.sql.SQLException;
    method public java.io.OutputStream setBinaryStream(long) throws java.sql.SQLException;
    method public int setBytes(long, byte[]) throws java.sql.SQLException;
    method public int setBytes(long, byte[], int, int) throws java.sql.SQLException;
    method public void truncate(long) throws java.sql.SQLException;
  }

  public interface CallableStatement extends java.sql.PreparedStatement {
    method public java.sql.Array getArray(int) throws java.sql.SQLException;
    method public java.sql.Array getArray(String) throws java.sql.SQLException;
    method @Deprecated public java.math.BigDecimal getBigDecimal(int, int) throws java.sql.SQLException;
    method public java.math.BigDecimal getBigDecimal(int) throws java.sql.SQLException;
    method public java.math.BigDecimal getBigDecimal(String) throws java.sql.SQLException;
    method public java.sql.Blob getBlob(int) throws java.sql.SQLException;
    method public java.sql.Blob getBlob(String) throws java.sql.SQLException;
    method public boolean getBoolean(int) throws java.sql.SQLException;
    method public boolean getBoolean(String) throws java.sql.SQLException;
    method public byte getByte(int) throws java.sql.SQLException;
    method public byte getByte(String) throws java.sql.SQLException;
    method public byte[] getBytes(int) throws java.sql.SQLException;
    method public byte[] getBytes(String) throws java.sql.SQLException;
    method public java.io.Reader getCharacterStream(int) throws java.sql.SQLException;
    method public java.io.Reader getCharacterStream(String) throws java.sql.SQLException;
    method public java.sql.Clob getClob(int) throws java.sql.SQLException;
    method public java.sql.Clob getClob(String) throws java.sql.SQLException;
    method public java.sql.Date getDate(int) throws java.sql.SQLException;
    method public java.sql.Date getDate(int, java.util.Calendar) throws java.sql.SQLException;
    method public java.sql.Date getDate(String) throws java.sql.SQLException;
    method public java.sql.Date getDate(String, java.util.Calendar) throws java.sql.SQLException;
    method public double getDouble(int) throws java.sql.SQLException;
    method public double getDouble(String) throws java.sql.SQLException;
    method public float getFloat(int) throws java.sql.SQLException;
    method public float getFloat(String) throws java.sql.SQLException;
    method public int getInt(int) throws java.sql.SQLException;
    method public int getInt(String) throws java.sql.SQLException;
    method public long getLong(int) throws java.sql.SQLException;
    method public long getLong(String) throws java.sql.SQLException;
    method public java.io.Reader getNCharacterStream(int) throws java.sql.SQLException;
    method public java.io.Reader getNCharacterStream(String) throws java.sql.SQLException;
    method public java.sql.NClob getNClob(int) throws java.sql.SQLException;
    method public java.sql.NClob getNClob(String) throws java.sql.SQLException;
    method public String getNString(int) throws java.sql.SQLException;
    method public String getNString(String) throws java.sql.SQLException;
    method public Object getObject(int) throws java.sql.SQLException;
    method public Object getObject(int, java.util.Map<java.lang.String,java.lang.Class<?>>) throws java.sql.SQLException;
    method public Object getObject(String) throws java.sql.SQLException;
    method public Object getObject(String, java.util.Map<java.lang.String,java.lang.Class<?>>) throws java.sql.SQLException;
    method public java.sql.Ref getRef(int) throws java.sql.SQLException;
    method public java.sql.Ref getRef(String) throws java.sql.SQLException;
    method public java.sql.RowId getRowId(int) throws java.sql.SQLException;
    method public java.sql.RowId getRowId(String) throws java.sql.SQLException;
    method public java.sql.SQLXML getSQLXML(int) throws java.sql.SQLException;
    method public java.sql.SQLXML getSQLXML(String) throws java.sql.SQLException;
    method public short getShort(int) throws java.sql.SQLException;
    method public short getShort(String) throws java.sql.SQLException;
    method public String getString(int) throws java.sql.SQLException;
    method public String getString(String) throws java.sql.SQLException;
    method public java.sql.Time getTime(int) throws java.sql.SQLException;
    method public java.sql.Time getTime(int, java.util.Calendar) throws java.sql.SQLException;
    method public java.sql.Time getTime(String) throws java.sql.SQLException;
    method public java.sql.Time getTime(String, java.util.Calendar) throws java.sql.SQLException;
    method public java.sql.Timestamp getTimestamp(int) throws java.sql.SQLException;
    method public java.sql.Timestamp getTimestamp(int, java.util.Calendar) throws java.sql.SQLException;
    method public java.sql.Timestamp getTimestamp(String) throws java.sql.SQLException;
    method public java.sql.Timestamp getTimestamp(String, java.util.Calendar) throws java.sql.SQLException;
    method public java.net.URL getURL(int) throws java.sql.SQLException;
    method public java.net.URL getURL(String) throws java.sql.SQLException;
    method public void registerOutParameter(int, int) throws java.sql.SQLException;
    method public void registerOutParameter(int, int, int) throws java.sql.SQLException;
    method public void registerOutParameter(int, int, String) throws java.sql.SQLException;
    method public void registerOutParameter(String, int) throws java.sql.SQLException;
    method public void registerOutParameter(String, int, int) throws java.sql.SQLException;
    method public void registerOutParameter(String, int, String) throws java.sql.SQLException;
    method public void setAsciiStream(String, java.io.InputStream, int) throws java.sql.SQLException;
    method public void setAsciiStream(String, java.io.InputStream, long) throws java.sql.SQLException;
    method public void setAsciiStream(String, java.io.InputStream) throws java.sql.SQLException;
    method public void setBigDecimal(String, java.math.BigDecimal) throws java.sql.SQLException;
    method public void setBinaryStream(String, java.io.InputStream, int) throws java.sql.SQLException;
    method public void setBinaryStream(String, java.io.InputStream, long) throws java.sql.SQLException;
    method public void setBinaryStream(String, java.io.InputStream) throws java.sql.SQLException;
    method public void setBlob(String, java.io.InputStream, long) throws java.sql.SQLException;
    method public void setBlob(String, java.sql.Blob) throws java.sql.SQLException;
    method public void setBlob(String, java.io.InputStream) throws java.sql.SQLException;
    method public void setBoolean(String, boolean) throws java.sql.SQLException;
    method public void setByte(String, byte) throws java.sql.SQLException;
    method public void setBytes(String, byte[]) throws java.sql.SQLException;
    method public void setCharacterStream(String, java.io.Reader, int) throws java.sql.SQLException;
    method public void setCharacterStream(String, java.io.Reader, long) throws java.sql.SQLException;
    method public void setCharacterStream(String, java.io.Reader) throws java.sql.SQLException;
    method public void setClob(String, java.io.Reader, long) throws java.sql.SQLException;
    method public void setClob(String, java.sql.Clob) throws java.sql.SQLException;
    method public void setClob(String, java.io.Reader) throws java.sql.SQLException;
    method public void setDate(String, java.sql.Date) throws java.sql.SQLException;
    method public void setDate(String, java.sql.Date, java.util.Calendar) throws java.sql.SQLException;
    method public void setDouble(String, double) throws java.sql.SQLException;
    method public void setFloat(String, float) throws java.sql.SQLException;
    method public void setInt(String, int) throws java.sql.SQLException;
    method public void setLong(String, long) throws java.sql.SQLException;
    method public void setNCharacterStream(String, java.io.Reader, long) throws java.sql.SQLException;
    method public void setNCharacterStream(String, java.io.Reader) throws java.sql.SQLException;
    method public void setNClob(String, java.sql.NClob) throws java.sql.SQLException;
    method public void setNClob(String, java.io.Reader, long) throws java.sql.SQLException;
    method public void setNClob(String, java.io.Reader) throws java.sql.SQLException;
    method public void setNString(String, String) throws java.sql.SQLException;
    method public void setNull(String, int) throws java.sql.SQLException;
    method public void setNull(String, int, String) throws java.sql.SQLException;
    method public void setObject(String, Object, int, int) throws java.sql.SQLException;
    method public void setObject(String, Object, int) throws java.sql.SQLException;
    method public void setObject(String, Object) throws java.sql.SQLException;
    method public void setRowId(String, java.sql.RowId) throws java.sql.SQLException;
    method public void setSQLXML(String, java.sql.SQLXML) throws java.sql.SQLException;
    method public void setShort(String, short) throws java.sql.SQLException;
    method public void setString(String, String) throws java.sql.SQLException;
    method public void setTime(String, java.sql.Time) throws java.sql.SQLException;
    method public void setTime(String, java.sql.Time, java.util.Calendar) throws java.sql.SQLException;
    method public void setTimestamp(String, java.sql.Timestamp) throws java.sql.SQLException;
    method public void setTimestamp(String, java.sql.Timestamp, java.util.Calendar) throws java.sql.SQLException;
    method public void setURL(String, java.net.URL) throws java.sql.SQLException;
    method public boolean wasNull() throws java.sql.SQLException;
  }

  public enum ClientInfoStatus {
    enum_constant public static final java.sql.ClientInfoStatus REASON_UNKNOWN;
    enum_constant public static final java.sql.ClientInfoStatus REASON_UNKNOWN_PROPERTY;
    enum_constant public static final java.sql.ClientInfoStatus REASON_VALUE_INVALID;
    enum_constant public static final java.sql.ClientInfoStatus REASON_VALUE_TRUNCATED;
  }

  public interface Clob {
    method public void free() throws java.sql.SQLException;
    method public java.io.InputStream getAsciiStream() throws java.sql.SQLException;
    method public java.io.Reader getCharacterStream() throws java.sql.SQLException;
    method public java.io.Reader getCharacterStream(long, long) throws java.sql.SQLException;
    method public String getSubString(long, int) throws java.sql.SQLException;
    method public long length() throws java.sql.SQLException;
    method public long position(String, long) throws java.sql.SQLException;
    method public long position(java.sql.Clob, long) throws java.sql.SQLException;
    method public java.io.OutputStream setAsciiStream(long) throws java.sql.SQLException;
    method public java.io.Writer setCharacterStream(long) throws java.sql.SQLException;
    method public int setString(long, String) throws java.sql.SQLException;
    method public int setString(long, String, int, int) throws java.sql.SQLException;
    method public void truncate(long) throws java.sql.SQLException;
  }

  public interface Connection extends java.sql.Wrapper java.lang.AutoCloseable {
    method public void clearWarnings() throws java.sql.SQLException;
    method public void close() throws java.sql.SQLException;
    method public void commit() throws java.sql.SQLException;
    method public java.sql.Array createArrayOf(String, Object[]) throws java.sql.SQLException;
    method public java.sql.Blob createBlob() throws java.sql.SQLException;
    method public java.sql.Clob createClob() throws java.sql.SQLException;
    method public java.sql.NClob createNClob() throws java.sql.SQLException;
    method public java.sql.SQLXML createSQLXML() throws java.sql.SQLException;
    method public java.sql.Statement createStatement() throws java.sql.SQLException;
    method public java.sql.Statement createStatement(int, int) throws java.sql.SQLException;
    method public java.sql.Statement createStatement(int, int, int) throws java.sql.SQLException;
    method public java.sql.Struct createStruct(String, Object[]) throws java.sql.SQLException;
    method public boolean getAutoCommit() throws java.sql.SQLException;
    method public String getCatalog() throws java.sql.SQLException;
    method public String getClientInfo(String) throws java.sql.SQLException;
    method public java.util.Properties getClientInfo() throws java.sql.SQLException;
    method public int getHoldability() throws java.sql.SQLException;
    method public java.sql.DatabaseMetaData getMetaData() throws java.sql.SQLException;
    method public int getTransactionIsolation() throws java.sql.SQLException;
    method public java.util.Map<java.lang.String,java.lang.Class<?>> getTypeMap() throws java.sql.SQLException;
    method public java.sql.SQLWarning getWarnings() throws java.sql.SQLException;
    method public boolean isClosed() throws java.sql.SQLException;
    method public boolean isReadOnly() throws java.sql.SQLException;
    method public boolean isValid(int) throws java.sql.SQLException;
    method public String nativeSQL(String) throws java.sql.SQLException;
    method public java.sql.CallableStatement prepareCall(String) throws java.sql.SQLException;
    method public java.sql.CallableStatement prepareCall(String, int, int) throws java.sql.SQLException;
    method public java.sql.CallableStatement prepareCall(String, int, int, int) throws java.sql.SQLException;
    method public java.sql.PreparedStatement prepareStatement(String) throws java.sql.SQLException;
    method public java.sql.PreparedStatement prepareStatement(String, int, int) throws java.sql.SQLException;
    method public java.sql.PreparedStatement prepareStatement(String, int, int, int) throws java.sql.SQLException;
    method public java.sql.PreparedStatement prepareStatement(String, int) throws java.sql.SQLException;
    method public java.sql.PreparedStatement prepareStatement(String, int[]) throws java.sql.SQLException;
    method public java.sql.PreparedStatement prepareStatement(String, String[]) throws java.sql.SQLException;
    method public void releaseSavepoint(java.sql.Savepoint) throws java.sql.SQLException;
    method public void rollback() throws java.sql.SQLException;
    method public void rollback(java.sql.Savepoint) throws java.sql.SQLException;
    method public void setAutoCommit(boolean) throws java.sql.SQLException;
    method public void setCatalog(String) throws java.sql.SQLException;
    method public void setClientInfo(String, String) throws java.sql.SQLClientInfoException;
    method public void setClientInfo(java.util.Properties) throws java.sql.SQLClientInfoException;
    method public void setHoldability(int) throws java.sql.SQLException;
    method public void setReadOnly(boolean) throws java.sql.SQLException;
    method public java.sql.Savepoint setSavepoint() throws java.sql.SQLException;
    method public java.sql.Savepoint setSavepoint(String) throws java.sql.SQLException;
    method public void setTransactionIsolation(int) throws java.sql.SQLException;
    method public void setTypeMap(java.util.Map<java.lang.String,java.lang.Class<?>>) throws java.sql.SQLException;
    field public static final int TRANSACTION_NONE = 0; // 0x0
    field public static final int TRANSACTION_READ_COMMITTED = 2; // 0x2
    field public static final int TRANSACTION_READ_UNCOMMITTED = 1; // 0x1
    field public static final int TRANSACTION_REPEATABLE_READ = 4; // 0x4
    field public static final int TRANSACTION_SERIALIZABLE = 8; // 0x8
  }

  public class DataTruncation extends java.sql.SQLWarning {
    ctor public DataTruncation(int, boolean, boolean, int, int);
    ctor public DataTruncation(int, boolean, boolean, int, int, Throwable);
    method public int getDataSize();
    method public int getIndex();
    method public boolean getParameter();
    method public boolean getRead();
    method public int getTransferSize();
  }

  public interface DatabaseMetaData extends java.sql.Wrapper {
    method public boolean allProceduresAreCallable() throws java.sql.SQLException;
    method public boolean allTablesAreSelectable() throws java.sql.SQLException;
    method public boolean autoCommitFailureClosesAllResultSets() throws java.sql.SQLException;
    method public boolean dataDefinitionCausesTransactionCommit() throws java.sql.SQLException;
    method public boolean dataDefinitionIgnoredInTransactions() throws java.sql.SQLException;
    method public boolean deletesAreDetected(int) throws java.sql.SQLException;
    method public boolean doesMaxRowSizeIncludeBlobs() throws java.sql.SQLException;
    method public java.sql.ResultSet getAttributes(String, String, String, String) throws java.sql.SQLException;
    method public java.sql.ResultSet getBestRowIdentifier(String, String, String, int, boolean) throws java.sql.SQLException;
    method public String getCatalogSeparator() throws java.sql.SQLException;
    method public String getCatalogTerm() throws java.sql.SQLException;
    method public java.sql.ResultSet getCatalogs() throws java.sql.SQLException;
    method public java.sql.ResultSet getClientInfoProperties() throws java.sql.SQLException;
    method public java.sql.ResultSet getColumnPrivileges(String, String, String, String) throws java.sql.SQLException;
    method public java.sql.ResultSet getColumns(String, String, String, String) throws java.sql.SQLException;
    method public java.sql.Connection getConnection() throws java.sql.SQLException;
    method public java.sql.ResultSet getCrossReference(String, String, String, String, String, String) throws java.sql.SQLException;
    method public int getDatabaseMajorVersion() throws java.sql.SQLException;
    method public int getDatabaseMinorVersion() throws java.sql.SQLException;
    method public String getDatabaseProductName() throws java.sql.SQLException;
    method public String getDatabaseProductVersion() throws java.sql.SQLException;
    method public int getDefaultTransactionIsolation() throws java.sql.SQLException;
    method public int getDriverMajorVersion();
    method public int getDriverMinorVersion();
    method public String getDriverName() throws java.sql.SQLException;
    method public String getDriverVersion() throws java.sql.SQLException;
    method public java.sql.ResultSet getExportedKeys(String, String, String) throws java.sql.SQLException;
    method public String getExtraNameCharacters() throws java.sql.SQLException;
    method public java.sql.ResultSet getFunctionColumns(String, String, String, String) throws java.sql.SQLException;
    method public java.sql.ResultSet getFunctions(String, String, String) throws java.sql.SQLException;
    method public String getIdentifierQuoteString() throws java.sql.SQLException;
    method public java.sql.ResultSet getImportedKeys(String, String, String) throws java.sql.SQLException;
    method public java.sql.ResultSet getIndexInfo(String, String, String, boolean, boolean) throws java.sql.SQLException;
    method public int getJDBCMajorVersion() throws java.sql.SQLException;
    method public int getJDBCMinorVersion() throws java.sql.SQLException;
    method public int getMaxBinaryLiteralLength() throws java.sql.SQLException;
    method public int getMaxCatalogNameLength() throws java.sql.SQLException;
    method public int getMaxCharLiteralLength() throws java.sql.SQLException;
    method public int getMaxColumnNameLength() throws java.sql.SQLException;
    method public int getMaxColumnsInGroupBy() throws java.sql.SQLException;
    method public int getMaxColumnsInIndex() throws java.sql.SQLException;
    method public int getMaxColumnsInOrderBy() throws java.sql.SQLException;
    method public int getMaxColumnsInSelect() throws java.sql.SQLException;
    method public int getMaxColumnsInTable() throws java.sql.SQLException;
    method public int getMaxConnections() throws java.sql.SQLException;
    method public int getMaxCursorNameLength() throws java.sql.SQLException;
    method public int getMaxIndexLength() throws java.sql.SQLException;
    method public int getMaxProcedureNameLength() throws java.sql.SQLException;
    method public int getMaxRowSize() throws java.sql.SQLException;
    method public int getMaxSchemaNameLength() throws java.sql.SQLException;
    method public int getMaxStatementLength() throws java.sql.SQLException;
    method public int getMaxStatements() throws java.sql.SQLException;
    method public int getMaxTableNameLength() throws java.sql.SQLException;
    method public int getMaxTablesInSelect() throws java.sql.SQLException;
    method public int getMaxUserNameLength() throws java.sql.SQLException;
    method public String getNumericFunctions() throws java.sql.SQLException;
    method public java.sql.ResultSet getPrimaryKeys(String, String, String) throws java.sql.SQLException;
    method public java.sql.ResultSet getProcedureColumns(String, String, String, String) throws java.sql.SQLException;
    method public String getProcedureTerm() throws java.sql.SQLException;
    method public java.sql.ResultSet getProcedures(String, String, String) throws java.sql.SQLException;
    method public int getResultSetHoldability() throws java.sql.SQLException;
    method public java.sql.RowIdLifetime getRowIdLifetime() throws java.sql.SQLException;
    method public String getSQLKeywords() throws java.sql.SQLException;
    method public int getSQLStateType() throws java.sql.SQLException;
    method public String getSchemaTerm() throws java.sql.SQLException;
    method public java.sql.ResultSet getSchemas() throws java.sql.SQLException;
    method public java.sql.ResultSet getSchemas(String, String) throws java.sql.SQLException;
    method public String getSearchStringEscape() throws java.sql.SQLException;
    method public String getStringFunctions() throws java.sql.SQLException;
    method public java.sql.ResultSet getSuperTables(String, String, String) throws java.sql.SQLException;
    method public java.sql.ResultSet getSuperTypes(String, String, String) throws java.sql.SQLException;
    method public String getSystemFunctions() throws java.sql.SQLException;
    method public java.sql.ResultSet getTablePrivileges(String, String, String) throws java.sql.SQLException;
    method public java.sql.ResultSet getTableTypes() throws java.sql.SQLException;
    method public java.sql.ResultSet getTables(String, String, String, String[]) throws java.sql.SQLException;
    method public String getTimeDateFunctions() throws java.sql.SQLException;
    method public java.sql.ResultSet getTypeInfo() throws java.sql.SQLException;
    method public java.sql.ResultSet getUDTs(String, String, String, int[]) throws java.sql.SQLException;
    method public String getURL() throws java.sql.SQLException;
    method public String getUserName() throws java.sql.SQLException;
    method public java.sql.ResultSet getVersionColumns(String, String, String) throws java.sql.SQLException;
    method public boolean insertsAreDetected(int) throws java.sql.SQLException;
    method public boolean isCatalogAtStart() throws java.sql.SQLException;
    method public boolean isReadOnly() throws java.sql.SQLException;
    method public boolean locatorsUpdateCopy() throws java.sql.SQLException;
    method public boolean nullPlusNonNullIsNull() throws java.sql.SQLException;
    method public boolean nullsAreSortedAtEnd() throws java.sql.SQLException;
    method public boolean nullsAreSortedAtStart() throws java.sql.SQLException;
    method public boolean nullsAreSortedHigh() throws java.sql.SQLException;
    method public boolean nullsAreSortedLow() throws java.sql.SQLException;
    method public boolean othersDeletesAreVisible(int) throws java.sql.SQLException;
    method public boolean othersInsertsAreVisible(int) throws java.sql.SQLException;
    method public boolean othersUpdatesAreVisible(int) throws java.sql.SQLException;
    method public boolean ownDeletesAreVisible(int) throws java.sql.SQLException;
    method public boolean ownInsertsAreVisible(int) throws java.sql.SQLException;
    method public boolean ownUpdatesAreVisible(int) throws java.sql.SQLException;
    method public boolean storesLowerCaseIdentifiers() throws java.sql.SQLException;
    method public boolean storesLowerCaseQuotedIdentifiers() throws java.sql.SQLException;
    method public boolean storesMixedCaseIdentifiers() throws java.sql.SQLException;
    method public boolean storesMixedCaseQuotedIdentifiers() throws java.sql.SQLException;
    method public boolean storesUpperCaseIdentifiers() throws java.sql.SQLException;
    method public boolean storesUpperCaseQuotedIdentifiers() throws java.sql.SQLException;
    method public boolean supportsANSI92EntryLevelSQL() throws java.sql.SQLException;
    method public boolean supportsANSI92FullSQL() throws java.sql.SQLException;
    method public boolean supportsANSI92IntermediateSQL() throws java.sql.SQLException;
    method public boolean supportsAlterTableWithAddColumn() throws java.sql.SQLException;
    method public boolean supportsAlterTableWithDropColumn() throws java.sql.SQLException;
    method public boolean supportsBatchUpdates() throws java.sql.SQLException;
    method public boolean supportsCatalogsInDataManipulation() throws java.sql.SQLException;
    method public boolean supportsCatalogsInIndexDefinitions() throws java.sql.SQLException;
    method public boolean supportsCatalogsInPrivilegeDefinitions() throws java.sql.SQLException;
    method public boolean supportsCatalogsInProcedureCalls() throws java.sql.SQLException;
    method public boolean supportsCatalogsInTableDefinitions() throws java.sql.SQLException;
    method public boolean supportsColumnAliasing() throws java.sql.SQLException;
    method public boolean supportsConvert() throws java.sql.SQLException;
    method public boolean supportsConvert(int, int) throws java.sql.SQLException;
    method public boolean supportsCoreSQLGrammar() throws java.sql.SQLException;
    method public boolean supportsCorrelatedSubqueries() throws java.sql.SQLException;
    method public boolean supportsDataDefinitionAndDataManipulationTransactions() throws java.sql.SQLException;
    method public boolean supportsDataManipulationTransactionsOnly() throws java.sql.SQLException;
    method public boolean supportsDifferentTableCorrelationNames() throws java.sql.SQLException;
    method public boolean supportsExpressionsInOrderBy() throws java.sql.SQLException;
    method public boolean supportsExtendedSQLGrammar() throws java.sql.SQLException;
    method public boolean supportsFullOuterJoins() throws java.sql.SQLException;
    method public boolean supportsGetGeneratedKeys() throws java.sql.SQLException;
    method public boolean supportsGroupBy() throws java.sql.SQLException;
    method public boolean supportsGroupByBeyondSelect() throws java.sql.SQLException;
    method public boolean supportsGroupByUnrelated() throws java.sql.SQLException;
    method public boolean supportsIntegrityEnhancementFacility() throws java.sql.SQLException;
    method public boolean supportsLikeEscapeClause() throws java.sql.SQLException;
    method public boolean supportsLimitedOuterJoins() throws java.sql.SQLException;
    method public boolean supportsMinimumSQLGrammar() throws java.sql.SQLException;
    method public boolean supportsMixedCaseIdentifiers() throws java.sql.SQLException;
    method public boolean supportsMixedCaseQuotedIdentifiers() throws java.sql.SQLException;
    method public boolean supportsMultipleOpenResults() throws java.sql.SQLException;
    method public boolean supportsMultipleResultSets() throws java.sql.SQLException;
    method public boolean supportsMultipleTransactions() throws java.sql.SQLException;
    method public boolean supportsNamedParameters() throws java.sql.SQLException;
    method public boolean supportsNonNullableColumns() throws java.sql.SQLException;
    method public boolean supportsOpenCursorsAcrossCommit() throws java.sql.SQLException;
    method public boolean supportsOpenCursorsAcrossRollback() throws java.sql.SQLException;
    method public boolean supportsOpenStatementsAcrossCommit() throws java.sql.SQLException;
    method public boolean supportsOpenStatementsAcrossRollback() throws java.sql.SQLException;
    method public boolean supportsOrderByUnrelated() throws java.sql.SQLException;
    method public boolean supportsOuterJoins() throws java.sql.SQLException;
    method public boolean supportsPositionedDelete() throws java.sql.SQLException;
    method public boolean supportsPositionedUpdate() throws java.sql.SQLException;
    method public boolean supportsResultSetConcurrency(int, int) throws java.sql.SQLException;
    method public boolean supportsResultSetHoldability(int) throws java.sql.SQLException;
    method public boolean supportsResultSetType(int) throws java.sql.SQLException;
    method public boolean supportsSavepoints() throws java.sql.SQLException;
    method public boolean supportsSchemasInDataManipulation() throws java.sql.SQLException;
    method public boolean supportsSchemasInIndexDefinitions() throws java.sql.SQLException;
    method public boolean supportsSchemasInPrivilegeDefinitions() throws java.sql.SQLException;
    method public boolean supportsSchemasInProcedureCalls() throws java.sql.SQLException;
    method public boolean supportsSchemasInTableDefinitions() throws java.sql.SQLException;
    method public boolean supportsSelectForUpdate() throws java.sql.SQLException;
    method public boolean supportsStatementPooling() throws java.sql.SQLException;
    method public boolean supportsStoredFunctionsUsingCallSyntax() throws java.sql.SQLException;
    method public boolean supportsStoredProcedures() throws java.sql.SQLException;
    method public boolean supportsSubqueriesInComparisons() throws java.sql.SQLException;
    method public boolean supportsSubqueriesInExists() throws java.sql.SQLException;
    method public boolean supportsSubqueriesInIns() throws java.sql.SQLException;
    method public boolean supportsSubqueriesInQuantifieds() throws java.sql.SQLException;
    method public boolean supportsTableCorrelationNames() throws java.sql.SQLException;
    method public boolean supportsTransactionIsolationLevel(int) throws java.sql.SQLException;
    method public boolean supportsTransactions() throws java.sql.SQLException;
    method public boolean supportsUnion() throws java.sql.SQLException;
    method public boolean supportsUnionAll() throws java.sql.SQLException;
    method public boolean updatesAreDetected(int) throws java.sql.SQLException;
    method public boolean usesLocalFilePerTable() throws java.sql.SQLException;
    method public boolean usesLocalFiles() throws java.sql.SQLException;
    field public static final short attributeNoNulls = 0; // 0x0
    field public static final short attributeNullable = 1; // 0x1
    field public static final short attributeNullableUnknown = 2; // 0x2
    field public static final int bestRowNotPseudo = 1; // 0x1
    field public static final int bestRowPseudo = 2; // 0x2
    field public static final int bestRowSession = 2; // 0x2
    field public static final int bestRowTemporary = 0; // 0x0
    field public static final int bestRowTransaction = 1; // 0x1
    field public static final int bestRowUnknown = 0; // 0x0
    field public static final int columnNoNulls = 0; // 0x0
    field public static final int columnNullable = 1; // 0x1
    field public static final int columnNullableUnknown = 2; // 0x2
    field public static final int functionColumnIn = 1; // 0x1
    field public static final int functionColumnInOut = 2; // 0x2
    field public static final int functionColumnOut = 3; // 0x3
    field public static final int functionColumnResult = 5; // 0x5
    field public static final int functionColumnUnknown = 0; // 0x0
    field public static final int functionNoNulls = 0; // 0x0
    field public static final int functionNoTable = 1; // 0x1
    field public static final int functionNullable = 1; // 0x1
    field public static final int functionNullableUnknown = 2; // 0x2
    field public static final int functionResultUnknown = 0; // 0x0
    field public static final int functionReturn = 4; // 0x4
    field public static final int functionReturnsTable = 2; // 0x2
    field public static final int importedKeyCascade = 0; // 0x0
    field public static final int importedKeyInitiallyDeferred = 5; // 0x5
    field public static final int importedKeyInitiallyImmediate = 6; // 0x6
    field public static final int importedKeyNoAction = 3; // 0x3
    field public static final int importedKeyNotDeferrable = 7; // 0x7
    field public static final int importedKeyRestrict = 1; // 0x1
    field public static final int importedKeySetDefault = 4; // 0x4
    field public static final int importedKeySetNull = 2; // 0x2
    field public static final int procedureColumnIn = 1; // 0x1
    field public static final int procedureColumnInOut = 2; // 0x2
    field public static final int procedureColumnOut = 4; // 0x4
    field public static final int procedureColumnResult = 3; // 0x3
    field public static final int procedureColumnReturn = 5; // 0x5
    field public static final int procedureColumnUnknown = 0; // 0x0
    field public static final int procedureNoNulls = 0; // 0x0
    field public static final int procedureNoResult = 1; // 0x1
    field public static final int procedureNullable = 1; // 0x1
    field public static final int procedureNullableUnknown = 2; // 0x2
    field public static final int procedureResultUnknown = 0; // 0x0
    field public static final int procedureReturnsResult = 2; // 0x2
    field public static final int sqlStateSQL = 2; // 0x2
    field public static final int sqlStateSQL99 = 2; // 0x2
    field public static final int sqlStateXOpen = 1; // 0x1
    field public static final short tableIndexClustered = 1; // 0x1
    field public static final short tableIndexHashed = 2; // 0x2
    field public static final short tableIndexOther = 3; // 0x3
    field public static final short tableIndexStatistic = 0; // 0x0
    field public static final int typeNoNulls = 0; // 0x0
    field public static final int typeNullable = 1; // 0x1
    field public static final int typeNullableUnknown = 2; // 0x2
    field public static final int typePredBasic = 2; // 0x2
    field public static final int typePredChar = 1; // 0x1
    field public static final int typePredNone = 0; // 0x0
    field public static final int typeSearchable = 3; // 0x3
    field public static final int versionColumnNotPseudo = 1; // 0x1
    field public static final int versionColumnPseudo = 2; // 0x2
    field public static final int versionColumnUnknown = 0; // 0x0
  }

  public class Date extends java.util.Date {
    ctor @Deprecated public Date(int, int, int);
    ctor public Date(long);
    method public static java.sql.Date valueOf(String);
  }

  public interface Driver {
    method public boolean acceptsURL(String) throws java.sql.SQLException;
    method public java.sql.Connection connect(String, java.util.Properties) throws java.sql.SQLException;
    method public int getMajorVersion();
    method public int getMinorVersion();
    method public java.sql.DriverPropertyInfo[] getPropertyInfo(String, java.util.Properties) throws java.sql.SQLException;
    method public boolean jdbcCompliant();
  }

  public class DriverManager {
    method public static void deregisterDriver(java.sql.Driver) throws java.sql.SQLException;
    method public static java.sql.Connection getConnection(String, java.util.Properties) throws java.sql.SQLException;
    method public static java.sql.Connection getConnection(String, String, String) throws java.sql.SQLException;
    method public static java.sql.Connection getConnection(String) throws java.sql.SQLException;
    method public static java.sql.Driver getDriver(String) throws java.sql.SQLException;
    method public static java.util.Enumeration<java.sql.Driver> getDrivers();
    method @Deprecated public static java.io.PrintStream getLogStream();
    method public static java.io.PrintWriter getLogWriter();
    method public static int getLoginTimeout();
    method public static void println(String);
    method public static void registerDriver(java.sql.Driver) throws java.sql.SQLException;
    method @Deprecated public static void setLogStream(java.io.PrintStream);
    method public static void setLogWriter(java.io.PrintWriter);
    method public static void setLoginTimeout(int);
  }

  public class DriverPropertyInfo {
    ctor public DriverPropertyInfo(String, String);
    field public String[] choices;
    field public String description;
    field public String name;
    field public boolean required;
    field public String value;
  }

  public interface NClob extends java.sql.Clob {
  }

  public interface ParameterMetaData extends java.sql.Wrapper {
    method public String getParameterClassName(int) throws java.sql.SQLException;
    method public int getParameterCount() throws java.sql.SQLException;
    method public int getParameterMode(int) throws java.sql.SQLException;
    method public int getParameterType(int) throws java.sql.SQLException;
    method public String getParameterTypeName(int) throws java.sql.SQLException;
    method public int getPrecision(int) throws java.sql.SQLException;
    method public int getScale(int) throws java.sql.SQLException;
    method public int isNullable(int) throws java.sql.SQLException;
    method public boolean isSigned(int) throws java.sql.SQLException;
    field public static final int parameterModeIn = 1; // 0x1
    field public static final int parameterModeInOut = 2; // 0x2
    field public static final int parameterModeOut = 4; // 0x4
    field public static final int parameterModeUnknown = 0; // 0x0
    field public static final int parameterNoNulls = 0; // 0x0
    field public static final int parameterNullable = 1; // 0x1
    field public static final int parameterNullableUnknown = 2; // 0x2
  }

  public interface PreparedStatement extends java.sql.Statement {
    method public void addBatch() throws java.sql.SQLException;
    method public void clearParameters() throws java.sql.SQLException;
    method public boolean execute() throws java.sql.SQLException;
    method public java.sql.ResultSet executeQuery() throws java.sql.SQLException;
    method public int executeUpdate() throws java.sql.SQLException;
    method public java.sql.ResultSetMetaData getMetaData() throws java.sql.SQLException;
    method public java.sql.ParameterMetaData getParameterMetaData() throws java.sql.SQLException;
    method public void setArray(int, java.sql.Array) throws java.sql.SQLException;
    method public void setAsciiStream(int, java.io.InputStream, int) throws java.sql.SQLException;
    method public void setAsciiStream(int, java.io.InputStream, long) throws java.sql.SQLException;
    method public void setAsciiStream(int, java.io.InputStream) throws java.sql.SQLException;
    method public void setBigDecimal(int, java.math.BigDecimal) throws java.sql.SQLException;
    method public void setBinaryStream(int, java.io.InputStream, int) throws java.sql.SQLException;
    method public void setBinaryStream(int, java.io.InputStream, long) throws java.sql.SQLException;
    method public void setBinaryStream(int, java.io.InputStream) throws java.sql.SQLException;
    method public void setBlob(int, java.sql.Blob) throws java.sql.SQLException;
    method public void setBlob(int, java.io.InputStream, long) throws java.sql.SQLException;
    method public void setBlob(int, java.io.InputStream) throws java.sql.SQLException;
    method public void setBoolean(int, boolean) throws java.sql.SQLException;
    method public void setByte(int, byte) throws java.sql.SQLException;
    method public void setBytes(int, byte[]) throws java.sql.SQLException;
    method public void setCharacterStream(int, java.io.Reader, int) throws java.sql.SQLException;
    method public void setCharacterStream(int, java.io.Reader, long) throws java.sql.SQLException;
    method public void setCharacterStream(int, java.io.Reader) throws java.sql.SQLException;
    method public void setClob(int, java.sql.Clob) throws java.sql.SQLException;
    method public void setClob(int, java.io.Reader, long) throws java.sql.SQLException;
    method public void setClob(int, java.io.Reader) throws java.sql.SQLException;
    method public void setDate(int, java.sql.Date) throws java.sql.SQLException;
    method public void setDate(int, java.sql.Date, java.util.Calendar) throws java.sql.SQLException;
    method public void setDouble(int, double) throws java.sql.SQLException;
    method public void setFloat(int, float) throws java.sql.SQLException;
    method public void setInt(int, int) throws java.sql.SQLException;
    method public void setLong(int, long) throws java.sql.SQLException;
    method public void setNCharacterStream(int, java.io.Reader, long) throws java.sql.SQLException;
    method public void setNCharacterStream(int, java.io.Reader) throws java.sql.SQLException;
    method public void setNClob(int, java.sql.NClob) throws java.sql.SQLException;
    method public void setNClob(int, java.io.Reader, long) throws java.sql.SQLException;
    method public void setNClob(int, java.io.Reader) throws java.sql.SQLException;
    method public void setNString(int, String) throws java.sql.SQLException;
    method public void setNull(int, int) throws java.sql.SQLException;
    method public void setNull(int, int, String) throws java.sql.SQLException;
    method public void setObject(int, Object, int) throws java.sql.SQLException;
    method public void setObject(int, Object) throws java.sql.SQLException;
    method public void setObject(int, Object, int, int) throws java.sql.SQLException;
    method public void setRef(int, java.sql.Ref) throws java.sql.SQLException;
    method public void setRowId(int, java.sql.RowId) throws java.sql.SQLException;
    method public void setSQLXML(int, java.sql.SQLXML) throws java.sql.SQLException;
    method public void setShort(int, short) throws java.sql.SQLException;
    method public void setString(int, String) throws java.sql.SQLException;
    method public void setTime(int, java.sql.Time) throws java.sql.SQLException;
    method public void setTime(int, java.sql.Time, java.util.Calendar) throws java.sql.SQLException;
    method public void setTimestamp(int, java.sql.Timestamp) throws java.sql.SQLException;
    method public void setTimestamp(int, java.sql.Timestamp, java.util.Calendar) throws java.sql.SQLException;
    method public void setURL(int, java.net.URL) throws java.sql.SQLException;
    method @Deprecated public void setUnicodeStream(int, java.io.InputStream, int) throws java.sql.SQLException;
  }

  public interface Ref {
    method public String getBaseTypeName() throws java.sql.SQLException;
    method public Object getObject(java.util.Map<java.lang.String,java.lang.Class<?>>) throws java.sql.SQLException;
    method public Object getObject() throws java.sql.SQLException;
    method public void setObject(Object) throws java.sql.SQLException;
  }

  public interface ResultSet extends java.sql.Wrapper java.lang.AutoCloseable {
    method public boolean absolute(int) throws java.sql.SQLException;
    method public void afterLast() throws java.sql.SQLException;
    method public void beforeFirst() throws java.sql.SQLException;
    method public void cancelRowUpdates() throws java.sql.SQLException;
    method public void clearWarnings() throws java.sql.SQLException;
    method public void close() throws java.sql.SQLException;
    method public void deleteRow() throws java.sql.SQLException;
    method public int findColumn(String) throws java.sql.SQLException;
    method public boolean first() throws java.sql.SQLException;
    method public java.sql.Array getArray(int) throws java.sql.SQLException;
    method public java.sql.Array getArray(String) throws java.sql.SQLException;
    method public java.io.InputStream getAsciiStream(int) throws java.sql.SQLException;
    method public java.io.InputStream getAsciiStream(String) throws java.sql.SQLException;
    method @Deprecated public java.math.BigDecimal getBigDecimal(int, int) throws java.sql.SQLException;
    method @Deprecated public java.math.BigDecimal getBigDecimal(String, int) throws java.sql.SQLException;
    method public java.math.BigDecimal getBigDecimal(int) throws java.sql.SQLException;
    method public java.math.BigDecimal getBigDecimal(String) throws java.sql.SQLException;
    method public java.io.InputStream getBinaryStream(int) throws java.sql.SQLException;
    method public java.io.InputStream getBinaryStream(String) throws java.sql.SQLException;
    method public java.sql.Blob getBlob(int) throws java.sql.SQLException;
    method public java.sql.Blob getBlob(String) throws java.sql.SQLException;
    method public boolean getBoolean(int) throws java.sql.SQLException;
    method public boolean getBoolean(String) throws java.sql.SQLException;
    method public byte getByte(int) throws java.sql.SQLException;
    method public byte getByte(String) throws java.sql.SQLException;
    method public byte[] getBytes(int) throws java.sql.SQLException;
    method public byte[] getBytes(String) throws java.sql.SQLException;
    method public java.io.Reader getCharacterStream(int) throws java.sql.SQLException;
    method public java.io.Reader getCharacterStream(String) throws java.sql.SQLException;
    method public java.sql.Clob getClob(int) throws java.sql.SQLException;
    method public java.sql.Clob getClob(String) throws java.sql.SQLException;
    method public int getConcurrency() throws java.sql.SQLException;
    method public String getCursorName() throws java.sql.SQLException;
    method public java.sql.Date getDate(int) throws java.sql.SQLException;
    method public java.sql.Date getDate(String) throws java.sql.SQLException;
    method public java.sql.Date getDate(int, java.util.Calendar) throws java.sql.SQLException;
    method public java.sql.Date getDate(String, java.util.Calendar) throws java.sql.SQLException;
    method public double getDouble(int) throws java.sql.SQLException;
    method public double getDouble(String) throws java.sql.SQLException;
    method public int getFetchDirection() throws java.sql.SQLException;
    method public int getFetchSize() throws java.sql.SQLException;
    method public float getFloat(int) throws java.sql.SQLException;
    method public float getFloat(String) throws java.sql.SQLException;
    method public int getHoldability() throws java.sql.SQLException;
    method public int getInt(int) throws java.sql.SQLException;
    method public int getInt(String) throws java.sql.SQLException;
    method public long getLong(int) throws java.sql.SQLException;
    method public long getLong(String) throws java.sql.SQLException;
    method public java.sql.ResultSetMetaData getMetaData() throws java.sql.SQLException;
    method public java.io.Reader getNCharacterStream(int) throws java.sql.SQLException;
    method public java.io.Reader getNCharacterStream(String) throws java.sql.SQLException;
    method public java.sql.NClob getNClob(int) throws java.sql.SQLException;
    method public java.sql.NClob getNClob(String) throws java.sql.SQLException;
    method public String getNString(int) throws java.sql.SQLException;
    method public String getNString(String) throws java.sql.SQLException;
    method public Object getObject(int) throws java.sql.SQLException;
    method public Object getObject(String) throws java.sql.SQLException;
    method public Object getObject(int, java.util.Map<java.lang.String,java.lang.Class<?>>) throws java.sql.SQLException;
    method public Object getObject(String, java.util.Map<java.lang.String,java.lang.Class<?>>) throws java.sql.SQLException;
    method public java.sql.Ref getRef(int) throws java.sql.SQLException;
    method public java.sql.Ref getRef(String) throws java.sql.SQLException;
    method public int getRow() throws java.sql.SQLException;
    method public java.sql.RowId getRowId(int) throws java.sql.SQLException;
    method public java.sql.RowId getRowId(String) throws java.sql.SQLException;
    method public java.sql.SQLXML getSQLXML(int) throws java.sql.SQLException;
    method public java.sql.SQLXML getSQLXML(String) throws java.sql.SQLException;
    method public short getShort(int) throws java.sql.SQLException;
    method public short getShort(String) throws java.sql.SQLException;
    method public java.sql.Statement getStatement() throws java.sql.SQLException;
    method public String getString(int) throws java.sql.SQLException;
    method public String getString(String) throws java.sql.SQLException;
    method public java.sql.Time getTime(int) throws java.sql.SQLException;
    method public java.sql.Time getTime(String) throws java.sql.SQLException;
    method public java.sql.Time getTime(int, java.util.Calendar) throws java.sql.SQLException;
    method public java.sql.Time getTime(String, java.util.Calendar) throws java.sql.SQLException;
    method public java.sql.Timestamp getTimestamp(int) throws java.sql.SQLException;
    method public java.sql.Timestamp getTimestamp(String) throws java.sql.SQLException;
    method public java.sql.Timestamp getTimestamp(int, java.util.Calendar) throws java.sql.SQLException;
    method public java.sql.Timestamp getTimestamp(String, java.util.Calendar) throws java.sql.SQLException;
    method public int getType() throws java.sql.SQLException;
    method public java.net.URL getURL(int) throws java.sql.SQLException;
    method public java.net.URL getURL(String) throws java.sql.SQLException;
    method @Deprecated public java.io.InputStream getUnicodeStream(int) throws java.sql.SQLException;
    method @Deprecated public java.io.InputStream getUnicodeStream(String) throws java.sql.SQLException;
    method public java.sql.SQLWarning getWarnings() throws java.sql.SQLException;
    method public void insertRow() throws java.sql.SQLException;
    method public boolean isAfterLast() throws java.sql.SQLException;
    method public boolean isBeforeFirst() throws java.sql.SQLException;
    method public boolean isClosed() throws java.sql.SQLException;
    method public boolean isFirst() throws java.sql.SQLException;
    method public boolean isLast() throws java.sql.SQLException;
    method public boolean last() throws java.sql.SQLException;
    method public void moveToCurrentRow() throws java.sql.SQLException;
    method public void moveToInsertRow() throws java.sql.SQLException;
    method public boolean next() throws java.sql.SQLException;
    method public boolean previous() throws java.sql.SQLException;
    method public void refreshRow() throws java.sql.SQLException;
    method public boolean relative(int) throws java.sql.SQLException;
    method public boolean rowDeleted() throws java.sql.SQLException;
    method public boolean rowInserted() throws java.sql.SQLException;
    method public boolean rowUpdated() throws java.sql.SQLException;
    method public void setFetchDirection(int) throws java.sql.SQLException;
    method public void setFetchSize(int) throws java.sql.SQLException;
    method public void updateArray(int, java.sql.Array) throws java.sql.SQLException;
    method public void updateArray(String, java.sql.Array) throws java.sql.SQLException;
    method public void updateAsciiStream(int, java.io.InputStream, int) throws java.sql.SQLException;
    method public void updateAsciiStream(String, java.io.InputStream, int) throws java.sql.SQLException;
    method public void updateAsciiStream(int, java.io.InputStream, long) throws java.sql.SQLException;
    method public void updateAsciiStream(String, java.io.InputStream, long) throws java.sql.SQLException;
    method public void updateAsciiStream(int, java.io.InputStream) throws java.sql.SQLException;
    method public void updateAsciiStream(String, java.io.InputStream) throws java.sql.SQLException;
    method public void updateBigDecimal(int, java.math.BigDecimal) throws java.sql.SQLException;
    method public void updateBigDecimal(String, java.math.BigDecimal) throws java.sql.SQLException;
    method public void updateBinaryStream(int, java.io.InputStream, int) throws java.sql.SQLException;
    method public void updateBinaryStream(String, java.io.InputStream, int) throws java.sql.SQLException;
    method public void updateBinaryStream(int, java.io.InputStream, long) throws java.sql.SQLException;
    method public void updateBinaryStream(String, java.io.InputStream, long) throws java.sql.SQLException;
    method public void updateBinaryStream(int, java.io.InputStream) throws java.sql.SQLException;
    method public void updateBinaryStream(String, java.io.InputStream) throws java.sql.SQLException;
    method public void updateBlob(int, java.sql.Blob) throws java.sql.SQLException;
    method public void updateBlob(String, java.sql.Blob) throws java.sql.SQLException;
    method public void updateBlob(int, java.io.InputStream, long) throws java.sql.SQLException;
    method public void updateBlob(String, java.io.InputStream, long) throws java.sql.SQLException;
    method public void updateBlob(int, java.io.InputStream) throws java.sql.SQLException;
    method public void updateBlob(String, java.io.InputStream) throws java.sql.SQLException;
    method public void updateBoolean(int, boolean) throws java.sql.SQLException;
    method public void updateBoolean(String, boolean) throws java.sql.SQLException;
    method public void updateByte(int, byte) throws java.sql.SQLException;
    method public void updateByte(String, byte) throws java.sql.SQLException;
    method public void updateBytes(int, byte[]) throws java.sql.SQLException;
    method public void updateBytes(String, byte[]) throws java.sql.SQLException;
    method public void updateCharacterStream(int, java.io.Reader, int) throws java.sql.SQLException;
    method public void updateCharacterStream(String, java.io.Reader, int) throws java.sql.SQLException;
    method public void updateCharacterStream(int, java.io.Reader, long) throws java.sql.SQLException;
    method public void updateCharacterStream(String, java.io.Reader, long) throws java.sql.SQLException;
    method public void updateCharacterStream(int, java.io.Reader) throws java.sql.SQLException;
    method public void updateCharacterStream(String, java.io.Reader) throws java.sql.SQLException;
    method public void updateClob(int, java.sql.Clob) throws java.sql.SQLException;
    method public void updateClob(String, java.sql.Clob) throws java.sql.SQLException;
    method public void updateClob(int, java.io.Reader, long) throws java.sql.SQLException;
    method public void updateClob(String, java.io.Reader, long) throws java.sql.SQLException;
    method public void updateClob(int, java.io.Reader) throws java.sql.SQLException;
    method public void updateClob(String, java.io.Reader) throws java.sql.SQLException;
    method public void updateDate(int, java.sql.Date) throws java.sql.SQLException;
    method public void updateDate(String, java.sql.Date) throws java.sql.SQLException;
    method public void updateDouble(int, double) throws java.sql.SQLException;
    method public void updateDouble(String, double) throws java.sql.SQLException;
    method public void updateFloat(int, float) throws java.sql.SQLException;
    method public void updateFloat(String, float) throws java.sql.SQLException;
    method public void updateInt(int, int) throws java.sql.SQLException;
    method public void updateInt(String, int) throws java.sql.SQLException;
    method public void updateLong(int, long) throws java.sql.SQLException;
    method public void updateLong(String, long) throws java.sql.SQLException;
    method public void updateNCharacterStream(int, java.io.Reader, long) throws java.sql.SQLException;
    method public void updateNCharacterStream(String, java.io.Reader, long) throws java.sql.SQLException;
    method public void updateNCharacterStream(int, java.io.Reader) throws java.sql.SQLException;
    method public void updateNCharacterStream(String, java.io.Reader) throws java.sql.SQLException;
    method public void updateNClob(int, java.sql.NClob) throws java.sql.SQLException;
    method public void updateNClob(String, java.sql.NClob) throws java.sql.SQLException;
    method public void updateNClob(int, java.io.Reader, long) throws java.sql.SQLException;
    method public void updateNClob(String, java.io.Reader, long) throws java.sql.SQLException;
    method public void updateNClob(int, java.io.Reader) throws java.sql.SQLException;
    method public void updateNClob(String, java.io.Reader) throws java.sql.SQLException;
    method public void updateNString(int, String) throws java.sql.SQLException;
    method public void updateNString(String, String) throws java.sql.SQLException;
    method public void updateNull(int) throws java.sql.SQLException;
    method public void updateNull(String) throws java.sql.SQLException;
    method public void updateObject(int, Object, int) throws java.sql.SQLException;
    method public void updateObject(int, Object) throws java.sql.SQLException;
    method public void updateObject(String, Object, int) throws java.sql.SQLException;
    method public void updateObject(String, Object) throws java.sql.SQLException;
    method public void updateRef(int, java.sql.Ref) throws java.sql.SQLException;
    method public void updateRef(String, java.sql.Ref) throws java.sql.SQLException;
    method public void updateRow() throws java.sql.SQLException;
    method public void updateRowId(int, java.sql.RowId) throws java.sql.SQLException;
    method public void updateRowId(String, java.sql.RowId) throws java.sql.SQLException;
    method public void updateSQLXML(int, java.sql.SQLXML) throws java.sql.SQLException;
    method public void updateSQLXML(String, java.sql.SQLXML) throws java.sql.SQLException;
    method public void updateShort(int, short) throws java.sql.SQLException;
    method public void updateShort(String, short) throws java.sql.SQLException;
    method public void updateString(int, String) throws java.sql.SQLException;
    method public void updateString(String, String) throws java.sql.SQLException;
    method public void updateTime(int, java.sql.Time) throws java.sql.SQLException;
    method public void updateTime(String, java.sql.Time) throws java.sql.SQLException;
    method public void updateTimestamp(int, java.sql.Timestamp) throws java.sql.SQLException;
    method public void updateTimestamp(String, java.sql.Timestamp) throws java.sql.SQLException;
    method public boolean wasNull() throws java.sql.SQLException;
    field public static final int CLOSE_CURSORS_AT_COMMIT = 2; // 0x2
    field public static final int CONCUR_READ_ONLY = 1007; // 0x3ef
    field public static final int CONCUR_UPDATABLE = 1008; // 0x3f0
    field public static final int FETCH_FORWARD = 1000; // 0x3e8
    field public static final int FETCH_REVERSE = 1001; // 0x3e9
    field public static final int FETCH_UNKNOWN = 1002; // 0x3ea
    field public static final int HOLD_CURSORS_OVER_COMMIT = 1; // 0x1
    field public static final int TYPE_FORWARD_ONLY = 1003; // 0x3eb
    field public static final int TYPE_SCROLL_INSENSITIVE = 1004; // 0x3ec
    field public static final int TYPE_SCROLL_SENSITIVE = 1005; // 0x3ed
  }

  public interface ResultSetMetaData extends java.sql.Wrapper {
    method public String getCatalogName(int) throws java.sql.SQLException;
    method public String getColumnClassName(int) throws java.sql.SQLException;
    method public int getColumnCount() throws java.sql.SQLException;
    method public int getColumnDisplaySize(int) throws java.sql.SQLException;
    method public String getColumnLabel(int) throws java.sql.SQLException;
    method public String getColumnName(int) throws java.sql.SQLException;
    method public int getColumnType(int) throws java.sql.SQLException;
    method public String getColumnTypeName(int) throws java.sql.SQLException;
    method public int getPrecision(int) throws java.sql.SQLException;
    method public int getScale(int) throws java.sql.SQLException;
    method public String getSchemaName(int) throws java.sql.SQLException;
    method public String getTableName(int) throws java.sql.SQLException;
    method public boolean isAutoIncrement(int) throws java.sql.SQLException;
    method public boolean isCaseSensitive(int) throws java.sql.SQLException;
    method public boolean isCurrency(int) throws java.sql.SQLException;
    method public boolean isDefinitelyWritable(int) throws java.sql.SQLException;
    method public int isNullable(int) throws java.sql.SQLException;
    method public boolean isReadOnly(int) throws java.sql.SQLException;
    method public boolean isSearchable(int) throws java.sql.SQLException;
    method public boolean isSigned(int) throws java.sql.SQLException;
    method public boolean isWritable(int) throws java.sql.SQLException;
    field public static final int columnNoNulls = 0; // 0x0
    field public static final int columnNullable = 1; // 0x1
    field public static final int columnNullableUnknown = 2; // 0x2
  }

  public interface RowId {
    method public boolean equals(Object);
    method public byte[] getBytes();
    method public int hashCode();
    method public String toString();
  }

  public enum RowIdLifetime {
    enum_constant public static final java.sql.RowIdLifetime ROWID_UNSUPPORTED;
    enum_constant public static final java.sql.RowIdLifetime ROWID_VALID_FOREVER;
    enum_constant public static final java.sql.RowIdLifetime ROWID_VALID_OTHER;
    enum_constant public static final java.sql.RowIdLifetime ROWID_VALID_SESSION;
    enum_constant public static final java.sql.RowIdLifetime ROWID_VALID_TRANSACTION;
  }

  public class SQLClientInfoException extends java.sql.SQLException {
    ctor public SQLClientInfoException();
    ctor public SQLClientInfoException(java.util.Map<java.lang.String,java.sql.ClientInfoStatus>);
    ctor public SQLClientInfoException(java.util.Map<java.lang.String,java.sql.ClientInfoStatus>, Throwable);
    ctor public SQLClientInfoException(String, java.util.Map<java.lang.String,java.sql.ClientInfoStatus>);
    ctor public SQLClientInfoException(String, java.util.Map<java.lang.String,java.sql.ClientInfoStatus>, Throwable);
    ctor public SQLClientInfoException(String, String, java.util.Map<java.lang.String,java.sql.ClientInfoStatus>);
    ctor public SQLClientInfoException(String, String, java.util.Map<java.lang.String,java.sql.ClientInfoStatus>, Throwable);
    ctor public SQLClientInfoException(String, String, int, java.util.Map<java.lang.String,java.sql.ClientInfoStatus>);
    ctor public SQLClientInfoException(String, String, int, java.util.Map<java.lang.String,java.sql.ClientInfoStatus>, Throwable);
    method public java.util.Map<java.lang.String,java.sql.ClientInfoStatus> getFailedProperties();
  }

  public interface SQLData {
    method public String getSQLTypeName() throws java.sql.SQLException;
    method public void readSQL(java.sql.SQLInput, String) throws java.sql.SQLException;
    method public void writeSQL(java.sql.SQLOutput) throws java.sql.SQLException;
  }

  public class SQLDataException extends java.sql.SQLNonTransientException {
    ctor public SQLDataException();
    ctor public SQLDataException(String);
    ctor public SQLDataException(String, String);
    ctor public SQLDataException(String, String, int);
    ctor public SQLDataException(Throwable);
    ctor public SQLDataException(String, Throwable);
    ctor public SQLDataException(String, String, Throwable);
    ctor public SQLDataException(String, String, int, Throwable);
  }

  public class SQLException extends java.lang.Exception implements java.lang.Iterable<java.lang.Throwable> {
    ctor public SQLException(String, String, int);
    ctor public SQLException(String, String);
    ctor public SQLException(String);
    ctor public SQLException();
    ctor public SQLException(Throwable);
    ctor public SQLException(String, Throwable);
    ctor public SQLException(String, String, Throwable);
    ctor public SQLException(String, String, int, Throwable);
    method public int getErrorCode();
    method public java.sql.SQLException getNextException();
    method public String getSQLState();
    method public java.util.Iterator<java.lang.Throwable> iterator();
    method public void setNextException(java.sql.SQLException);
  }

  public class SQLFeatureNotSupportedException extends java.sql.SQLNonTransientException {
    ctor public SQLFeatureNotSupportedException();
    ctor public SQLFeatureNotSupportedException(String);
    ctor public SQLFeatureNotSupportedException(String, String);
    ctor public SQLFeatureNotSupportedException(String, String, int);
    ctor public SQLFeatureNotSupportedException(Throwable);
    ctor public SQLFeatureNotSupportedException(String, Throwable);
    ctor public SQLFeatureNotSupportedException(String, String, Throwable);
    ctor public SQLFeatureNotSupportedException(String, String, int, Throwable);
  }

  public interface SQLInput {
    method public java.sql.Array readArray() throws java.sql.SQLException;
    method public java.io.InputStream readAsciiStream() throws java.sql.SQLException;
    method public java.math.BigDecimal readBigDecimal() throws java.sql.SQLException;
    method public java.io.InputStream readBinaryStream() throws java.sql.SQLException;
    method public java.sql.Blob readBlob() throws java.sql.SQLException;
    method public boolean readBoolean() throws java.sql.SQLException;
    method public byte readByte() throws java.sql.SQLException;
    method public byte[] readBytes() throws java.sql.SQLException;
    method public java.io.Reader readCharacterStream() throws java.sql.SQLException;
    method public java.sql.Clob readClob() throws java.sql.SQLException;
    method public java.sql.Date readDate() throws java.sql.SQLException;
    method public double readDouble() throws java.sql.SQLException;
    method public float readFloat() throws java.sql.SQLException;
    method public int readInt() throws java.sql.SQLException;
    method public long readLong() throws java.sql.SQLException;
    method public java.sql.NClob readNClob() throws java.sql.SQLException;
    method public String readNString() throws java.sql.SQLException;
    method public Object readObject() throws java.sql.SQLException;
    method public java.sql.Ref readRef() throws java.sql.SQLException;
    method public java.sql.RowId readRowId() throws java.sql.SQLException;
    method public java.sql.SQLXML readSQLXML() throws java.sql.SQLException;
    method public short readShort() throws java.sql.SQLException;
    method public String readString() throws java.sql.SQLException;
    method public java.sql.Time readTime() throws java.sql.SQLException;
    method public java.sql.Timestamp readTimestamp() throws java.sql.SQLException;
    method public java.net.URL readURL() throws java.sql.SQLException;
    method public boolean wasNull() throws java.sql.SQLException;
  }

  public class SQLIntegrityConstraintViolationException extends java.sql.SQLNonTransientException {
    ctor public SQLIntegrityConstraintViolationException();
    ctor public SQLIntegrityConstraintViolationException(String);
    ctor public SQLIntegrityConstraintViolationException(String, String);
    ctor public SQLIntegrityConstraintViolationException(String, String, int);
    ctor public SQLIntegrityConstraintViolationException(Throwable);
    ctor public SQLIntegrityConstraintViolationException(String, Throwable);
    ctor public SQLIntegrityConstraintViolationException(String, String, Throwable);
    ctor public SQLIntegrityConstraintViolationException(String, String, int, Throwable);
  }

  public class SQLInvalidAuthorizationSpecException extends java.sql.SQLNonTransientException {
    ctor public SQLInvalidAuthorizationSpecException();
    ctor public SQLInvalidAuthorizationSpecException(String);
    ctor public SQLInvalidAuthorizationSpecException(String, String);
    ctor public SQLInvalidAuthorizationSpecException(String, String, int);
    ctor public SQLInvalidAuthorizationSpecException(Throwable);
    ctor public SQLInvalidAuthorizationSpecException(String, Throwable);
    ctor public SQLInvalidAuthorizationSpecException(String, String, Throwable);
    ctor public SQLInvalidAuthorizationSpecException(String, String, int, Throwable);
  }

  public class SQLNonTransientConnectionException extends java.sql.SQLNonTransientException {
    ctor public SQLNonTransientConnectionException();
    ctor public SQLNonTransientConnectionException(String);
    ctor public SQLNonTransientConnectionException(String, String);
    ctor public SQLNonTransientConnectionException(String, String, int);
    ctor public SQLNonTransientConnectionException(Throwable);
    ctor public SQLNonTransientConnectionException(String, Throwable);
    ctor public SQLNonTransientConnectionException(String, String, Throwable);
    ctor public SQLNonTransientConnectionException(String, String, int, Throwable);
  }

  public class SQLNonTransientException extends java.sql.SQLException {
    ctor public SQLNonTransientException();
    ctor public SQLNonTransientException(String);
    ctor public SQLNonTransientException(String, String);
    ctor public SQLNonTransientException(String, String, int);
    ctor public SQLNonTransientException(Throwable);
    ctor public SQLNonTransientException(String, Throwable);
    ctor public SQLNonTransientException(String, String, Throwable);
    ctor public SQLNonTransientException(String, String, int, Throwable);
  }

  public interface SQLOutput {
    method public void writeArray(java.sql.Array) throws java.sql.SQLException;
    method public void writeAsciiStream(java.io.InputStream) throws java.sql.SQLException;
    method public void writeBigDecimal(java.math.BigDecimal) throws java.sql.SQLException;
    method public void writeBinaryStream(java.io.InputStream) throws java.sql.SQLException;
    method public void writeBlob(java.sql.Blob) throws java.sql.SQLException;
    method public void writeBoolean(boolean) throws java.sql.SQLException;
    method public void writeByte(byte) throws java.sql.SQLException;
    method public void writeBytes(byte[]) throws java.sql.SQLException;
    method public void writeCharacterStream(java.io.Reader) throws java.sql.SQLException;
    method public void writeClob(java.sql.Clob) throws java.sql.SQLException;
    method public void writeDate(java.sql.Date) throws java.sql.SQLException;
    method public void writeDouble(double) throws java.sql.SQLException;
    method public void writeFloat(float) throws java.sql.SQLException;
    method public void writeInt(int) throws java.sql.SQLException;
    method public void writeLong(long) throws java.sql.SQLException;
    method public void writeNClob(java.sql.NClob) throws java.sql.SQLException;
    method public void writeNString(String) throws java.sql.SQLException;
    method public void writeObject(java.sql.SQLData) throws java.sql.SQLException;
    method public void writeRef(java.sql.Ref) throws java.sql.SQLException;
    method public void writeRowId(java.sql.RowId) throws java.sql.SQLException;
    method public void writeSQLXML(java.sql.SQLXML) throws java.sql.SQLException;
    method public void writeShort(short) throws java.sql.SQLException;
    method public void writeString(String) throws java.sql.SQLException;
    method public void writeStruct(java.sql.Struct) throws java.sql.SQLException;
    method public void writeTime(java.sql.Time) throws java.sql.SQLException;
    method public void writeTimestamp(java.sql.Timestamp) throws java.sql.SQLException;
    method public void writeURL(java.net.URL) throws java.sql.SQLException;
  }

  public final class SQLPermission extends java.security.BasicPermission {
    ctor public SQLPermission(String);
    ctor public SQLPermission(String, String);
  }

  public class SQLRecoverableException extends java.sql.SQLException {
    ctor public SQLRecoverableException();
    ctor public SQLRecoverableException(String);
    ctor public SQLRecoverableException(String, String);
    ctor public SQLRecoverableException(String, String, int);
    ctor public SQLRecoverableException(Throwable);
    ctor public SQLRecoverableException(String, Throwable);
    ctor public SQLRecoverableException(String, String, Throwable);
    ctor public SQLRecoverableException(String, String, int, Throwable);
  }

  public class SQLSyntaxErrorException extends java.sql.SQLNonTransientException {
    ctor public SQLSyntaxErrorException();
    ctor public SQLSyntaxErrorException(String);
    ctor public SQLSyntaxErrorException(String, String);
    ctor public SQLSyntaxErrorException(String, String, int);
    ctor public SQLSyntaxErrorException(Throwable);
    ctor public SQLSyntaxErrorException(String, Throwable);
    ctor public SQLSyntaxErrorException(String, String, Throwable);
    ctor public SQLSyntaxErrorException(String, String, int, Throwable);
  }

  public class SQLTimeoutException extends java.sql.SQLTransientException {
    ctor public SQLTimeoutException();
    ctor public SQLTimeoutException(String);
    ctor public SQLTimeoutException(String, String);
    ctor public SQLTimeoutException(String, String, int);
    ctor public SQLTimeoutException(Throwable);
    ctor public SQLTimeoutException(String, Throwable);
    ctor public SQLTimeoutException(String, String, Throwable);
    ctor public SQLTimeoutException(String, String, int, Throwable);
  }

  public class SQLTransactionRollbackException extends java.sql.SQLTransientException {
    ctor public SQLTransactionRollbackException();
    ctor public SQLTransactionRollbackException(String);
    ctor public SQLTransactionRollbackException(String, String);
    ctor public SQLTransactionRollbackException(String, String, int);
    ctor public SQLTransactionRollbackException(Throwable);
    ctor public SQLTransactionRollbackException(String, Throwable);
    ctor public SQLTransactionRollbackException(String, String, Throwable);
    ctor public SQLTransactionRollbackException(String, String, int, Throwable);
  }

  public class SQLTransientConnectionException extends java.sql.SQLTransientException {
    ctor public SQLTransientConnectionException();
    ctor public SQLTransientConnectionException(String);
    ctor public SQLTransientConnectionException(String, String);
    ctor public SQLTransientConnectionException(String, String, int);
    ctor public SQLTransientConnectionException(Throwable);
    ctor public SQLTransientConnectionException(String, Throwable);
    ctor public SQLTransientConnectionException(String, String, Throwable);
    ctor public SQLTransientConnectionException(String, String, int, Throwable);
  }

  public class SQLTransientException extends java.sql.SQLException {
    ctor public SQLTransientException();
    ctor public SQLTransientException(String);
    ctor public SQLTransientException(String, String);
    ctor public SQLTransientException(String, String, int);
    ctor public SQLTransientException(Throwable);
    ctor public SQLTransientException(String, Throwable);
    ctor public SQLTransientException(String, String, Throwable);
    ctor public SQLTransientException(String, String, int, Throwable);
  }

  public class SQLWarning extends java.sql.SQLException {
    ctor public SQLWarning(String, String, int);
    ctor public SQLWarning(String, String);
    ctor public SQLWarning(String);
    ctor public SQLWarning();
    ctor public SQLWarning(Throwable);
    ctor public SQLWarning(String, Throwable);
    ctor public SQLWarning(String, String, Throwable);
    ctor public SQLWarning(String, String, int, Throwable);
    method public java.sql.SQLWarning getNextWarning();
    method public void setNextWarning(java.sql.SQLWarning);
  }

  public interface SQLXML {
    method public void free() throws java.sql.SQLException;
    method public java.io.InputStream getBinaryStream() throws java.sql.SQLException;
    method public java.io.Reader getCharacterStream() throws java.sql.SQLException;
    method public <T extends javax.xml.transform.Source> T getSource(Class<T>) throws java.sql.SQLException;
    method public String getString() throws java.sql.SQLException;
    method public java.io.OutputStream setBinaryStream() throws java.sql.SQLException;
    method public java.io.Writer setCharacterStream() throws java.sql.SQLException;
    method public <T extends javax.xml.transform.Result> T setResult(Class<T>) throws java.sql.SQLException;
    method public void setString(String) throws java.sql.SQLException;
  }

  public interface Savepoint {
    method public int getSavepointId() throws java.sql.SQLException;
    method public String getSavepointName() throws java.sql.SQLException;
  }

  public interface Statement extends java.sql.Wrapper java.lang.AutoCloseable {
    method public void addBatch(String) throws java.sql.SQLException;
    method public void cancel() throws java.sql.SQLException;
    method public void clearBatch() throws java.sql.SQLException;
    method public void clearWarnings() throws java.sql.SQLException;
    method public void close() throws java.sql.SQLException;
    method public boolean execute(String) throws java.sql.SQLException;
    method public boolean execute(String, int) throws java.sql.SQLException;
    method public boolean execute(String, int[]) throws java.sql.SQLException;
    method public boolean execute(String, String[]) throws java.sql.SQLException;
    method public int[] executeBatch() throws java.sql.SQLException;
    method public java.sql.ResultSet executeQuery(String) throws java.sql.SQLException;
    method public int executeUpdate(String) throws java.sql.SQLException;
    method public int executeUpdate(String, int) throws java.sql.SQLException;
    method public int executeUpdate(String, int[]) throws java.sql.SQLException;
    method public int executeUpdate(String, String[]) throws java.sql.SQLException;
    method public java.sql.Connection getConnection() throws java.sql.SQLException;
    method public int getFetchDirection() throws java.sql.SQLException;
    method public int getFetchSize() throws java.sql.SQLException;
    method public java.sql.ResultSet getGeneratedKeys() throws java.sql.SQLException;
    method public int getMaxFieldSize() throws java.sql.SQLException;
    method public int getMaxRows() throws java.sql.SQLException;
    method public boolean getMoreResults() throws java.sql.SQLException;
    method public boolean getMoreResults(int) throws java.sql.SQLException;
    method public int getQueryTimeout() throws java.sql.SQLException;
    method public java.sql.ResultSet getResultSet() throws java.sql.SQLException;
    method public int getResultSetConcurrency() throws java.sql.SQLException;
    method public int getResultSetHoldability() throws java.sql.SQLException;
    method public int getResultSetType() throws java.sql.SQLException;
    method public int getUpdateCount() throws java.sql.SQLException;
    method public java.sql.SQLWarning getWarnings() throws java.sql.SQLException;
    method public boolean isClosed() throws java.sql.SQLException;
    method public boolean isPoolable() throws java.sql.SQLException;
    method public void setCursorName(String) throws java.sql.SQLException;
    method public void setEscapeProcessing(boolean) throws java.sql.SQLException;
    method public void setFetchDirection(int) throws java.sql.SQLException;
    method public void setFetchSize(int) throws java.sql.SQLException;
    method public void setMaxFieldSize(int) throws java.sql.SQLException;
    method public void setMaxRows(int) throws java.sql.SQLException;
    method public void setPoolable(boolean) throws java.sql.SQLException;
    method public void setQueryTimeout(int) throws java.sql.SQLException;
    field public static final int CLOSE_ALL_RESULTS = 3; // 0x3
    field public static final int CLOSE_CURRENT_RESULT = 1; // 0x1
    field public static final int EXECUTE_FAILED = -3; // 0xfffffffd
    field public static final int KEEP_CURRENT_RESULT = 2; // 0x2
    field public static final int NO_GENERATED_KEYS = 2; // 0x2
    field public static final int RETURN_GENERATED_KEYS = 1; // 0x1
    field public static final int SUCCESS_NO_INFO = -2; // 0xfffffffe
  }

  public interface Struct {
    method public Object[] getAttributes() throws java.sql.SQLException;
    method public Object[] getAttributes(java.util.Map<java.lang.String,java.lang.Class<?>>) throws java.sql.SQLException;
    method public String getSQLTypeName() throws java.sql.SQLException;
  }

  public class Time extends java.util.Date {
    ctor @Deprecated public Time(int, int, int);
    ctor public Time(long);
    method public static java.sql.Time valueOf(String);
  }

  public class Timestamp extends java.util.Date {
    ctor @Deprecated public Timestamp(int, int, int, int, int, int, int);
    ctor public Timestamp(long);
    method public boolean after(java.sql.Timestamp);
    method public boolean before(java.sql.Timestamp);
    method public int compareTo(java.sql.Timestamp);
    method public boolean equals(java.sql.Timestamp);
    method public int getNanos();
    method public void setNanos(int);
    method public static java.sql.Timestamp valueOf(String);
  }

  public class Types {
    field public static final int ARRAY = 2003; // 0x7d3
    field public static final int BIGINT = -5; // 0xfffffffb
    field public static final int BINARY = -2; // 0xfffffffe
    field public static final int BIT = -7; // 0xfffffff9
    field public static final int BLOB = 2004; // 0x7d4
    field public static final int BOOLEAN = 16; // 0x10
    field public static final int CHAR = 1; // 0x1
    field public static final int CLOB = 2005; // 0x7d5
    field public static final int DATALINK = 70; // 0x46
    field public static final int DATE = 91; // 0x5b
    field public static final int DECIMAL = 3; // 0x3
    field public static final int DISTINCT = 2001; // 0x7d1
    field public static final int DOUBLE = 8; // 0x8
    field public static final int FLOAT = 6; // 0x6
    field public static final int INTEGER = 4; // 0x4
    field public static final int JAVA_OBJECT = 2000; // 0x7d0
    field public static final int LONGNVARCHAR = -16; // 0xfffffff0
    field public static final int LONGVARBINARY = -4; // 0xfffffffc
    field public static final int LONGVARCHAR = -1; // 0xffffffff
    field public static final int NCHAR = -15; // 0xfffffff1
    field public static final int NCLOB = 2011; // 0x7db
    field public static final int NULL = 0; // 0x0
    field public static final int NUMERIC = 2; // 0x2
    field public static final int NVARCHAR = -9; // 0xfffffff7
    field public static final int OTHER = 1111; // 0x457
    field public static final int REAL = 7; // 0x7
    field public static final int REF = 2006; // 0x7d6
    field public static final int ROWID = -8; // 0xfffffff8
    field public static final int SMALLINT = 5; // 0x5
    field public static final int SQLXML = 2009; // 0x7d9
    field public static final int STRUCT = 2002; // 0x7d2
    field public static final int TIME = 92; // 0x5c
    field public static final int TIMESTAMP = 93; // 0x5d
    field public static final int TINYINT = -6; // 0xfffffffa
    field public static final int VARBINARY = -3; // 0xfffffffd
    field public static final int VARCHAR = 12; // 0xc
  }

  public interface Wrapper {
    method public boolean isWrapperFor(Class<?>) throws java.sql.SQLException;
    method public <T> T unwrap(Class<T>) throws java.sql.SQLException;
  }

}

package java.text {

  public class Annotation {
    ctor public Annotation(Object);
    method public Object getValue();
  }

  public interface AttributedCharacterIterator extends java.text.CharacterIterator {
    method public java.util.Set<java.text.AttributedCharacterIterator.Attribute> getAllAttributeKeys();
    method public Object getAttribute(java.text.AttributedCharacterIterator.Attribute);
    method public java.util.Map<java.text.AttributedCharacterIterator.Attribute,java.lang.Object> getAttributes();
    method public int getRunLimit();
    method public int getRunLimit(java.text.AttributedCharacterIterator.Attribute);
    method public int getRunLimit(java.util.Set<? extends java.text.AttributedCharacterIterator.Attribute>);
    method public int getRunStart();
    method public int getRunStart(java.text.AttributedCharacterIterator.Attribute);
    method public int getRunStart(java.util.Set<? extends java.text.AttributedCharacterIterator.Attribute>);
  }

  public static class AttributedCharacterIterator.Attribute implements java.io.Serializable {
    ctor protected AttributedCharacterIterator.Attribute(String);
    method public final boolean equals(Object);
    method protected String getName();
    method public final int hashCode();
    method @java.io.Serial protected Object readResolve() throws java.io.InvalidObjectException;
    field public static final java.text.AttributedCharacterIterator.Attribute INPUT_METHOD_SEGMENT;
    field public static final java.text.AttributedCharacterIterator.Attribute LANGUAGE;
    field public static final java.text.AttributedCharacterIterator.Attribute READING;
  }

  public class AttributedString {
    ctor public AttributedString(String);
    ctor public AttributedString(String, java.util.Map<? extends java.text.AttributedCharacterIterator.Attribute,?>);
    ctor public AttributedString(java.text.AttributedCharacterIterator);
    ctor public AttributedString(java.text.AttributedCharacterIterator, int, int);
    ctor public AttributedString(java.text.AttributedCharacterIterator, int, int, java.text.AttributedCharacterIterator.Attribute[]);
    method public void addAttribute(java.text.AttributedCharacterIterator.Attribute, Object);
    method public void addAttribute(java.text.AttributedCharacterIterator.Attribute, Object, int, int);
    method public void addAttributes(java.util.Map<? extends java.text.AttributedCharacterIterator.Attribute,?>, int, int);
    method public java.text.AttributedCharacterIterator getIterator();
    method public java.text.AttributedCharacterIterator getIterator(java.text.AttributedCharacterIterator.Attribute[]);
    method public java.text.AttributedCharacterIterator getIterator(java.text.AttributedCharacterIterator.Attribute[], int, int);
  }

  public final class Bidi {
    ctor public Bidi(String, int);
    ctor public Bidi(java.text.AttributedCharacterIterator);
    ctor public Bidi(char[], int, byte[], int, int, int);
    method public boolean baseIsLeftToRight();
    method public java.text.Bidi createLineBidi(int, int);
    method public int getBaseLevel();
    method public int getLength();
    method public int getLevelAt(int);
    method public int getRunCount();
    method public int getRunLevel(int);
    method public int getRunLimit(int);
    method public int getRunStart(int);
    method public boolean isLeftToRight();
    method public boolean isMixed();
    method public boolean isRightToLeft();
    method public static void reorderVisually(byte[], int, Object[], int, int);
    method public static boolean requiresBidi(char[], int, int);
    field public static final int DIRECTION_DEFAULT_LEFT_TO_RIGHT = -2; // 0xfffffffe
    field public static final int DIRECTION_DEFAULT_RIGHT_TO_LEFT = -1; // 0xffffffff
    field public static final int DIRECTION_LEFT_TO_RIGHT = 0; // 0x0
    field public static final int DIRECTION_RIGHT_TO_LEFT = 1; // 0x1
  }

  public abstract class BreakIterator implements java.lang.Cloneable {
    ctor protected BreakIterator();
    method public Object clone();
    method public abstract int current();
    method public abstract int first();
    method public abstract int following(int);
    method public static java.util.Locale[] getAvailableLocales();
    method public static java.text.BreakIterator getCharacterInstance();
    method public static java.text.BreakIterator getCharacterInstance(java.util.Locale);
    method public static java.text.BreakIterator getLineInstance();
    method public static java.text.BreakIterator getLineInstance(java.util.Locale);
    method public static java.text.BreakIterator getSentenceInstance();
    method public static java.text.BreakIterator getSentenceInstance(java.util.Locale);
    method public abstract java.text.CharacterIterator getText();
    method public static java.text.BreakIterator getWordInstance();
    method public static java.text.BreakIterator getWordInstance(java.util.Locale);
    method public boolean isBoundary(int);
    method public abstract int last();
    method public abstract int next(int);
    method public abstract int next();
    method public int preceding(int);
    method public abstract int previous();
    method public void setText(String);
    method public abstract void setText(java.text.CharacterIterator);
    field public static final int DONE = -1; // 0xffffffff
  }

  public interface CharacterIterator extends java.lang.Cloneable {
    method public Object clone();
    method public char current();
    method public char first();
    method public int getBeginIndex();
    method public int getEndIndex();
    method public int getIndex();
    method public char last();
    method public char next();
    method public char previous();
    method public char setIndex(int);
    field public static final char DONE = 65535; // 0xffff '\uffff'
  }

  public class ChoiceFormat extends java.text.NumberFormat {
    ctor public ChoiceFormat(String);
    ctor public ChoiceFormat(double[], String[]);
    method public void applyPattern(String);
    method public StringBuffer format(long, StringBuffer, java.text.FieldPosition);
    method public StringBuffer format(double, StringBuffer, java.text.FieldPosition);
    method public Object[] getFormats();
    method public double[] getLimits();
    method public static final double nextDouble(double);
    method public static double nextDouble(double, boolean);
    method public Number parse(String, java.text.ParsePosition);
    method public static final double previousDouble(double);
    method public void setChoices(double[], String[]);
    method public String toPattern();
  }

  public final class CollationElementIterator {
    method public int getMaxExpansion(int);
    method public int getOffset();
    method public int next();
    method public int previous();
    method public static int primaryOrder(int);
    method public void reset();
    method public static short secondaryOrder(int);
    method public void setOffset(int);
    method public void setText(String);
    method public void setText(java.text.CharacterIterator);
    method public static short tertiaryOrder(int);
    field public static final int NULLORDER = -1; // 0xffffffff
  }

  public abstract class CollationKey implements java.lang.Comparable<java.text.CollationKey> {
    ctor protected CollationKey(String);
    method public abstract int compareTo(java.text.CollationKey);
    method public String getSourceString();
    method public abstract byte[] toByteArray();
  }

  public abstract class Collator implements java.lang.Cloneable java.util.Comparator<java.lang.Object> {
    ctor protected Collator();
    method public Object clone();
    method public abstract int compare(String, String);
    method public int compare(Object, Object);
    method public boolean equals(String, String);
    method public boolean equals(Object);
    method public static java.util.Locale[] getAvailableLocales();
    method public abstract java.text.CollationKey getCollationKey(String);
    method public int getDecomposition();
    method public static java.text.Collator getInstance();
    method public static java.text.Collator getInstance(java.util.Locale);
    method public int getStrength();
    method public abstract int hashCode();
    method public void setDecomposition(int);
    method public void setStrength(int);
    field public static final int CANONICAL_DECOMPOSITION = 1; // 0x1
    field public static final int FULL_DECOMPOSITION = 2; // 0x2
    field public static final int IDENTICAL = 3; // 0x3
    field public static final int NO_DECOMPOSITION = 0; // 0x0
    field public static final int PRIMARY = 0; // 0x0
    field public static final int SECONDARY = 1; // 0x1
    field public static final int TERTIARY = 2; // 0x2
  }

  public abstract class DateFormat extends java.text.Format {
    ctor protected DateFormat();
    method @NonNull public final StringBuffer format(@NonNull Object, @NonNull StringBuffer, @NonNull java.text.FieldPosition);
    method @NonNull public abstract StringBuffer format(@NonNull java.util.Date, @NonNull StringBuffer, @NonNull java.text.FieldPosition);
    method @NonNull public final String format(@NonNull java.util.Date);
    method @NonNull public static java.util.Locale[] getAvailableLocales();
    method @NonNull public java.util.Calendar getCalendar();
    method @NonNull public static final java.text.DateFormat getDateInstance();
    method @NonNull public static final java.text.DateFormat getDateInstance(int);
    method @NonNull public static final java.text.DateFormat getDateInstance(int, @NonNull java.util.Locale);
    method @NonNull public static final java.text.DateFormat getDateTimeInstance();
    method @NonNull public static final java.text.DateFormat getDateTimeInstance(int, int);
    method @NonNull public static final java.text.DateFormat getDateTimeInstance(int, int, @NonNull java.util.Locale);
    method @NonNull public static final java.text.DateFormat getInstance();
    method @NonNull public java.text.NumberFormat getNumberFormat();
    method @NonNull public static final java.text.DateFormat getTimeInstance();
    method @NonNull public static final java.text.DateFormat getTimeInstance(int);
    method @NonNull public static final java.text.DateFormat getTimeInstance(int, @NonNull java.util.Locale);
    method @NonNull public java.util.TimeZone getTimeZone();
    method public boolean isLenient();
    method @Nullable public java.util.Date parse(@NonNull String) throws java.text.ParseException;
    method @Nullable public abstract java.util.Date parse(@NonNull String, @NonNull java.text.ParsePosition);
    method @Nullable public Object parseObject(@NonNull String, @NonNull java.text.ParsePosition);
    method public void setCalendar(@NonNull java.util.Calendar);
    method public void setLenient(boolean);
    method public void setNumberFormat(@NonNull java.text.NumberFormat);
    method public void setTimeZone(@NonNull java.util.TimeZone);
    field public static final int AM_PM_FIELD = 14; // 0xe
    field public static final int DATE_FIELD = 3; // 0x3
    field public static final int DAY_OF_WEEK_FIELD = 9; // 0x9
    field public static final int DAY_OF_WEEK_IN_MONTH_FIELD = 11; // 0xb
    field public static final int DAY_OF_YEAR_FIELD = 10; // 0xa
    field public static final int DEFAULT = 2; // 0x2
    field public static final int ERA_FIELD = 0; // 0x0
    field public static final int FULL = 0; // 0x0
    field public static final int HOUR0_FIELD = 16; // 0x10
    field public static final int HOUR1_FIELD = 15; // 0xf
    field public static final int HOUR_OF_DAY0_FIELD = 5; // 0x5
    field public static final int HOUR_OF_DAY1_FIELD = 4; // 0x4
    field public static final int LONG = 1; // 0x1
    field public static final int MEDIUM = 2; // 0x2
    field public static final int MILLISECOND_FIELD = 8; // 0x8
    field public static final int MINUTE_FIELD = 6; // 0x6
    field public static final int MONTH_FIELD = 2; // 0x2
    field public static final int SECOND_FIELD = 7; // 0x7
    field public static final int SHORT = 3; // 0x3
    field public static final int TIMEZONE_FIELD = 17; // 0x11
    field public static final int WEEK_OF_MONTH_FIELD = 13; // 0xd
    field public static final int WEEK_OF_YEAR_FIELD = 12; // 0xc
    field public static final int YEAR_FIELD = 1; // 0x1
    field @NonNull protected java.util.Calendar calendar;
    field @NonNull protected java.text.NumberFormat numberFormat;
  }

  public static class DateFormat.Field extends java.text.Format.Field {
    ctor protected DateFormat.Field(@NonNull String, int);
    method public int getCalendarField();
    method @NonNull public static java.text.DateFormat.Field ofCalendarField(int);
    field @NonNull public static final java.text.DateFormat.Field AM_PM;
    field @NonNull public static final java.text.DateFormat.Field DAY_OF_MONTH;
    field @NonNull public static final java.text.DateFormat.Field DAY_OF_WEEK;
    field @NonNull public static final java.text.DateFormat.Field DAY_OF_WEEK_IN_MONTH;
    field @NonNull public static final java.text.DateFormat.Field DAY_OF_YEAR;
    field @NonNull public static final java.text.DateFormat.Field ERA;
    field @NonNull public static final java.text.DateFormat.Field HOUR0;
    field @NonNull public static final java.text.DateFormat.Field HOUR1;
    field @NonNull public static final java.text.DateFormat.Field HOUR_OF_DAY0;
    field @NonNull public static final java.text.DateFormat.Field HOUR_OF_DAY1;
    field @NonNull public static final java.text.DateFormat.Field MILLISECOND;
    field @NonNull public static final java.text.DateFormat.Field MINUTE;
    field @NonNull public static final java.text.DateFormat.Field MONTH;
    field @NonNull public static final java.text.DateFormat.Field SECOND;
    field @NonNull public static final java.text.DateFormat.Field TIME_ZONE;
    field @NonNull public static final java.text.DateFormat.Field WEEK_OF_MONTH;
    field @NonNull public static final java.text.DateFormat.Field WEEK_OF_YEAR;
    field @NonNull public static final java.text.DateFormat.Field YEAR;
  }

  public class DateFormatSymbols implements java.lang.Cloneable java.io.Serializable {
    ctor public DateFormatSymbols();
    ctor public DateFormatSymbols(java.util.Locale);
    method public Object clone();
    method public String[] getAmPmStrings();
    method public static java.util.Locale[] getAvailableLocales();
    method public String[] getEras();
    method public static final java.text.DateFormatSymbols getInstance();
    method public static final java.text.DateFormatSymbols getInstance(java.util.Locale);
    method public String getLocalPatternChars();
    method public String[] getMonths();
    method public String[] getShortMonths();
    method public String[] getShortWeekdays();
    method public String[] getWeekdays();
    method public String[][] getZoneStrings();
    method public void setAmPmStrings(String[]);
    method public void setEras(String[]);
    method public void setLocalPatternChars(String);
    method public void setMonths(String[]);
    method public void setShortMonths(String[]);
    method public void setShortWeekdays(String[]);
    method public void setWeekdays(String[]);
    method public void setZoneStrings(String[][]);
  }

  public class DecimalFormat extends java.text.NumberFormat {
    ctor public DecimalFormat();
    ctor public DecimalFormat(String);
    ctor public DecimalFormat(String, java.text.DecimalFormatSymbols);
    method public void applyLocalizedPattern(String);
    method public void applyPattern(String);
    method public final StringBuffer format(Object, StringBuffer, java.text.FieldPosition);
    method public StringBuffer format(double, StringBuffer, java.text.FieldPosition);
    method public StringBuffer format(long, StringBuffer, java.text.FieldPosition);
    method public java.text.DecimalFormatSymbols getDecimalFormatSymbols();
    method public int getGroupingSize();
    method public int getMultiplier();
    method public String getNegativePrefix();
    method public String getNegativeSuffix();
    method public String getPositivePrefix();
    method public String getPositiveSuffix();
    method public boolean isDecimalSeparatorAlwaysShown();
    method public boolean isParseBigDecimal();
    method public Number parse(String, java.text.ParsePosition);
    method public void setDecimalFormatSymbols(java.text.DecimalFormatSymbols);
    method public void setDecimalSeparatorAlwaysShown(boolean);
    method public void setGroupingSize(int);
    method public void setMultiplier(int);
    method public void setNegativePrefix(String);
    method public void setNegativeSuffix(String);
    method public void setParseBigDecimal(boolean);
    method public void setPositivePrefix(String);
    method public void setPositiveSuffix(String);
    method public String toLocalizedPattern();
    method public String toPattern();
  }

  public class DecimalFormatSymbols implements java.lang.Cloneable java.io.Serializable {
    ctor public DecimalFormatSymbols();
    ctor public DecimalFormatSymbols(java.util.Locale);
    method public Object clone();
    method public static java.util.Locale[] getAvailableLocales();
    method public java.util.Currency getCurrency();
    method public String getCurrencySymbol();
    method public char getDecimalSeparator();
    method public char getDigit();
    method public String getExponentSeparator();
    method public char getGroupingSeparator();
    method public String getInfinity();
    method public static final java.text.DecimalFormatSymbols getInstance();
    method public static final java.text.DecimalFormatSymbols getInstance(java.util.Locale);
    method public String getInternationalCurrencySymbol();
    method public char getMinusSign();
    method public char getMonetaryDecimalSeparator();
    method public char getMonetaryGroupingSeparator();
    method public String getNaN();
    method public char getPatternSeparator();
    method public char getPerMill();
    method public char getPercent();
    method public char getZeroDigit();
    method public void setCurrency(java.util.Currency);
    method public void setCurrencySymbol(String);
    method public void setDecimalSeparator(char);
    method public void setDigit(char);
    method public void setExponentSeparator(String);
    method public void setGroupingSeparator(char);
    method public void setInfinity(String);
    method public void setInternationalCurrencySymbol(String);
    method public void setMinusSign(char);
    method public void setMonetaryDecimalSeparator(char);
    method public void setMonetaryGroupingSeparator(char);
    method public void setNaN(String);
    method public void setPatternSeparator(char);
    method public void setPerMill(char);
    method public void setPercent(char);
    method public void setZeroDigit(char);
  }

  public class FieldPosition {
    ctor public FieldPosition(int);
    ctor public FieldPosition(java.text.Format.Field);
    ctor public FieldPosition(java.text.Format.Field, int);
    method public int getBeginIndex();
    method public int getEndIndex();
    method public int getField();
    method public java.text.Format.Field getFieldAttribute();
    method public void setBeginIndex(int);
    method public void setEndIndex(int);
  }

  public abstract class Format implements java.lang.Cloneable java.io.Serializable {
    ctor protected Format();
    method public Object clone();
    method public final String format(Object);
    method public abstract StringBuffer format(Object, StringBuffer, java.text.FieldPosition);
    method public java.text.AttributedCharacterIterator formatToCharacterIterator(Object);
    method public abstract Object parseObject(String, java.text.ParsePosition);
    method public Object parseObject(String) throws java.text.ParseException;
  }

  public static class Format.Field extends java.text.AttributedCharacterIterator.Attribute {
    ctor protected Format.Field(String);
  }

  public class MessageFormat extends java.text.Format {
    ctor public MessageFormat(String);
    ctor public MessageFormat(String, java.util.Locale);
    method public void applyPattern(String);
    method public final StringBuffer format(Object[], StringBuffer, java.text.FieldPosition);
    method public static String format(String, java.lang.Object...);
    method public final StringBuffer format(Object, StringBuffer, java.text.FieldPosition);
    method public java.text.Format[] getFormats();
    method public java.text.Format[] getFormatsByArgumentIndex();
    method public java.util.Locale getLocale();
    method public Object[] parse(String, java.text.ParsePosition);
    method public Object[] parse(String) throws java.text.ParseException;
    method public Object parseObject(String, java.text.ParsePosition);
    method public void setFormat(int, java.text.Format);
    method public void setFormatByArgumentIndex(int, java.text.Format);
    method public void setFormats(java.text.Format[]);
    method public void setFormatsByArgumentIndex(java.text.Format[]);
    method public void setLocale(java.util.Locale);
    method public String toPattern();
  }

  public static class MessageFormat.Field extends java.text.Format.Field {
    ctor protected MessageFormat.Field(String);
    field public static final java.text.MessageFormat.Field ARGUMENT;
  }

  public final class Normalizer {
    method public static boolean isNormalized(CharSequence, java.text.Normalizer.Form);
    method public static String normalize(CharSequence, java.text.Normalizer.Form);
  }

  public enum Normalizer.Form {
    enum_constant public static final java.text.Normalizer.Form NFC;
    enum_constant public static final java.text.Normalizer.Form NFD;
    enum_constant public static final java.text.Normalizer.Form NFKC;
    enum_constant public static final java.text.Normalizer.Form NFKD;
  }

  public abstract class NumberFormat extends java.text.Format {
    ctor protected NumberFormat();
    method @NonNull public StringBuffer format(@NonNull Object, @NonNull StringBuffer, @NonNull java.text.FieldPosition);
    method @NonNull public final String format(double);
    method @NonNull public final String format(long);
    method @NonNull public abstract StringBuffer format(double, @NonNull StringBuffer, @NonNull java.text.FieldPosition);
    method @NonNull public abstract StringBuffer format(long, @NonNull StringBuffer, @NonNull java.text.FieldPosition);
    method @NonNull public static java.util.Locale[] getAvailableLocales();
    method @Nullable public java.util.Currency getCurrency();
    method @NonNull public static final java.text.NumberFormat getCurrencyInstance();
    method @NonNull public static java.text.NumberFormat getCurrencyInstance(@NonNull java.util.Locale);
    method @NonNull public static final java.text.NumberFormat getInstance();
    method @NonNull public static java.text.NumberFormat getInstance(@NonNull java.util.Locale);
    method @NonNull public static final java.text.NumberFormat getIntegerInstance();
    method @NonNull public static java.text.NumberFormat getIntegerInstance(@NonNull java.util.Locale);
    method public int getMaximumFractionDigits();
    method public int getMaximumIntegerDigits();
    method public int getMinimumFractionDigits();
    method public int getMinimumIntegerDigits();
    method @NonNull public static final java.text.NumberFormat getNumberInstance();
    method @NonNull public static java.text.NumberFormat getNumberInstance(@NonNull java.util.Locale);
    method @NonNull public static final java.text.NumberFormat getPercentInstance();
    method @NonNull public static java.text.NumberFormat getPercentInstance(@NonNull java.util.Locale);
    method @NonNull public java.math.RoundingMode getRoundingMode();
    method public boolean isGroupingUsed();
    method public boolean isParseIntegerOnly();
    method @Nullable public abstract Number parse(@NonNull String, @NonNull java.text.ParsePosition);
    method @Nullable public Number parse(@NonNull String) throws java.text.ParseException;
    method @Nullable public final Object parseObject(@NonNull String, @NonNull java.text.ParsePosition);
    method public void setCurrency(@NonNull java.util.Currency);
    method public void setGroupingUsed(boolean);
    method public void setMaximumFractionDigits(int);
    method public void setMaximumIntegerDigits(int);
    method public void setMinimumFractionDigits(int);
    method public void setMinimumIntegerDigits(int);
    method public void setParseIntegerOnly(boolean);
    method public void setRoundingMode(@Nullable java.math.RoundingMode);
    field public static final int FRACTION_FIELD = 1; // 0x1
    field public static final int INTEGER_FIELD = 0; // 0x0
  }

  public static class NumberFormat.Field extends java.text.Format.Field {
    ctor protected NumberFormat.Field(@NonNull String);
    field @NonNull public static final java.text.NumberFormat.Field CURRENCY;
    field @NonNull public static final java.text.NumberFormat.Field DECIMAL_SEPARATOR;
    field @NonNull public static final java.text.NumberFormat.Field EXPONENT;
    field @NonNull public static final java.text.NumberFormat.Field EXPONENT_SIGN;
    field @NonNull public static final java.text.NumberFormat.Field EXPONENT_SYMBOL;
    field @NonNull public static final java.text.NumberFormat.Field FRACTION;
    field @NonNull public static final java.text.NumberFormat.Field GROUPING_SEPARATOR;
    field @NonNull public static final java.text.NumberFormat.Field INTEGER;
    field @NonNull public static final java.text.NumberFormat.Field PERCENT;
    field @NonNull public static final java.text.NumberFormat.Field PERMILLE;
    field @NonNull public static final java.text.NumberFormat.Field SIGN;
  }

  public class ParseException extends java.lang.Exception {
    ctor public ParseException(String, int);
    method public int getErrorOffset();
  }

  public class ParsePosition {
    ctor public ParsePosition(int);
    method public int getErrorIndex();
    method public int getIndex();
    method public void setErrorIndex(int);
    method public void setIndex(int);
  }

  public class RuleBasedCollator extends java.text.Collator {
    ctor public RuleBasedCollator(String) throws java.text.ParseException;
    method public int compare(String, String);
    method public java.text.CollationElementIterator getCollationElementIterator(String);
    method public java.text.CollationElementIterator getCollationElementIterator(java.text.CharacterIterator);
    method public java.text.CollationKey getCollationKey(String);
    method public String getRules();
    method public int hashCode();
  }

  public class SimpleDateFormat extends java.text.DateFormat {
    ctor public SimpleDateFormat();
    ctor public SimpleDateFormat(String);
    ctor public SimpleDateFormat(String, java.util.Locale);
    ctor public SimpleDateFormat(String, java.text.DateFormatSymbols);
    method public void applyLocalizedPattern(String);
    method public void applyPattern(String);
    method public StringBuffer format(java.util.Date, StringBuffer, java.text.FieldPosition);
    method public java.util.Date get2DigitYearStart();
    method public java.text.DateFormatSymbols getDateFormatSymbols();
    method public java.util.Date parse(String, java.text.ParsePosition);
    method public void set2DigitYearStart(java.util.Date);
    method public void setDateFormatSymbols(java.text.DateFormatSymbols);
    method public String toLocalizedPattern();
    method public String toPattern();
  }

  public final class StringCharacterIterator implements java.text.CharacterIterator {
    ctor public StringCharacterIterator(String);
    ctor public StringCharacterIterator(String, int);
    ctor public StringCharacterIterator(String, int, int, int);
    method public Object clone();
    method public char current();
    method public char first();
    method public int getBeginIndex();
    method public int getEndIndex();
    method public int getIndex();
    method public char last();
    method public char next();
    method public char previous();
    method public char setIndex(int);
    method public void setText(String);
  }

}

package java.time {

  public abstract class Clock implements java.time.InstantSource {
    ctor protected Clock();
    method public static java.time.Clock fixed(java.time.Instant, java.time.ZoneId);
    method public abstract java.time.ZoneId getZone();
    method public long millis();
    method public static java.time.Clock offset(java.time.Clock, java.time.Duration);
    method public static java.time.Clock system(java.time.ZoneId);
    method public static java.time.Clock systemDefaultZone();
    method public static java.time.Clock systemUTC();
    method public static java.time.Clock tick(java.time.Clock, java.time.Duration);
    method public static java.time.Clock tickMillis(java.time.ZoneId);
    method public static java.time.Clock tickMinutes(java.time.ZoneId);
    method public static java.time.Clock tickSeconds(java.time.ZoneId);
    method public abstract java.time.Clock withZone(java.time.ZoneId);
  }

  public class DateTimeException extends java.lang.RuntimeException {
    ctor public DateTimeException(String);
    ctor public DateTimeException(String, Throwable);
  }

  public enum DayOfWeek implements java.time.temporal.TemporalAccessor java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public static java.time.DayOfWeek from(java.time.temporal.TemporalAccessor);
    method public String getDisplayName(java.time.format.TextStyle, java.util.Locale);
    method public long getLong(java.time.temporal.TemporalField);
    method public int getValue();
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public java.time.DayOfWeek minus(long);
    method public static java.time.DayOfWeek of(int);
    method public java.time.DayOfWeek plus(long);
    enum_constant public static final java.time.DayOfWeek FRIDAY;
    enum_constant public static final java.time.DayOfWeek MONDAY;
    enum_constant public static final java.time.DayOfWeek SATURDAY;
    enum_constant public static final java.time.DayOfWeek SUNDAY;
    enum_constant public static final java.time.DayOfWeek THURSDAY;
    enum_constant public static final java.time.DayOfWeek TUESDAY;
    enum_constant public static final java.time.DayOfWeek WEDNESDAY;
  }

  public final class Duration implements java.lang.Comparable<java.time.Duration> java.io.Serializable java.time.temporal.TemporalAmount {
    method public java.time.Duration abs();
    method public java.time.temporal.Temporal addTo(java.time.temporal.Temporal);
    method public static java.time.Duration between(java.time.temporal.Temporal, java.time.temporal.Temporal);
    method public int compareTo(java.time.Duration);
    method public java.time.Duration dividedBy(long);
    method public long dividedBy(java.time.Duration);
    method public static java.time.Duration from(java.time.temporal.TemporalAmount);
    method public long get(java.time.temporal.TemporalUnit);
    method public int getNano();
    method public long getSeconds();
    method public java.util.List<java.time.temporal.TemporalUnit> getUnits();
    method public boolean isNegative();
    method public boolean isZero();
    method public java.time.Duration minus(java.time.Duration);
    method public java.time.Duration minus(long, java.time.temporal.TemporalUnit);
    method public java.time.Duration minusDays(long);
    method public java.time.Duration minusHours(long);
    method public java.time.Duration minusMillis(long);
    method public java.time.Duration minusMinutes(long);
    method public java.time.Duration minusNanos(long);
    method public java.time.Duration minusSeconds(long);
    method public java.time.Duration multipliedBy(long);
    method public java.time.Duration negated();
    method public static java.time.Duration of(long, java.time.temporal.TemporalUnit);
    method public static java.time.Duration ofDays(long);
    method public static java.time.Duration ofHours(long);
    method public static java.time.Duration ofMillis(long);
    method public static java.time.Duration ofMinutes(long);
    method public static java.time.Duration ofNanos(long);
    method public static java.time.Duration ofSeconds(long);
    method public static java.time.Duration ofSeconds(long, long);
    method public static java.time.Duration parse(CharSequence);
    method public java.time.Duration plus(java.time.Duration);
    method public java.time.Duration plus(long, java.time.temporal.TemporalUnit);
    method public java.time.Duration plusDays(long);
    method public java.time.Duration plusHours(long);
    method public java.time.Duration plusMillis(long);
    method public java.time.Duration plusMinutes(long);
    method public java.time.Duration plusNanos(long);
    method public java.time.Duration plusSeconds(long);
    method public java.time.temporal.Temporal subtractFrom(java.time.temporal.Temporal);
    method public long toDays();
    method public long toDaysPart();
    method public long toHours();
    method public int toHoursPart();
    method public long toMillis();
    method public int toMillisPart();
    method public long toMinutes();
    method public int toMinutesPart();
    method public long toNanos();
    method public int toNanosPart();
    method public long toSeconds();
    method public int toSecondsPart();
    method public java.time.Duration truncatedTo(java.time.temporal.TemporalUnit);
    method public java.time.Duration withNanos(int);
    method public java.time.Duration withSeconds(long);
    field public static final java.time.Duration ZERO;
  }

  public final class Instant implements java.lang.Comparable<java.time.Instant> java.io.Serializable java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public java.time.OffsetDateTime atOffset(java.time.ZoneOffset);
    method public java.time.ZonedDateTime atZone(java.time.ZoneId);
    method public int compareTo(java.time.Instant);
    method public static java.time.Instant from(java.time.temporal.TemporalAccessor);
    method public int get(java.time.temporal.TemporalField);
    method public long getEpochSecond();
    method public long getLong(java.time.temporal.TemporalField);
    method public int getNano();
    method public boolean isAfter(java.time.Instant);
    method public boolean isBefore(java.time.Instant);
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public boolean isSupported(java.time.temporal.TemporalUnit);
    method public java.time.Instant minus(java.time.temporal.TemporalAmount);
    method public java.time.Instant minus(long, java.time.temporal.TemporalUnit);
    method public java.time.Instant minusMillis(long);
    method public java.time.Instant minusNanos(long);
    method public java.time.Instant minusSeconds(long);
    method public static java.time.Instant now();
    method public static java.time.Instant now(java.time.Clock);
    method public static java.time.Instant ofEpochMilli(long);
    method public static java.time.Instant ofEpochSecond(long);
    method public static java.time.Instant ofEpochSecond(long, long);
    method public static java.time.Instant parse(CharSequence);
    method public java.time.Instant plus(java.time.temporal.TemporalAmount);
    method public java.time.Instant plus(long, java.time.temporal.TemporalUnit);
    method public java.time.Instant plusMillis(long);
    method public java.time.Instant plusNanos(long);
    method public java.time.Instant plusSeconds(long);
    method public <R> R query(java.time.temporal.TemporalQuery<R>);
    method public java.time.temporal.ValueRange range(java.time.temporal.TemporalField);
    method public long toEpochMilli();
    method public java.time.Instant truncatedTo(java.time.temporal.TemporalUnit);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.Instant with(java.time.temporal.TemporalAdjuster);
    method public java.time.Instant with(java.time.temporal.TemporalField, long);
    field public static final java.time.Instant EPOCH;
    field public static final java.time.Instant MAX;
    field public static final java.time.Instant MIN;
  }

  public interface InstantSource {
    method public static java.time.InstantSource fixed(java.time.Instant);
    method public java.time.Instant instant();
    method public default long millis();
    method public static java.time.InstantSource offset(java.time.InstantSource, java.time.Duration);
    method public static java.time.InstantSource system();
    method public static java.time.InstantSource tick(java.time.InstantSource, java.time.Duration);
    method public default java.time.Clock withZone(java.time.ZoneId);
  }

  public final class LocalDate implements java.time.chrono.ChronoLocalDate java.io.Serializable java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public java.time.LocalDateTime atStartOfDay();
    method public java.time.ZonedDateTime atStartOfDay(java.time.ZoneId);
    method public java.time.LocalDateTime atTime(java.time.LocalTime);
    method public java.time.LocalDateTime atTime(int, int);
    method public java.time.LocalDateTime atTime(int, int, int);
    method public java.time.LocalDateTime atTime(int, int, int, int);
    method public java.time.OffsetDateTime atTime(java.time.OffsetTime);
    method public int compareTo(java.time.chrono.ChronoLocalDate);
    method public java.util.stream.Stream<java.time.LocalDate> datesUntil(java.time.LocalDate);
    method public java.util.stream.Stream<java.time.LocalDate> datesUntil(java.time.LocalDate, java.time.Period);
    method public boolean equals(Object);
    method public String format(java.time.format.DateTimeFormatter);
    method public static java.time.LocalDate from(java.time.temporal.TemporalAccessor);
    method public int get(java.time.temporal.TemporalField);
    method public java.time.chrono.IsoChronology getChronology();
    method public int getDayOfMonth();
    method public java.time.DayOfWeek getDayOfWeek();
    method public int getDayOfYear();
    method public java.time.chrono.Era getEra();
    method public long getLong(java.time.temporal.TemporalField);
    method public java.time.Month getMonth();
    method public int getMonthValue();
    method public int getYear();
    method public int hashCode();
    method public boolean isAfter(java.time.chrono.ChronoLocalDate);
    method public boolean isBefore(java.time.chrono.ChronoLocalDate);
    method public boolean isEqual(java.time.chrono.ChronoLocalDate);
    method public boolean isLeapYear();
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public boolean isSupported(java.time.temporal.TemporalUnit);
    method public int lengthOfMonth();
    method public int lengthOfYear();
    method public java.time.LocalDate minus(java.time.temporal.TemporalAmount);
    method public java.time.LocalDate minus(long, java.time.temporal.TemporalUnit);
    method public java.time.LocalDate minusDays(long);
    method public java.time.LocalDate minusMonths(long);
    method public java.time.LocalDate minusWeeks(long);
    method public java.time.LocalDate minusYears(long);
    method public static java.time.LocalDate now();
    method public static java.time.LocalDate now(java.time.ZoneId);
    method public static java.time.LocalDate now(java.time.Clock);
    method public static java.time.LocalDate of(int, java.time.Month, int);
    method public static java.time.LocalDate of(int, int, int);
    method public static java.time.LocalDate ofEpochDay(long);
    method public static java.time.LocalDate ofInstant(java.time.Instant, java.time.ZoneId);
    method public static java.time.LocalDate ofYearDay(int, int);
    method public static java.time.LocalDate parse(CharSequence);
    method public static java.time.LocalDate parse(CharSequence, java.time.format.DateTimeFormatter);
    method public java.time.LocalDate plus(java.time.temporal.TemporalAmount);
    method public java.time.LocalDate plus(long, java.time.temporal.TemporalUnit);
    method public java.time.LocalDate plusDays(long);
    method public java.time.LocalDate plusMonths(long);
    method public java.time.LocalDate plusWeeks(long);
    method public java.time.LocalDate plusYears(long);
    method public <R> R query(java.time.temporal.TemporalQuery<R>);
    method public java.time.temporal.ValueRange range(java.time.temporal.TemporalField);
    method public long toEpochDay();
    method public long toEpochSecond(java.time.LocalTime, java.time.ZoneOffset);
    method public String toString();
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.Period until(java.time.chrono.ChronoLocalDate);
    method public java.time.LocalDate with(java.time.temporal.TemporalAdjuster);
    method public java.time.LocalDate with(java.time.temporal.TemporalField, long);
    method public java.time.LocalDate withDayOfMonth(int);
    method public java.time.LocalDate withDayOfYear(int);
    method public java.time.LocalDate withMonth(int);
    method public java.time.LocalDate withYear(int);
    field public static final java.time.LocalDate EPOCH;
    field public static final java.time.LocalDate MAX;
    field public static final java.time.LocalDate MIN;
  }

  public final class LocalDateTime implements java.time.chrono.ChronoLocalDateTime<java.time.LocalDate> java.io.Serializable java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public java.time.OffsetDateTime atOffset(java.time.ZoneOffset);
    method public java.time.ZonedDateTime atZone(java.time.ZoneId);
    method public int compareTo(java.time.chrono.ChronoLocalDateTime<?>);
    method public boolean equals(Object);
    method public String format(java.time.format.DateTimeFormatter);
    method public static java.time.LocalDateTime from(java.time.temporal.TemporalAccessor);
    method public int get(java.time.temporal.TemporalField);
    method public int getDayOfMonth();
    method public java.time.DayOfWeek getDayOfWeek();
    method public int getDayOfYear();
    method public int getHour();
    method public long getLong(java.time.temporal.TemporalField);
    method public int getMinute();
    method public java.time.Month getMonth();
    method public int getMonthValue();
    method public int getNano();
    method public int getSecond();
    method public int getYear();
    method public int hashCode();
    method public boolean isAfter(java.time.chrono.ChronoLocalDateTime<?>);
    method public boolean isBefore(java.time.chrono.ChronoLocalDateTime<?>);
    method public boolean isEqual(java.time.chrono.ChronoLocalDateTime<?>);
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public boolean isSupported(java.time.temporal.TemporalUnit);
    method public java.time.LocalDateTime minus(java.time.temporal.TemporalAmount);
    method public java.time.LocalDateTime minus(long, java.time.temporal.TemporalUnit);
    method public java.time.LocalDateTime minusDays(long);
    method public java.time.LocalDateTime minusHours(long);
    method public java.time.LocalDateTime minusMinutes(long);
    method public java.time.LocalDateTime minusMonths(long);
    method public java.time.LocalDateTime minusNanos(long);
    method public java.time.LocalDateTime minusSeconds(long);
    method public java.time.LocalDateTime minusWeeks(long);
    method public java.time.LocalDateTime minusYears(long);
    method public static java.time.LocalDateTime now();
    method public static java.time.LocalDateTime now(java.time.ZoneId);
    method public static java.time.LocalDateTime now(java.time.Clock);
    method public static java.time.LocalDateTime of(int, java.time.Month, int, int, int);
    method public static java.time.LocalDateTime of(int, java.time.Month, int, int, int, int);
    method public static java.time.LocalDateTime of(int, java.time.Month, int, int, int, int, int);
    method public static java.time.LocalDateTime of(int, int, int, int, int);
    method public static java.time.LocalDateTime of(int, int, int, int, int, int);
    method public static java.time.LocalDateTime of(int, int, int, int, int, int, int);
    method public static java.time.LocalDateTime of(java.time.LocalDate, java.time.LocalTime);
    method public static java.time.LocalDateTime ofEpochSecond(long, int, java.time.ZoneOffset);
    method public static java.time.LocalDateTime ofInstant(java.time.Instant, java.time.ZoneId);
    method public static java.time.LocalDateTime parse(CharSequence);
    method public static java.time.LocalDateTime parse(CharSequence, java.time.format.DateTimeFormatter);
    method public java.time.LocalDateTime plus(java.time.temporal.TemporalAmount);
    method public java.time.LocalDateTime plus(long, java.time.temporal.TemporalUnit);
    method public java.time.LocalDateTime plusDays(long);
    method public java.time.LocalDateTime plusHours(long);
    method public java.time.LocalDateTime plusMinutes(long);
    method public java.time.LocalDateTime plusMonths(long);
    method public java.time.LocalDateTime plusNanos(long);
    method public java.time.LocalDateTime plusSeconds(long);
    method public java.time.LocalDateTime plusWeeks(long);
    method public java.time.LocalDateTime plusYears(long);
    method public <R> R query(java.time.temporal.TemporalQuery<R>);
    method public java.time.temporal.ValueRange range(java.time.temporal.TemporalField);
    method public java.time.LocalDate toLocalDate();
    method public java.time.LocalTime toLocalTime();
    method public String toString();
    method public java.time.LocalDateTime truncatedTo(java.time.temporal.TemporalUnit);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.LocalDateTime with(java.time.temporal.TemporalAdjuster);
    method public java.time.LocalDateTime with(java.time.temporal.TemporalField, long);
    method public java.time.LocalDateTime withDayOfMonth(int);
    method public java.time.LocalDateTime withDayOfYear(int);
    method public java.time.LocalDateTime withHour(int);
    method public java.time.LocalDateTime withMinute(int);
    method public java.time.LocalDateTime withMonth(int);
    method public java.time.LocalDateTime withNano(int);
    method public java.time.LocalDateTime withSecond(int);
    method public java.time.LocalDateTime withYear(int);
    field public static final java.time.LocalDateTime MAX;
    field public static final java.time.LocalDateTime MIN;
  }

  public final class LocalTime implements java.lang.Comparable<java.time.LocalTime> java.io.Serializable java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public java.time.LocalDateTime atDate(java.time.LocalDate);
    method public java.time.OffsetTime atOffset(java.time.ZoneOffset);
    method public int compareTo(java.time.LocalTime);
    method public String format(java.time.format.DateTimeFormatter);
    method public static java.time.LocalTime from(java.time.temporal.TemporalAccessor);
    method public int get(java.time.temporal.TemporalField);
    method public int getHour();
    method public long getLong(java.time.temporal.TemporalField);
    method public int getMinute();
    method public int getNano();
    method public int getSecond();
    method public boolean isAfter(java.time.LocalTime);
    method public boolean isBefore(java.time.LocalTime);
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public boolean isSupported(java.time.temporal.TemporalUnit);
    method public java.time.LocalTime minus(java.time.temporal.TemporalAmount);
    method public java.time.LocalTime minus(long, java.time.temporal.TemporalUnit);
    method public java.time.LocalTime minusHours(long);
    method public java.time.LocalTime minusMinutes(long);
    method public java.time.LocalTime minusNanos(long);
    method public java.time.LocalTime minusSeconds(long);
    method public static java.time.LocalTime now();
    method public static java.time.LocalTime now(java.time.ZoneId);
    method public static java.time.LocalTime now(java.time.Clock);
    method public static java.time.LocalTime of(int, int);
    method public static java.time.LocalTime of(int, int, int);
    method public static java.time.LocalTime of(int, int, int, int);
    method public static java.time.LocalTime ofInstant(java.time.Instant, java.time.ZoneId);
    method public static java.time.LocalTime ofNanoOfDay(long);
    method public static java.time.LocalTime ofSecondOfDay(long);
    method public static java.time.LocalTime parse(CharSequence);
    method public static java.time.LocalTime parse(CharSequence, java.time.format.DateTimeFormatter);
    method public java.time.LocalTime plus(java.time.temporal.TemporalAmount);
    method public java.time.LocalTime plus(long, java.time.temporal.TemporalUnit);
    method public java.time.LocalTime plusHours(long);
    method public java.time.LocalTime plusMinutes(long);
    method public java.time.LocalTime plusNanos(long);
    method public java.time.LocalTime plusSeconds(long);
    method public <R> R query(java.time.temporal.TemporalQuery<R>);
    method public java.time.temporal.ValueRange range(java.time.temporal.TemporalField);
    method public long toEpochSecond(java.time.LocalDate, java.time.ZoneOffset);
    method public long toNanoOfDay();
    method public int toSecondOfDay();
    method public java.time.LocalTime truncatedTo(java.time.temporal.TemporalUnit);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.LocalTime with(java.time.temporal.TemporalAdjuster);
    method public java.time.LocalTime with(java.time.temporal.TemporalField, long);
    method public java.time.LocalTime withHour(int);
    method public java.time.LocalTime withMinute(int);
    method public java.time.LocalTime withNano(int);
    method public java.time.LocalTime withSecond(int);
    field public static final java.time.LocalTime MAX;
    field public static final java.time.LocalTime MIDNIGHT;
    field public static final java.time.LocalTime MIN;
    field public static final java.time.LocalTime NOON;
  }

  public enum Month implements java.time.temporal.TemporalAccessor java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public int firstDayOfYear(boolean);
    method public java.time.Month firstMonthOfQuarter();
    method public static java.time.Month from(java.time.temporal.TemporalAccessor);
    method public String getDisplayName(java.time.format.TextStyle, java.util.Locale);
    method public long getLong(java.time.temporal.TemporalField);
    method public int getValue();
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public int length(boolean);
    method public int maxLength();
    method public int minLength();
    method public java.time.Month minus(long);
    method public static java.time.Month of(int);
    method public java.time.Month plus(long);
    enum_constant public static final java.time.Month APRIL;
    enum_constant public static final java.time.Month AUGUST;
    enum_constant public static final java.time.Month DECEMBER;
    enum_constant public static final java.time.Month FEBRUARY;
    enum_constant public static final java.time.Month JANUARY;
    enum_constant public static final java.time.Month JULY;
    enum_constant public static final java.time.Month JUNE;
    enum_constant public static final java.time.Month MARCH;
    enum_constant public static final java.time.Month MAY;
    enum_constant public static final java.time.Month NOVEMBER;
    enum_constant public static final java.time.Month OCTOBER;
    enum_constant public static final java.time.Month SEPTEMBER;
  }

  public final class MonthDay implements java.lang.Comparable<java.time.MonthDay> java.io.Serializable java.time.temporal.TemporalAccessor java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public java.time.LocalDate atYear(int);
    method public int compareTo(java.time.MonthDay);
    method public String format(java.time.format.DateTimeFormatter);
    method public static java.time.MonthDay from(java.time.temporal.TemporalAccessor);
    method public int get(java.time.temporal.TemporalField);
    method public int getDayOfMonth();
    method public long getLong(java.time.temporal.TemporalField);
    method public java.time.Month getMonth();
    method public int getMonthValue();
    method public boolean isAfter(java.time.MonthDay);
    method public boolean isBefore(java.time.MonthDay);
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public boolean isValidYear(int);
    method public static java.time.MonthDay now();
    method public static java.time.MonthDay now(java.time.ZoneId);
    method public static java.time.MonthDay now(java.time.Clock);
    method public static java.time.MonthDay of(java.time.Month, int);
    method public static java.time.MonthDay of(int, int);
    method public static java.time.MonthDay parse(CharSequence);
    method public static java.time.MonthDay parse(CharSequence, java.time.format.DateTimeFormatter);
    method public <R> R query(java.time.temporal.TemporalQuery<R>);
    method public java.time.temporal.ValueRange range(java.time.temporal.TemporalField);
    method public java.time.MonthDay with(java.time.Month);
    method public java.time.MonthDay withDayOfMonth(int);
    method public java.time.MonthDay withMonth(int);
  }

  public final class OffsetDateTime implements java.lang.Comparable<java.time.OffsetDateTime> java.io.Serializable java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public java.time.ZonedDateTime atZoneSameInstant(java.time.ZoneId);
    method public java.time.ZonedDateTime atZoneSimilarLocal(java.time.ZoneId);
    method public int compareTo(java.time.OffsetDateTime);
    method public String format(java.time.format.DateTimeFormatter);
    method public static java.time.OffsetDateTime from(java.time.temporal.TemporalAccessor);
    method public int get(java.time.temporal.TemporalField);
    method public int getDayOfMonth();
    method public java.time.DayOfWeek getDayOfWeek();
    method public int getDayOfYear();
    method public int getHour();
    method public long getLong(java.time.temporal.TemporalField);
    method public int getMinute();
    method public java.time.Month getMonth();
    method public int getMonthValue();
    method public int getNano();
    method public java.time.ZoneOffset getOffset();
    method public int getSecond();
    method public int getYear();
    method public boolean isAfter(java.time.OffsetDateTime);
    method public boolean isBefore(java.time.OffsetDateTime);
    method public boolean isEqual(java.time.OffsetDateTime);
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public boolean isSupported(java.time.temporal.TemporalUnit);
    method public java.time.OffsetDateTime minus(java.time.temporal.TemporalAmount);
    method public java.time.OffsetDateTime minus(long, java.time.temporal.TemporalUnit);
    method public java.time.OffsetDateTime minusDays(long);
    method public java.time.OffsetDateTime minusHours(long);
    method public java.time.OffsetDateTime minusMinutes(long);
    method public java.time.OffsetDateTime minusMonths(long);
    method public java.time.OffsetDateTime minusNanos(long);
    method public java.time.OffsetDateTime minusSeconds(long);
    method public java.time.OffsetDateTime minusWeeks(long);
    method public java.time.OffsetDateTime minusYears(long);
    method public static java.time.OffsetDateTime now();
    method public static java.time.OffsetDateTime now(java.time.ZoneId);
    method public static java.time.OffsetDateTime now(java.time.Clock);
    method public static java.time.OffsetDateTime of(java.time.LocalDate, java.time.LocalTime, java.time.ZoneOffset);
    method public static java.time.OffsetDateTime of(java.time.LocalDateTime, java.time.ZoneOffset);
    method public static java.time.OffsetDateTime of(int, int, int, int, int, int, int, java.time.ZoneOffset);
    method public static java.time.OffsetDateTime ofInstant(java.time.Instant, java.time.ZoneId);
    method public static java.time.OffsetDateTime parse(CharSequence);
    method public static java.time.OffsetDateTime parse(CharSequence, java.time.format.DateTimeFormatter);
    method public java.time.OffsetDateTime plus(java.time.temporal.TemporalAmount);
    method public java.time.OffsetDateTime plus(long, java.time.temporal.TemporalUnit);
    method public java.time.OffsetDateTime plusDays(long);
    method public java.time.OffsetDateTime plusHours(long);
    method public java.time.OffsetDateTime plusMinutes(long);
    method public java.time.OffsetDateTime plusMonths(long);
    method public java.time.OffsetDateTime plusNanos(long);
    method public java.time.OffsetDateTime plusSeconds(long);
    method public java.time.OffsetDateTime plusWeeks(long);
    method public java.time.OffsetDateTime plusYears(long);
    method public <R> R query(java.time.temporal.TemporalQuery<R>);
    method public java.time.temporal.ValueRange range(java.time.temporal.TemporalField);
    method public static java.util.Comparator<java.time.OffsetDateTime> timeLineOrder();
    method public long toEpochSecond();
    method public java.time.Instant toInstant();
    method public java.time.LocalDate toLocalDate();
    method public java.time.LocalDateTime toLocalDateTime();
    method public java.time.LocalTime toLocalTime();
    method public java.time.OffsetTime toOffsetTime();
    method public java.time.ZonedDateTime toZonedDateTime();
    method public java.time.OffsetDateTime truncatedTo(java.time.temporal.TemporalUnit);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.OffsetDateTime with(java.time.temporal.TemporalAdjuster);
    method public java.time.OffsetDateTime with(java.time.temporal.TemporalField, long);
    method public java.time.OffsetDateTime withDayOfMonth(int);
    method public java.time.OffsetDateTime withDayOfYear(int);
    method public java.time.OffsetDateTime withHour(int);
    method public java.time.OffsetDateTime withMinute(int);
    method public java.time.OffsetDateTime withMonth(int);
    method public java.time.OffsetDateTime withNano(int);
    method public java.time.OffsetDateTime withOffsetSameInstant(java.time.ZoneOffset);
    method public java.time.OffsetDateTime withOffsetSameLocal(java.time.ZoneOffset);
    method public java.time.OffsetDateTime withSecond(int);
    method public java.time.OffsetDateTime withYear(int);
    field public static final java.time.OffsetDateTime MAX;
    field public static final java.time.OffsetDateTime MIN;
  }

  public final class OffsetTime implements java.lang.Comparable<java.time.OffsetTime> java.io.Serializable java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public java.time.OffsetDateTime atDate(java.time.LocalDate);
    method public int compareTo(java.time.OffsetTime);
    method public String format(java.time.format.DateTimeFormatter);
    method public static java.time.OffsetTime from(java.time.temporal.TemporalAccessor);
    method public int get(java.time.temporal.TemporalField);
    method public int getHour();
    method public long getLong(java.time.temporal.TemporalField);
    method public int getMinute();
    method public int getNano();
    method public java.time.ZoneOffset getOffset();
    method public int getSecond();
    method public boolean isAfter(java.time.OffsetTime);
    method public boolean isBefore(java.time.OffsetTime);
    method public boolean isEqual(java.time.OffsetTime);
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public boolean isSupported(java.time.temporal.TemporalUnit);
    method public java.time.OffsetTime minus(java.time.temporal.TemporalAmount);
    method public java.time.OffsetTime minus(long, java.time.temporal.TemporalUnit);
    method public java.time.OffsetTime minusHours(long);
    method public java.time.OffsetTime minusMinutes(long);
    method public java.time.OffsetTime minusNanos(long);
    method public java.time.OffsetTime minusSeconds(long);
    method public static java.time.OffsetTime now();
    method public static java.time.OffsetTime now(java.time.ZoneId);
    method public static java.time.OffsetTime now(java.time.Clock);
    method public static java.time.OffsetTime of(java.time.LocalTime, java.time.ZoneOffset);
    method public static java.time.OffsetTime of(int, int, int, int, java.time.ZoneOffset);
    method public static java.time.OffsetTime ofInstant(java.time.Instant, java.time.ZoneId);
    method public static java.time.OffsetTime parse(CharSequence);
    method public static java.time.OffsetTime parse(CharSequence, java.time.format.DateTimeFormatter);
    method public java.time.OffsetTime plus(java.time.temporal.TemporalAmount);
    method public java.time.OffsetTime plus(long, java.time.temporal.TemporalUnit);
    method public java.time.OffsetTime plusHours(long);
    method public java.time.OffsetTime plusMinutes(long);
    method public java.time.OffsetTime plusNanos(long);
    method public java.time.OffsetTime plusSeconds(long);
    method public <R> R query(java.time.temporal.TemporalQuery<R>);
    method public java.time.temporal.ValueRange range(java.time.temporal.TemporalField);
    method public long toEpochSecond(java.time.LocalDate);
    method public java.time.LocalTime toLocalTime();
    method public java.time.OffsetTime truncatedTo(java.time.temporal.TemporalUnit);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.OffsetTime with(java.time.temporal.TemporalAdjuster);
    method public java.time.OffsetTime with(java.time.temporal.TemporalField, long);
    method public java.time.OffsetTime withHour(int);
    method public java.time.OffsetTime withMinute(int);
    method public java.time.OffsetTime withNano(int);
    method public java.time.OffsetTime withOffsetSameInstant(java.time.ZoneOffset);
    method public java.time.OffsetTime withOffsetSameLocal(java.time.ZoneOffset);
    method public java.time.OffsetTime withSecond(int);
    field public static final java.time.OffsetTime MAX;
    field public static final java.time.OffsetTime MIN;
  }

  public final class Period implements java.time.chrono.ChronoPeriod java.io.Serializable {
    method public java.time.temporal.Temporal addTo(java.time.temporal.Temporal);
    method public static java.time.Period between(java.time.LocalDate, java.time.LocalDate);
    method public boolean equals(Object);
    method public static java.time.Period from(java.time.temporal.TemporalAmount);
    method public long get(java.time.temporal.TemporalUnit);
    method public java.time.chrono.IsoChronology getChronology();
    method public int getDays();
    method public int getMonths();
    method public java.util.List<java.time.temporal.TemporalUnit> getUnits();
    method public int getYears();
    method public int hashCode();
    method public boolean isNegative();
    method public boolean isZero();
    method public java.time.Period minus(java.time.temporal.TemporalAmount);
    method public java.time.Period minusDays(long);
    method public java.time.Period minusMonths(long);
    method public java.time.Period minusYears(long);
    method public java.time.Period multipliedBy(int);
    method public java.time.Period negated();
    method public java.time.Period normalized();
    method public static java.time.Period of(int, int, int);
    method public static java.time.Period ofDays(int);
    method public static java.time.Period ofMonths(int);
    method public static java.time.Period ofWeeks(int);
    method public static java.time.Period ofYears(int);
    method public static java.time.Period parse(CharSequence);
    method public java.time.Period plus(java.time.temporal.TemporalAmount);
    method public java.time.Period plusDays(long);
    method public java.time.Period plusMonths(long);
    method public java.time.Period plusYears(long);
    method public java.time.temporal.Temporal subtractFrom(java.time.temporal.Temporal);
    method public String toString();
    method public long toTotalMonths();
    method public java.time.Period withDays(int);
    method public java.time.Period withMonths(int);
    method public java.time.Period withYears(int);
    field public static final java.time.Period ZERO;
  }

  public final class Year implements java.lang.Comparable<java.time.Year> java.io.Serializable java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public java.time.LocalDate atDay(int);
    method public java.time.YearMonth atMonth(java.time.Month);
    method public java.time.YearMonth atMonth(int);
    method public java.time.LocalDate atMonthDay(java.time.MonthDay);
    method public int compareTo(java.time.Year);
    method public String format(java.time.format.DateTimeFormatter);
    method public static java.time.Year from(java.time.temporal.TemporalAccessor);
    method public int get(java.time.temporal.TemporalField);
    method public long getLong(java.time.temporal.TemporalField);
    method public int getValue();
    method public boolean isAfter(java.time.Year);
    method public boolean isBefore(java.time.Year);
    method public static boolean isLeap(long);
    method public boolean isLeap();
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public boolean isSupported(java.time.temporal.TemporalUnit);
    method public boolean isValidMonthDay(java.time.MonthDay);
    method public int length();
    method public java.time.Year minus(java.time.temporal.TemporalAmount);
    method public java.time.Year minus(long, java.time.temporal.TemporalUnit);
    method public java.time.Year minusYears(long);
    method public static java.time.Year now();
    method public static java.time.Year now(java.time.ZoneId);
    method public static java.time.Year now(java.time.Clock);
    method public static java.time.Year of(int);
    method public static java.time.Year parse(CharSequence);
    method public static java.time.Year parse(CharSequence, java.time.format.DateTimeFormatter);
    method public java.time.Year plus(java.time.temporal.TemporalAmount);
    method public java.time.Year plus(long, java.time.temporal.TemporalUnit);
    method public java.time.Year plusYears(long);
    method public <R> R query(java.time.temporal.TemporalQuery<R>);
    method public java.time.temporal.ValueRange range(java.time.temporal.TemporalField);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.Year with(java.time.temporal.TemporalAdjuster);
    method public java.time.Year with(java.time.temporal.TemporalField, long);
    field public static final int MAX_VALUE = 999999999; // 0x3b9ac9ff
    field public static final int MIN_VALUE = -999999999; // 0xc4653601
  }

  public final class YearMonth implements java.lang.Comparable<java.time.YearMonth> java.io.Serializable java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public java.time.LocalDate atDay(int);
    method public java.time.LocalDate atEndOfMonth();
    method public int compareTo(java.time.YearMonth);
    method public String format(java.time.format.DateTimeFormatter);
    method public static java.time.YearMonth from(java.time.temporal.TemporalAccessor);
    method public int get(java.time.temporal.TemporalField);
    method public long getLong(java.time.temporal.TemporalField);
    method public java.time.Month getMonth();
    method public int getMonthValue();
    method public int getYear();
    method public boolean isAfter(java.time.YearMonth);
    method public boolean isBefore(java.time.YearMonth);
    method public boolean isLeapYear();
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public boolean isSupported(java.time.temporal.TemporalUnit);
    method public boolean isValidDay(int);
    method public int lengthOfMonth();
    method public int lengthOfYear();
    method public java.time.YearMonth minus(java.time.temporal.TemporalAmount);
    method public java.time.YearMonth minus(long, java.time.temporal.TemporalUnit);
    method public java.time.YearMonth minusMonths(long);
    method public java.time.YearMonth minusYears(long);
    method public static java.time.YearMonth now();
    method public static java.time.YearMonth now(java.time.ZoneId);
    method public static java.time.YearMonth now(java.time.Clock);
    method public static java.time.YearMonth of(int, java.time.Month);
    method public static java.time.YearMonth of(int, int);
    method public static java.time.YearMonth parse(CharSequence);
    method public static java.time.YearMonth parse(CharSequence, java.time.format.DateTimeFormatter);
    method public java.time.YearMonth plus(java.time.temporal.TemporalAmount);
    method public java.time.YearMonth plus(long, java.time.temporal.TemporalUnit);
    method public java.time.YearMonth plusMonths(long);
    method public java.time.YearMonth plusYears(long);
    method public <R> R query(java.time.temporal.TemporalQuery<R>);
    method public java.time.temporal.ValueRange range(java.time.temporal.TemporalField);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.YearMonth with(java.time.temporal.TemporalAdjuster);
    method public java.time.YearMonth with(java.time.temporal.TemporalField, long);
    method public java.time.YearMonth withMonth(int);
    method public java.time.YearMonth withYear(int);
  }

  public abstract class ZoneId implements java.io.Serializable {
    method public static java.time.ZoneId from(java.time.temporal.TemporalAccessor);
    method public static java.util.Set<java.lang.String> getAvailableZoneIds();
    method public String getDisplayName(java.time.format.TextStyle, java.util.Locale);
    method public abstract String getId();
    method public abstract java.time.zone.ZoneRules getRules();
    method public java.time.ZoneId normalized();
    method public static java.time.ZoneId of(String, java.util.Map<java.lang.String,java.lang.String>);
    method public static java.time.ZoneId of(String);
    method public static java.time.ZoneId ofOffset(String, java.time.ZoneOffset);
    method public static java.time.ZoneId systemDefault();
    field public static final java.util.Map<java.lang.String,java.lang.String> SHORT_IDS;
  }

  public final class ZoneOffset extends java.time.ZoneId implements java.lang.Comparable<java.time.ZoneOffset> java.io.Serializable java.time.temporal.TemporalAccessor java.time.temporal.TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public int compareTo(java.time.ZoneOffset);
    method public static java.time.ZoneOffset from(java.time.temporal.TemporalAccessor);
    method public int get(java.time.temporal.TemporalField);
    method public String getId();
    method public long getLong(java.time.temporal.TemporalField);
    method public java.time.zone.ZoneRules getRules();
    method public int getTotalSeconds();
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public static java.time.ZoneOffset of(String);
    method public static java.time.ZoneOffset ofHours(int);
    method public static java.time.ZoneOffset ofHoursMinutes(int, int);
    method public static java.time.ZoneOffset ofHoursMinutesSeconds(int, int, int);
    method public static java.time.ZoneOffset ofTotalSeconds(int);
    method public <R> R query(java.time.temporal.TemporalQuery<R>);
    method public java.time.temporal.ValueRange range(java.time.temporal.TemporalField);
    field public static final java.time.ZoneOffset MAX;
    field public static final java.time.ZoneOffset MIN;
    field public static final java.time.ZoneOffset UTC;
  }

  public final class ZonedDateTime implements java.time.chrono.ChronoZonedDateTime<java.time.LocalDate> java.io.Serializable java.time.temporal.Temporal {
    method public boolean equals(Object);
    method public String format(java.time.format.DateTimeFormatter);
    method public static java.time.ZonedDateTime from(java.time.temporal.TemporalAccessor);
    method public int get(java.time.temporal.TemporalField);
    method public int getDayOfMonth();
    method public java.time.DayOfWeek getDayOfWeek();
    method public int getDayOfYear();
    method public int getHour();
    method public long getLong(java.time.temporal.TemporalField);
    method public int getMinute();
    method public java.time.Month getMonth();
    method public int getMonthValue();
    method public int getNano();
    method public java.time.ZoneOffset getOffset();
    method public int getSecond();
    method public int getYear();
    method public java.time.ZoneId getZone();
    method public int hashCode();
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public boolean isSupported(java.time.temporal.TemporalUnit);
    method public java.time.ZonedDateTime minus(java.time.temporal.TemporalAmount);
    method public java.time.ZonedDateTime minus(long, java.time.temporal.TemporalUnit);
    method public java.time.ZonedDateTime minusDays(long);
    method public java.time.ZonedDateTime minusHours(long);
    method public java.time.ZonedDateTime minusMinutes(long);
    method public java.time.ZonedDateTime minusMonths(long);
    method public java.time.ZonedDateTime minusNanos(long);
    method public java.time.ZonedDateTime minusSeconds(long);
    method public java.time.ZonedDateTime minusWeeks(long);
    method public java.time.ZonedDateTime minusYears(long);
    method public static java.time.ZonedDateTime now();
    method public static java.time.ZonedDateTime now(java.time.ZoneId);
    method public static java.time.ZonedDateTime now(java.time.Clock);
    method public static java.time.ZonedDateTime of(java.time.LocalDate, java.time.LocalTime, java.time.ZoneId);
    method public static java.time.ZonedDateTime of(java.time.LocalDateTime, java.time.ZoneId);
    method public static java.time.ZonedDateTime of(int, int, int, int, int, int, int, java.time.ZoneId);
    method public static java.time.ZonedDateTime ofInstant(java.time.Instant, java.time.ZoneId);
    method public static java.time.ZonedDateTime ofInstant(java.time.LocalDateTime, java.time.ZoneOffset, java.time.ZoneId);
    method public static java.time.ZonedDateTime ofLocal(java.time.LocalDateTime, java.time.ZoneId, java.time.ZoneOffset);
    method public static java.time.ZonedDateTime ofStrict(java.time.LocalDateTime, java.time.ZoneOffset, java.time.ZoneId);
    method public static java.time.ZonedDateTime parse(CharSequence);
    method public static java.time.ZonedDateTime parse(CharSequence, java.time.format.DateTimeFormatter);
    method public java.time.ZonedDateTime plus(java.time.temporal.TemporalAmount);
    method public java.time.ZonedDateTime plus(long, java.time.temporal.TemporalUnit);
    method public java.time.ZonedDateTime plusDays(long);
    method public java.time.ZonedDateTime plusHours(long);
    method public java.time.ZonedDateTime plusMinutes(long);
    method public java.time.ZonedDateTime plusMonths(long);
    method public java.time.ZonedDateTime plusNanos(long);
    method public java.time.ZonedDateTime plusSeconds(long);
    method public java.time.ZonedDateTime plusWeeks(long);
    method public java.time.ZonedDateTime plusYears(long);
    method public <R> R query(java.time.temporal.TemporalQuery<R>);
    method public java.time.temporal.ValueRange range(java.time.temporal.TemporalField);
    method public java.time.LocalDate toLocalDate();
    method public java.time.LocalDateTime toLocalDateTime();
    method public java.time.LocalTime toLocalTime();
    method public java.time.OffsetDateTime toOffsetDateTime();
    method public String toString();
    method public java.time.ZonedDateTime truncatedTo(java.time.temporal.TemporalUnit);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.ZonedDateTime with(java.time.temporal.TemporalAdjuster);
    method public java.time.ZonedDateTime with(java.time.temporal.TemporalField, long);
    method public java.time.ZonedDateTime withDayOfMonth(int);
    method public java.time.ZonedDateTime withDayOfYear(int);
    method public java.time.ZonedDateTime withEarlierOffsetAtOverlap();
    method public java.time.ZonedDateTime withFixedOffsetZone();
    method public java.time.ZonedDateTime withHour(int);
    method public java.time.ZonedDateTime withLaterOffsetAtOverlap();
    method public java.time.ZonedDateTime withMinute(int);
    method public java.time.ZonedDateTime withMonth(int);
    method public java.time.ZonedDateTime withNano(int);
    method public java.time.ZonedDateTime withSecond(int);
    method public java.time.ZonedDateTime withYear(int);
    method public java.time.ZonedDateTime withZoneSameInstant(java.time.ZoneId);
    method public java.time.ZonedDateTime withZoneSameLocal(java.time.ZoneId);
  }

}

package java.time.chrono {

  public abstract class AbstractChronology implements java.time.chrono.Chronology {
    ctor protected AbstractChronology();
    method public int compareTo(java.time.chrono.Chronology);
    method public boolean equals(Object);
    method public int hashCode();
    method public java.time.chrono.ChronoLocalDate resolveDate(java.util.Map<java.time.temporal.TemporalField,java.lang.Long>, java.time.format.ResolverStyle);
    method public String toString();
  }

  public interface ChronoLocalDate extends java.time.temporal.Temporal java.lang.Comparable<java.time.chrono.ChronoLocalDate> java.time.temporal.TemporalAdjuster {
    method public default java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public default java.time.chrono.ChronoLocalDateTime<?> atTime(java.time.LocalTime);
    method public default int compareTo(java.time.chrono.ChronoLocalDate);
    method public boolean equals(Object);
    method public default String format(java.time.format.DateTimeFormatter);
    method public static java.time.chrono.ChronoLocalDate from(java.time.temporal.TemporalAccessor);
    method public java.time.chrono.Chronology getChronology();
    method public default java.time.chrono.Era getEra();
    method public int hashCode();
    method public default boolean isAfter(java.time.chrono.ChronoLocalDate);
    method public default boolean isBefore(java.time.chrono.ChronoLocalDate);
    method public default boolean isEqual(java.time.chrono.ChronoLocalDate);
    method public default boolean isLeapYear();
    method public default boolean isSupported(java.time.temporal.TemporalField);
    method public default boolean isSupported(java.time.temporal.TemporalUnit);
    method public int lengthOfMonth();
    method public default int lengthOfYear();
    method public default java.time.chrono.ChronoLocalDate minus(java.time.temporal.TemporalAmount);
    method public default java.time.chrono.ChronoLocalDate minus(long, java.time.temporal.TemporalUnit);
    method public default java.time.chrono.ChronoLocalDate plus(java.time.temporal.TemporalAmount);
    method public default java.time.chrono.ChronoLocalDate plus(long, java.time.temporal.TemporalUnit);
    method public static java.util.Comparator<java.time.chrono.ChronoLocalDate> timeLineOrder();
    method public default long toEpochDay();
    method public String toString();
    method public java.time.chrono.ChronoPeriod until(java.time.chrono.ChronoLocalDate);
    method public default java.time.chrono.ChronoLocalDate with(java.time.temporal.TemporalAdjuster);
    method public default java.time.chrono.ChronoLocalDate with(java.time.temporal.TemporalField, long);
  }

  public interface ChronoLocalDateTime<D extends java.time.chrono.ChronoLocalDate> extends java.time.temporal.Temporal java.lang.Comparable<java.time.chrono.ChronoLocalDateTime<?>> java.time.temporal.TemporalAdjuster {
    method public default java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public java.time.chrono.ChronoZonedDateTime<D> atZone(java.time.ZoneId);
    method public default int compareTo(java.time.chrono.ChronoLocalDateTime<?>);
    method public boolean equals(Object);
    method public default String format(java.time.format.DateTimeFormatter);
    method public static java.time.chrono.ChronoLocalDateTime<?> from(java.time.temporal.TemporalAccessor);
    method public default java.time.chrono.Chronology getChronology();
    method public int hashCode();
    method public default boolean isAfter(java.time.chrono.ChronoLocalDateTime<?>);
    method public default boolean isBefore(java.time.chrono.ChronoLocalDateTime<?>);
    method public default boolean isEqual(java.time.chrono.ChronoLocalDateTime<?>);
    method public default boolean isSupported(java.time.temporal.TemporalUnit);
    method public default java.time.chrono.ChronoLocalDateTime<D> minus(java.time.temporal.TemporalAmount);
    method public default java.time.chrono.ChronoLocalDateTime<D> minus(long, java.time.temporal.TemporalUnit);
    method public default java.time.chrono.ChronoLocalDateTime<D> plus(java.time.temporal.TemporalAmount);
    method public java.time.chrono.ChronoLocalDateTime<D> plus(long, java.time.temporal.TemporalUnit);
    method public static java.util.Comparator<java.time.chrono.ChronoLocalDateTime<?>> timeLineOrder();
    method public default long toEpochSecond(java.time.ZoneOffset);
    method public default java.time.Instant toInstant(java.time.ZoneOffset);
    method public D toLocalDate();
    method public java.time.LocalTime toLocalTime();
    method public String toString();
    method public default java.time.chrono.ChronoLocalDateTime<D> with(java.time.temporal.TemporalAdjuster);
    method public java.time.chrono.ChronoLocalDateTime<D> with(java.time.temporal.TemporalField, long);
  }

  public interface ChronoPeriod extends java.time.temporal.TemporalAmount {
    method public static java.time.chrono.ChronoPeriod between(java.time.chrono.ChronoLocalDate, java.time.chrono.ChronoLocalDate);
    method public boolean equals(Object);
    method public java.time.chrono.Chronology getChronology();
    method public int hashCode();
    method public default boolean isNegative();
    method public default boolean isZero();
    method public java.time.chrono.ChronoPeriod minus(java.time.temporal.TemporalAmount);
    method public java.time.chrono.ChronoPeriod multipliedBy(int);
    method public default java.time.chrono.ChronoPeriod negated();
    method public java.time.chrono.ChronoPeriod normalized();
    method public java.time.chrono.ChronoPeriod plus(java.time.temporal.TemporalAmount);
    method public String toString();
  }

  public interface ChronoZonedDateTime<D extends java.time.chrono.ChronoLocalDate> extends java.time.temporal.Temporal java.lang.Comparable<java.time.chrono.ChronoZonedDateTime<?>> {
    method public default int compareTo(java.time.chrono.ChronoZonedDateTime<?>);
    method public boolean equals(Object);
    method public default String format(java.time.format.DateTimeFormatter);
    method public static java.time.chrono.ChronoZonedDateTime<?> from(java.time.temporal.TemporalAccessor);
    method public default java.time.chrono.Chronology getChronology();
    method public default long getLong(java.time.temporal.TemporalField);
    method public java.time.ZoneOffset getOffset();
    method public java.time.ZoneId getZone();
    method public int hashCode();
    method public default boolean isAfter(java.time.chrono.ChronoZonedDateTime<?>);
    method public default boolean isBefore(java.time.chrono.ChronoZonedDateTime<?>);
    method public default boolean isEqual(java.time.chrono.ChronoZonedDateTime<?>);
    method public default boolean isSupported(java.time.temporal.TemporalUnit);
    method public default java.time.chrono.ChronoZonedDateTime<D> minus(java.time.temporal.TemporalAmount);
    method public default java.time.chrono.ChronoZonedDateTime<D> minus(long, java.time.temporal.TemporalUnit);
    method public default java.time.chrono.ChronoZonedDateTime<D> plus(java.time.temporal.TemporalAmount);
    method public java.time.chrono.ChronoZonedDateTime<D> plus(long, java.time.temporal.TemporalUnit);
    method public static java.util.Comparator<java.time.chrono.ChronoZonedDateTime<?>> timeLineOrder();
    method public default long toEpochSecond();
    method public default java.time.Instant toInstant();
    method public default D toLocalDate();
    method public java.time.chrono.ChronoLocalDateTime<D> toLocalDateTime();
    method public default java.time.LocalTime toLocalTime();
    method public String toString();
    method public default java.time.chrono.ChronoZonedDateTime<D> with(java.time.temporal.TemporalAdjuster);
    method public java.time.chrono.ChronoZonedDateTime<D> with(java.time.temporal.TemporalField, long);
    method public java.time.chrono.ChronoZonedDateTime<D> withEarlierOffsetAtOverlap();
    method public java.time.chrono.ChronoZonedDateTime<D> withLaterOffsetAtOverlap();
    method public java.time.chrono.ChronoZonedDateTime<D> withZoneSameInstant(java.time.ZoneId);
    method public java.time.chrono.ChronoZonedDateTime<D> withZoneSameLocal(java.time.ZoneId);
  }

  public interface Chronology extends java.lang.Comparable<java.time.chrono.Chronology> {
    method public int compareTo(java.time.chrono.Chronology);
    method public default java.time.chrono.ChronoLocalDate date(java.time.chrono.Era, int, int, int);
    method public java.time.chrono.ChronoLocalDate date(int, int, int);
    method public java.time.chrono.ChronoLocalDate date(java.time.temporal.TemporalAccessor);
    method public java.time.chrono.ChronoLocalDate dateEpochDay(long);
    method public default java.time.chrono.ChronoLocalDate dateNow();
    method public default java.time.chrono.ChronoLocalDate dateNow(java.time.ZoneId);
    method public default java.time.chrono.ChronoLocalDate dateNow(java.time.Clock);
    method public default java.time.chrono.ChronoLocalDate dateYearDay(java.time.chrono.Era, int, int);
    method public java.time.chrono.ChronoLocalDate dateYearDay(int, int);
    method public default long epochSecond(int, int, int, int, int, int, java.time.ZoneOffset);
    method public default long epochSecond(java.time.chrono.Era, int, int, int, int, int, int, java.time.ZoneOffset);
    method public boolean equals(Object);
    method public java.time.chrono.Era eraOf(int);
    method public java.util.List<java.time.chrono.Era> eras();
    method public static java.time.chrono.Chronology from(java.time.temporal.TemporalAccessor);
    method public static java.util.Set<java.time.chrono.Chronology> getAvailableChronologies();
    method public String getCalendarType();
    method public default String getDisplayName(java.time.format.TextStyle, java.util.Locale);
    method public String getId();
    method public int hashCode();
    method public boolean isLeapYear(long);
    method public default java.time.chrono.ChronoLocalDateTime<? extends java.time.chrono.ChronoLocalDate> localDateTime(java.time.temporal.TemporalAccessor);
    method public static java.time.chrono.Chronology of(String);
    method public static java.time.chrono.Chronology ofLocale(java.util.Locale);
    method public default java.time.chrono.ChronoPeriod period(int, int, int);
    method public int prolepticYear(java.time.chrono.Era, int);
    method public java.time.temporal.ValueRange range(java.time.temporal.ChronoField);
    method public java.time.chrono.ChronoLocalDate resolveDate(java.util.Map<java.time.temporal.TemporalField,java.lang.Long>, java.time.format.ResolverStyle);
    method public String toString();
    method public default java.time.chrono.ChronoZonedDateTime<? extends java.time.chrono.ChronoLocalDate> zonedDateTime(java.time.temporal.TemporalAccessor);
    method public default java.time.chrono.ChronoZonedDateTime<? extends java.time.chrono.ChronoLocalDate> zonedDateTime(java.time.Instant, java.time.ZoneId);
  }

  public interface Era extends java.time.temporal.TemporalAccessor java.time.temporal.TemporalAdjuster {
    method public default java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
    method public default String getDisplayName(java.time.format.TextStyle, java.util.Locale);
    method public default long getLong(java.time.temporal.TemporalField);
    method public int getValue();
    method public default boolean isSupported(java.time.temporal.TemporalField);
  }

  public final class HijrahChronology extends java.time.chrono.AbstractChronology implements java.io.Serializable {
    method public java.time.chrono.HijrahDate date(java.time.chrono.Era, int, int, int);
    method public java.time.chrono.HijrahDate date(int, int, int);
    method public java.time.chrono.HijrahDate date(java.time.temporal.TemporalAccessor);
    method public java.time.chrono.HijrahDate dateEpochDay(long);
    method public java.time.chrono.HijrahDate dateNow();
    method public java.time.chrono.HijrahDate dateNow(java.time.ZoneId);
    method public java.time.chrono.HijrahDate dateNow(java.time.Clock);
    method public java.time.chrono.HijrahDate dateYearDay(java.time.chrono.Era, int, int);
    method public java.time.chrono.HijrahDate dateYearDay(int, int);
    method public java.time.chrono.HijrahEra eraOf(int);
    method public java.util.List<java.time.chrono.Era> eras();
    method public String getCalendarType();
    method public String getId();
    method public boolean isLeapYear(long);
    method public java.time.chrono.ChronoLocalDateTime<java.time.chrono.HijrahDate> localDateTime(java.time.temporal.TemporalAccessor);
    method public int prolepticYear(java.time.chrono.Era, int);
    method public java.time.temporal.ValueRange range(java.time.temporal.ChronoField);
    method public java.time.chrono.HijrahDate resolveDate(java.util.Map<java.time.temporal.TemporalField,java.lang.Long>, java.time.format.ResolverStyle);
    method public java.time.chrono.ChronoZonedDateTime<java.time.chrono.HijrahDate> zonedDateTime(java.time.temporal.TemporalAccessor);
    method public java.time.chrono.ChronoZonedDateTime<java.time.chrono.HijrahDate> zonedDateTime(java.time.Instant, java.time.ZoneId);
    field public static final java.time.chrono.HijrahChronology INSTANCE;
  }

  public final class HijrahDate implements java.time.chrono.ChronoLocalDate java.io.Serializable java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public java.time.chrono.ChronoLocalDateTime<java.time.chrono.HijrahDate> atTime(java.time.LocalTime);
    method public static java.time.chrono.HijrahDate from(java.time.temporal.TemporalAccessor);
    method public java.time.chrono.HijrahChronology getChronology();
    method public java.time.chrono.HijrahEra getEra();
    method public long getLong(java.time.temporal.TemporalField);
    method public boolean isLeapYear();
    method public int lengthOfMonth();
    method public int lengthOfYear();
    method public java.time.chrono.HijrahDate minus(java.time.temporal.TemporalAmount);
    method public java.time.chrono.HijrahDate minus(long, java.time.temporal.TemporalUnit);
    method public static java.time.chrono.HijrahDate now();
    method public static java.time.chrono.HijrahDate now(java.time.ZoneId);
    method public static java.time.chrono.HijrahDate now(java.time.Clock);
    method public static java.time.chrono.HijrahDate of(int, int, int);
    method public java.time.chrono.HijrahDate plus(java.time.temporal.TemporalAmount);
    method public java.time.chrono.HijrahDate plus(long, java.time.temporal.TemporalUnit);
    method public java.time.temporal.ValueRange range(java.time.temporal.TemporalField);
    method public long toEpochDay();
    method public String toString();
    method public java.time.chrono.ChronoPeriod until(java.time.chrono.ChronoLocalDate);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.chrono.HijrahDate with(java.time.temporal.TemporalField, long);
    method public java.time.chrono.HijrahDate with(java.time.temporal.TemporalAdjuster);
    method public java.time.chrono.HijrahDate withVariant(java.time.chrono.HijrahChronology);
  }

  public enum HijrahEra implements java.time.chrono.Era {
    method public int getValue();
    method public static java.time.chrono.HijrahEra of(int);
    enum_constant public static final java.time.chrono.HijrahEra AH;
  }

  public final class IsoChronology extends java.time.chrono.AbstractChronology implements java.io.Serializable {
    method public java.time.LocalDate date(java.time.chrono.Era, int, int, int);
    method public java.time.LocalDate date(int, int, int);
    method public java.time.LocalDate date(java.time.temporal.TemporalAccessor);
    method public java.time.LocalDate dateEpochDay(long);
    method public java.time.LocalDate dateNow();
    method public java.time.LocalDate dateNow(java.time.ZoneId);
    method public java.time.LocalDate dateNow(java.time.Clock);
    method public java.time.LocalDate dateYearDay(java.time.chrono.Era, int, int);
    method public java.time.LocalDate dateYearDay(int, int);
    method public long epochSecond(int, int, int, int, int, int, java.time.ZoneOffset);
    method public java.time.chrono.IsoEra eraOf(int);
    method public java.util.List<java.time.chrono.Era> eras();
    method public String getCalendarType();
    method public String getId();
    method public boolean isLeapYear(long);
    method public java.time.LocalDateTime localDateTime(java.time.temporal.TemporalAccessor);
    method public java.time.Period period(int, int, int);
    method public int prolepticYear(java.time.chrono.Era, int);
    method public java.time.temporal.ValueRange range(java.time.temporal.ChronoField);
    method public java.time.LocalDate resolveDate(java.util.Map<java.time.temporal.TemporalField,java.lang.Long>, java.time.format.ResolverStyle);
    method public java.time.ZonedDateTime zonedDateTime(java.time.temporal.TemporalAccessor);
    method public java.time.ZonedDateTime zonedDateTime(java.time.Instant, java.time.ZoneId);
    field public static final java.time.chrono.IsoChronology INSTANCE;
  }

  public enum IsoEra implements java.time.chrono.Era {
    method public int getValue();
    method public static java.time.chrono.IsoEra of(int);
    enum_constant public static final java.time.chrono.IsoEra BCE;
    enum_constant public static final java.time.chrono.IsoEra CE;
  }

  public final class JapaneseChronology extends java.time.chrono.AbstractChronology implements java.io.Serializable {
    method public java.time.chrono.JapaneseDate date(java.time.chrono.Era, int, int, int);
    method public java.time.chrono.JapaneseDate date(int, int, int);
    method public java.time.chrono.JapaneseDate date(java.time.temporal.TemporalAccessor);
    method public java.time.chrono.JapaneseDate dateEpochDay(long);
    method public java.time.chrono.JapaneseDate dateNow();
    method public java.time.chrono.JapaneseDate dateNow(java.time.ZoneId);
    method public java.time.chrono.JapaneseDate dateNow(java.time.Clock);
    method public java.time.chrono.JapaneseDate dateYearDay(java.time.chrono.Era, int, int);
    method public java.time.chrono.JapaneseDate dateYearDay(int, int);
    method public java.time.chrono.JapaneseEra eraOf(int);
    method public java.util.List<java.time.chrono.Era> eras();
    method public String getCalendarType();
    method public String getId();
    method public boolean isLeapYear(long);
    method public java.time.chrono.ChronoLocalDateTime<java.time.chrono.JapaneseDate> localDateTime(java.time.temporal.TemporalAccessor);
    method public int prolepticYear(java.time.chrono.Era, int);
    method public java.time.temporal.ValueRange range(java.time.temporal.ChronoField);
    method public java.time.chrono.JapaneseDate resolveDate(java.util.Map<java.time.temporal.TemporalField,java.lang.Long>, java.time.format.ResolverStyle);
    method public java.time.chrono.ChronoZonedDateTime<java.time.chrono.JapaneseDate> zonedDateTime(java.time.temporal.TemporalAccessor);
    method public java.time.chrono.ChronoZonedDateTime<java.time.chrono.JapaneseDate> zonedDateTime(java.time.Instant, java.time.ZoneId);
    field public static final java.time.chrono.JapaneseChronology INSTANCE;
  }

  public final class JapaneseDate implements java.time.chrono.ChronoLocalDate java.io.Serializable java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public java.time.chrono.ChronoLocalDateTime<java.time.chrono.JapaneseDate> atTime(java.time.LocalTime);
    method public static java.time.chrono.JapaneseDate from(java.time.temporal.TemporalAccessor);
    method public java.time.chrono.JapaneseChronology getChronology();
    method public java.time.chrono.JapaneseEra getEra();
    method public long getLong(java.time.temporal.TemporalField);
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public int lengthOfMonth();
    method public int lengthOfYear();
    method public java.time.chrono.JapaneseDate minus(java.time.temporal.TemporalAmount);
    method public java.time.chrono.JapaneseDate minus(long, java.time.temporal.TemporalUnit);
    method public static java.time.chrono.JapaneseDate now();
    method public static java.time.chrono.JapaneseDate now(java.time.ZoneId);
    method public static java.time.chrono.JapaneseDate now(java.time.Clock);
    method public static java.time.chrono.JapaneseDate of(java.time.chrono.JapaneseEra, int, int, int);
    method public static java.time.chrono.JapaneseDate of(int, int, int);
    method public java.time.chrono.JapaneseDate plus(java.time.temporal.TemporalAmount);
    method public java.time.chrono.JapaneseDate plus(long, java.time.temporal.TemporalUnit);
    method public java.time.temporal.ValueRange range(java.time.temporal.TemporalField);
    method public long toEpochDay();
    method public String toString();
    method public java.time.chrono.ChronoPeriod until(java.time.chrono.ChronoLocalDate);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.chrono.JapaneseDate with(java.time.temporal.TemporalField, long);
    method public java.time.chrono.JapaneseDate with(java.time.temporal.TemporalAdjuster);
  }

  public final class JapaneseEra implements java.time.chrono.Era java.io.Serializable {
    method public String getDisplayName(java.time.format.TextStyle, java.util.Locale);
    method public int getValue();
    method public static java.time.chrono.JapaneseEra of(int);
    method public java.time.temporal.ValueRange range(java.time.temporal.TemporalField);
    method public static java.time.chrono.JapaneseEra valueOf(String);
    method public static java.time.chrono.JapaneseEra[] values();
    field public static final java.time.chrono.JapaneseEra HEISEI;
    field public static final java.time.chrono.JapaneseEra MEIJI;
    field public static final java.time.chrono.JapaneseEra REIWA;
    field public static final java.time.chrono.JapaneseEra SHOWA;
    field public static final java.time.chrono.JapaneseEra TAISHO;
  }

  public final class MinguoChronology extends java.time.chrono.AbstractChronology implements java.io.Serializable {
    method public java.time.chrono.MinguoDate date(java.time.chrono.Era, int, int, int);
    method public java.time.chrono.MinguoDate date(int, int, int);
    method public java.time.chrono.MinguoDate date(java.time.temporal.TemporalAccessor);
    method public java.time.chrono.MinguoDate dateEpochDay(long);
    method public java.time.chrono.MinguoDate dateNow();
    method public java.time.chrono.MinguoDate dateNow(java.time.ZoneId);
    method public java.time.chrono.MinguoDate dateNow(java.time.Clock);
    method public java.time.chrono.MinguoDate dateYearDay(java.time.chrono.Era, int, int);
    method public java.time.chrono.MinguoDate dateYearDay(int, int);
    method public java.time.chrono.MinguoEra eraOf(int);
    method public java.util.List<java.time.chrono.Era> eras();
    method public String getCalendarType();
    method public String getId();
    method public boolean isLeapYear(long);
    method public java.time.chrono.ChronoLocalDateTime<java.time.chrono.MinguoDate> localDateTime(java.time.temporal.TemporalAccessor);
    method public int prolepticYear(java.time.chrono.Era, int);
    method public java.time.temporal.ValueRange range(java.time.temporal.ChronoField);
    method public java.time.chrono.MinguoDate resolveDate(java.util.Map<java.time.temporal.TemporalField,java.lang.Long>, java.time.format.ResolverStyle);
    method public java.time.chrono.ChronoZonedDateTime<java.time.chrono.MinguoDate> zonedDateTime(java.time.temporal.TemporalAccessor);
    method public java.time.chrono.ChronoZonedDateTime<java.time.chrono.MinguoDate> zonedDateTime(java.time.Instant, java.time.ZoneId);
    field public static final java.time.chrono.MinguoChronology INSTANCE;
  }

  public final class MinguoDate implements java.time.chrono.ChronoLocalDate java.io.Serializable java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public java.time.chrono.ChronoLocalDateTime<java.time.chrono.MinguoDate> atTime(java.time.LocalTime);
    method public static java.time.chrono.MinguoDate from(java.time.temporal.TemporalAccessor);
    method public java.time.chrono.MinguoChronology getChronology();
    method public java.time.chrono.MinguoEra getEra();
    method public long getLong(java.time.temporal.TemporalField);
    method public int lengthOfMonth();
    method public java.time.chrono.MinguoDate minus(java.time.temporal.TemporalAmount);
    method public java.time.chrono.MinguoDate minus(long, java.time.temporal.TemporalUnit);
    method public static java.time.chrono.MinguoDate now();
    method public static java.time.chrono.MinguoDate now(java.time.ZoneId);
    method public static java.time.chrono.MinguoDate now(java.time.Clock);
    method public static java.time.chrono.MinguoDate of(int, int, int);
    method public java.time.chrono.MinguoDate plus(java.time.temporal.TemporalAmount);
    method public java.time.chrono.MinguoDate plus(long, java.time.temporal.TemporalUnit);
    method public java.time.temporal.ValueRange range(java.time.temporal.TemporalField);
    method public long toEpochDay();
    method public String toString();
    method public java.time.chrono.ChronoPeriod until(java.time.chrono.ChronoLocalDate);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.chrono.MinguoDate with(java.time.temporal.TemporalField, long);
    method public java.time.chrono.MinguoDate with(java.time.temporal.TemporalAdjuster);
  }

  public enum MinguoEra implements java.time.chrono.Era {
    method public int getValue();
    method public static java.time.chrono.MinguoEra of(int);
    enum_constant public static final java.time.chrono.MinguoEra BEFORE_ROC;
    enum_constant public static final java.time.chrono.MinguoEra ROC;
  }

  public final class ThaiBuddhistChronology extends java.time.chrono.AbstractChronology implements java.io.Serializable {
    method public java.time.chrono.ThaiBuddhistDate date(java.time.chrono.Era, int, int, int);
    method public java.time.chrono.ThaiBuddhistDate date(int, int, int);
    method public java.time.chrono.ThaiBuddhistDate date(java.time.temporal.TemporalAccessor);
    method public java.time.chrono.ThaiBuddhistDate dateEpochDay(long);
    method public java.time.chrono.ThaiBuddhistDate dateNow();
    method public java.time.chrono.ThaiBuddhistDate dateNow(java.time.ZoneId);
    method public java.time.chrono.ThaiBuddhistDate dateNow(java.time.Clock);
    method public java.time.chrono.ThaiBuddhistDate dateYearDay(java.time.chrono.Era, int, int);
    method public java.time.chrono.ThaiBuddhistDate dateYearDay(int, int);
    method public java.time.chrono.ThaiBuddhistEra eraOf(int);
    method public java.util.List<java.time.chrono.Era> eras();
    method public String getCalendarType();
    method public String getId();
    method public boolean isLeapYear(long);
    method public java.time.chrono.ChronoLocalDateTime<java.time.chrono.ThaiBuddhistDate> localDateTime(java.time.temporal.TemporalAccessor);
    method public int prolepticYear(java.time.chrono.Era, int);
    method public java.time.temporal.ValueRange range(java.time.temporal.ChronoField);
    method public java.time.chrono.ThaiBuddhistDate resolveDate(java.util.Map<java.time.temporal.TemporalField,java.lang.Long>, java.time.format.ResolverStyle);
    method public java.time.chrono.ChronoZonedDateTime<java.time.chrono.ThaiBuddhistDate> zonedDateTime(java.time.temporal.TemporalAccessor);
    method public java.time.chrono.ChronoZonedDateTime<java.time.chrono.ThaiBuddhistDate> zonedDateTime(java.time.Instant, java.time.ZoneId);
    field public static final java.time.chrono.ThaiBuddhistChronology INSTANCE;
  }

  public final class ThaiBuddhistDate implements java.time.chrono.ChronoLocalDate java.io.Serializable java.time.temporal.Temporal java.time.temporal.TemporalAdjuster {
    method public java.time.chrono.ChronoLocalDateTime<java.time.chrono.ThaiBuddhistDate> atTime(java.time.LocalTime);
    method public static java.time.chrono.ThaiBuddhistDate from(java.time.temporal.TemporalAccessor);
    method public java.time.chrono.ThaiBuddhistChronology getChronology();
    method public java.time.chrono.ThaiBuddhistEra getEra();
    method public long getLong(java.time.temporal.TemporalField);
    method public int lengthOfMonth();
    method public java.time.chrono.ThaiBuddhistDate minus(java.time.temporal.TemporalAmount);
    method public java.time.chrono.ThaiBuddhistDate minus(long, java.time.temporal.TemporalUnit);
    method public static java.time.chrono.ThaiBuddhistDate now();
    method public static java.time.chrono.ThaiBuddhistDate now(java.time.ZoneId);
    method public static java.time.chrono.ThaiBuddhistDate now(java.time.Clock);
    method public static java.time.chrono.ThaiBuddhistDate of(int, int, int);
    method public java.time.chrono.ThaiBuddhistDate plus(java.time.temporal.TemporalAmount);
    method public java.time.chrono.ThaiBuddhistDate plus(long, java.time.temporal.TemporalUnit);
    method public java.time.temporal.ValueRange range(java.time.temporal.TemporalField);
    method public long toEpochDay();
    method public String toString();
    method public java.time.chrono.ChronoPeriod until(java.time.chrono.ChronoLocalDate);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public java.time.chrono.ThaiBuddhistDate with(java.time.temporal.TemporalField, long);
    method public java.time.chrono.ThaiBuddhistDate with(java.time.temporal.TemporalAdjuster);
  }

  public enum ThaiBuddhistEra implements java.time.chrono.Era {
    method public int getValue();
    method public static java.time.chrono.ThaiBuddhistEra of(int);
    enum_constant public static final java.time.chrono.ThaiBuddhistEra BE;
    enum_constant public static final java.time.chrono.ThaiBuddhistEra BEFORE_BE;
  }

}

package java.time.format {

  public final class DateTimeFormatter {
    method public String format(java.time.temporal.TemporalAccessor);
    method public void formatTo(java.time.temporal.TemporalAccessor, Appendable);
    method public java.time.chrono.Chronology getChronology();
    method public java.time.format.DecimalStyle getDecimalStyle();
    method public java.util.Locale getLocale();
    method public java.util.Set<java.time.temporal.TemporalField> getResolverFields();
    method public java.time.format.ResolverStyle getResolverStyle();
    method public java.time.ZoneId getZone();
    method public java.time.format.DateTimeFormatter localizedBy(java.util.Locale);
    method public static java.time.format.DateTimeFormatter ofLocalizedDate(java.time.format.FormatStyle);
    method public static java.time.format.DateTimeFormatter ofLocalizedDateTime(java.time.format.FormatStyle);
    method public static java.time.format.DateTimeFormatter ofLocalizedDateTime(java.time.format.FormatStyle, java.time.format.FormatStyle);
    method public static java.time.format.DateTimeFormatter ofLocalizedTime(java.time.format.FormatStyle);
    method public static java.time.format.DateTimeFormatter ofPattern(String);
    method public static java.time.format.DateTimeFormatter ofPattern(String, java.util.Locale);
    method public java.time.temporal.TemporalAccessor parse(CharSequence);
    method public java.time.temporal.TemporalAccessor parse(CharSequence, java.text.ParsePosition);
    method public <T> T parse(CharSequence, java.time.temporal.TemporalQuery<T>);
    method public java.time.temporal.TemporalAccessor parseBest(CharSequence, java.time.temporal.TemporalQuery<?>...);
    method public java.time.temporal.TemporalAccessor parseUnresolved(CharSequence, java.text.ParsePosition);
    method public static java.time.temporal.TemporalQuery<java.time.Period> parsedExcessDays();
    method public static java.time.temporal.TemporalQuery<java.lang.Boolean> parsedLeapSecond();
    method public java.text.Format toFormat();
    method public java.text.Format toFormat(java.time.temporal.TemporalQuery<?>);
    method public java.time.format.DateTimeFormatter withChronology(java.time.chrono.Chronology);
    method public java.time.format.DateTimeFormatter withDecimalStyle(java.time.format.DecimalStyle);
    method public java.time.format.DateTimeFormatter withLocale(java.util.Locale);
    method public java.time.format.DateTimeFormatter withResolverFields(java.time.temporal.TemporalField...);
    method public java.time.format.DateTimeFormatter withResolverFields(java.util.Set<java.time.temporal.TemporalField>);
    method public java.time.format.DateTimeFormatter withResolverStyle(java.time.format.ResolverStyle);
    method public java.time.format.DateTimeFormatter withZone(java.time.ZoneId);
    field public static final java.time.format.DateTimeFormatter BASIC_ISO_DATE;
    field public static final java.time.format.DateTimeFormatter ISO_DATE;
    field public static final java.time.format.DateTimeFormatter ISO_DATE_TIME;
    field public static final java.time.format.DateTimeFormatter ISO_INSTANT;
    field public static final java.time.format.DateTimeFormatter ISO_LOCAL_DATE;
    field public static final java.time.format.DateTimeFormatter ISO_LOCAL_DATE_TIME;
    field public static final java.time.format.DateTimeFormatter ISO_LOCAL_TIME;
    field public static final java.time.format.DateTimeFormatter ISO_OFFSET_DATE;
    field public static final java.time.format.DateTimeFormatter ISO_OFFSET_DATE_TIME;
    field public static final java.time.format.DateTimeFormatter ISO_OFFSET_TIME;
    field public static final java.time.format.DateTimeFormatter ISO_ORDINAL_DATE;
    field public static final java.time.format.DateTimeFormatter ISO_TIME;
    field public static final java.time.format.DateTimeFormatter ISO_WEEK_DATE;
    field public static final java.time.format.DateTimeFormatter ISO_ZONED_DATE_TIME;
    field public static final java.time.format.DateTimeFormatter RFC_1123_DATE_TIME;
  }

  public final class DateTimeFormatterBuilder {
    ctor public DateTimeFormatterBuilder();
    method public java.time.format.DateTimeFormatterBuilder append(java.time.format.DateTimeFormatter);
    method public java.time.format.DateTimeFormatterBuilder appendChronologyId();
    method public java.time.format.DateTimeFormatterBuilder appendChronologyText(java.time.format.TextStyle);
    method public java.time.format.DateTimeFormatterBuilder appendFraction(java.time.temporal.TemporalField, int, int, boolean);
    method public java.time.format.DateTimeFormatterBuilder appendGenericZoneText(java.time.format.TextStyle);
    method public java.time.format.DateTimeFormatterBuilder appendGenericZoneText(java.time.format.TextStyle, java.util.Set<java.time.ZoneId>);
    method public java.time.format.DateTimeFormatterBuilder appendInstant();
    method public java.time.format.DateTimeFormatterBuilder appendInstant(int);
    method public java.time.format.DateTimeFormatterBuilder appendLiteral(char);
    method public java.time.format.DateTimeFormatterBuilder appendLiteral(String);
    method public java.time.format.DateTimeFormatterBuilder appendLocalized(java.time.format.FormatStyle, java.time.format.FormatStyle);
    method public java.time.format.DateTimeFormatterBuilder appendLocalizedOffset(java.time.format.TextStyle);
    method public java.time.format.DateTimeFormatterBuilder appendOffset(String, String);
    method public java.time.format.DateTimeFormatterBuilder appendOffsetId();
    method public java.time.format.DateTimeFormatterBuilder appendOptional(java.time.format.DateTimeFormatter);
    method public java.time.format.DateTimeFormatterBuilder appendPattern(String);
    method public java.time.format.DateTimeFormatterBuilder appendText(java.time.temporal.TemporalField);
    method public java.time.format.DateTimeFormatterBuilder appendText(java.time.temporal.TemporalField, java.time.format.TextStyle);
    method public java.time.format.DateTimeFormatterBuilder appendText(java.time.temporal.TemporalField, java.util.Map<java.lang.Long,java.lang.String>);
    method public java.time.format.DateTimeFormatterBuilder appendValue(java.time.temporal.TemporalField);
    method public java.time.format.DateTimeFormatterBuilder appendValue(java.time.temporal.TemporalField, int);
    method public java.time.format.DateTimeFormatterBuilder appendValue(java.time.temporal.TemporalField, int, int, java.time.format.SignStyle);
    method public java.time.format.DateTimeFormatterBuilder appendValueReduced(java.time.temporal.TemporalField, int, int, int);
    method public java.time.format.DateTimeFormatterBuilder appendValueReduced(java.time.temporal.TemporalField, int, int, java.time.chrono.ChronoLocalDate);
    method public java.time.format.DateTimeFormatterBuilder appendZoneId();
    method public java.time.format.DateTimeFormatterBuilder appendZoneOrOffsetId();
    method public java.time.format.DateTimeFormatterBuilder appendZoneRegionId();
    method public java.time.format.DateTimeFormatterBuilder appendZoneText(java.time.format.TextStyle);
    method public java.time.format.DateTimeFormatterBuilder appendZoneText(java.time.format.TextStyle, java.util.Set<java.time.ZoneId>);
    method public static String getLocalizedDateTimePattern(java.time.format.FormatStyle, java.time.format.FormatStyle, java.time.chrono.Chronology, java.util.Locale);
    method public java.time.format.DateTimeFormatterBuilder optionalEnd();
    method public java.time.format.DateTimeFormatterBuilder optionalStart();
    method public java.time.format.DateTimeFormatterBuilder padNext(int);
    method public java.time.format.DateTimeFormatterBuilder padNext(int, char);
    method public java.time.format.DateTimeFormatterBuilder parseCaseInsensitive();
    method public java.time.format.DateTimeFormatterBuilder parseCaseSensitive();
    method public java.time.format.DateTimeFormatterBuilder parseDefaulting(java.time.temporal.TemporalField, long);
    method public java.time.format.DateTimeFormatterBuilder parseLenient();
    method public java.time.format.DateTimeFormatterBuilder parseStrict();
    method public java.time.format.DateTimeFormatter toFormatter();
    method public java.time.format.DateTimeFormatter toFormatter(java.util.Locale);
  }

  public class DateTimeParseException extends java.time.DateTimeException {
    ctor public DateTimeParseException(String, CharSequence, int);
    ctor public DateTimeParseException(String, CharSequence, int, Throwable);
    method public int getErrorIndex();
    method public String getParsedString();
  }

  public final class DecimalStyle {
    method public static java.util.Set<java.util.Locale> getAvailableLocales();
    method public char getDecimalSeparator();
    method public char getNegativeSign();
    method public char getPositiveSign();
    method public char getZeroDigit();
    method public static java.time.format.DecimalStyle of(java.util.Locale);
    method public static java.time.format.DecimalStyle ofDefaultLocale();
    method public java.time.format.DecimalStyle withDecimalSeparator(char);
    method public java.time.format.DecimalStyle withNegativeSign(char);
    method public java.time.format.DecimalStyle withPositiveSign(char);
    method public java.time.format.DecimalStyle withZeroDigit(char);
    field public static final java.time.format.DecimalStyle STANDARD;
  }

  public enum FormatStyle {
    enum_constant public static final java.time.format.FormatStyle FULL;
    enum_constant public static final java.time.format.FormatStyle LONG;
    enum_constant public static final java.time.format.FormatStyle MEDIUM;
    enum_constant public static final java.time.format.FormatStyle SHORT;
  }

  public enum ResolverStyle {
    enum_constant public static final java.time.format.ResolverStyle LENIENT;
    enum_constant public static final java.time.format.ResolverStyle SMART;
    enum_constant public static final java.time.format.ResolverStyle STRICT;
  }

  public enum SignStyle {
    enum_constant public static final java.time.format.SignStyle ALWAYS;
    enum_constant public static final java.time.format.SignStyle EXCEEDS_PAD;
    enum_constant public static final java.time.format.SignStyle NEVER;
    enum_constant public static final java.time.format.SignStyle NORMAL;
    enum_constant public static final java.time.format.SignStyle NOT_NEGATIVE;
  }

  public enum TextStyle {
    method public java.time.format.TextStyle asNormal();
    method public java.time.format.TextStyle asStandalone();
    method public boolean isStandalone();
    enum_constant public static final java.time.format.TextStyle FULL;
    enum_constant public static final java.time.format.TextStyle FULL_STANDALONE;
    enum_constant public static final java.time.format.TextStyle NARROW;
    enum_constant public static final java.time.format.TextStyle NARROW_STANDALONE;
    enum_constant public static final java.time.format.TextStyle SHORT;
    enum_constant public static final java.time.format.TextStyle SHORT_STANDALONE;
  }

}

package java.time.temporal {

  public enum ChronoField implements java.time.temporal.TemporalField {
    method public <R extends java.time.temporal.Temporal> R adjustInto(R, long);
    method public int checkValidIntValue(long);
    method public long checkValidValue(long);
    method public java.time.temporal.TemporalUnit getBaseUnit();
    method public long getFrom(java.time.temporal.TemporalAccessor);
    method public java.time.temporal.TemporalUnit getRangeUnit();
    method public boolean isDateBased();
    method public boolean isSupportedBy(java.time.temporal.TemporalAccessor);
    method public boolean isTimeBased();
    method public java.time.temporal.ValueRange range();
    method public java.time.temporal.ValueRange rangeRefinedBy(java.time.temporal.TemporalAccessor);
    enum_constant public static final java.time.temporal.ChronoField ALIGNED_DAY_OF_WEEK_IN_MONTH;
    enum_constant public static final java.time.temporal.ChronoField ALIGNED_DAY_OF_WEEK_IN_YEAR;
    enum_constant public static final java.time.temporal.ChronoField ALIGNED_WEEK_OF_MONTH;
    enum_constant public static final java.time.temporal.ChronoField ALIGNED_WEEK_OF_YEAR;
    enum_constant public static final java.time.temporal.ChronoField AMPM_OF_DAY;
    enum_constant public static final java.time.temporal.ChronoField CLOCK_HOUR_OF_AMPM;
    enum_constant public static final java.time.temporal.ChronoField CLOCK_HOUR_OF_DAY;
    enum_constant public static final java.time.temporal.ChronoField DAY_OF_MONTH;
    enum_constant public static final java.time.temporal.ChronoField DAY_OF_WEEK;
    enum_constant public static final java.time.temporal.ChronoField DAY_OF_YEAR;
    enum_constant public static final java.time.temporal.ChronoField EPOCH_DAY;
    enum_constant public static final java.time.temporal.ChronoField ERA;
    enum_constant public static final java.time.temporal.ChronoField HOUR_OF_AMPM;
    enum_constant public static final java.time.temporal.ChronoField HOUR_OF_DAY;
    enum_constant public static final java.time.temporal.ChronoField INSTANT_SECONDS;
    enum_constant public static final java.time.temporal.ChronoField MICRO_OF_DAY;
    enum_constant public static final java.time.temporal.ChronoField MICRO_OF_SECOND;
    enum_constant public static final java.time.temporal.ChronoField MILLI_OF_DAY;
    enum_constant public static final java.time.temporal.ChronoField MILLI_OF_SECOND;
    enum_constant public static final java.time.temporal.ChronoField MINUTE_OF_DAY;
    enum_constant public static final java.time.temporal.ChronoField MINUTE_OF_HOUR;
    enum_constant public static final java.time.temporal.ChronoField MONTH_OF_YEAR;
    enum_constant public static final java.time.temporal.ChronoField NANO_OF_DAY;
    enum_constant public static final java.time.temporal.ChronoField NANO_OF_SECOND;
    enum_constant public static final java.time.temporal.ChronoField OFFSET_SECONDS;
    enum_constant public static final java.time.temporal.ChronoField PROLEPTIC_MONTH;
    enum_constant public static final java.time.temporal.ChronoField SECOND_OF_DAY;
    enum_constant public static final java.time.temporal.ChronoField SECOND_OF_MINUTE;
    enum_constant public static final java.time.temporal.ChronoField YEAR;
    enum_constant public static final java.time.temporal.ChronoField YEAR_OF_ERA;
  }

  public enum ChronoUnit implements java.time.temporal.TemporalUnit {
    method public <R extends java.time.temporal.Temporal> R addTo(R, long);
    method public long between(java.time.temporal.Temporal, java.time.temporal.Temporal);
    method public java.time.Duration getDuration();
    method public boolean isDateBased();
    method public boolean isDurationEstimated();
    method public boolean isTimeBased();
    enum_constant public static final java.time.temporal.ChronoUnit CENTURIES;
    enum_constant public static final java.time.temporal.ChronoUnit DAYS;
    enum_constant public static final java.time.temporal.ChronoUnit DECADES;
    enum_constant public static final java.time.temporal.ChronoUnit ERAS;
    enum_constant public static final java.time.temporal.ChronoUnit FOREVER;
    enum_constant public static final java.time.temporal.ChronoUnit HALF_DAYS;
    enum_constant public static final java.time.temporal.ChronoUnit HOURS;
    enum_constant public static final java.time.temporal.ChronoUnit MICROS;
    enum_constant public static final java.time.temporal.ChronoUnit MILLENNIA;
    enum_constant public static final java.time.temporal.ChronoUnit MILLIS;
    enum_constant public static final java.time.temporal.ChronoUnit MINUTES;
    enum_constant public static final java.time.temporal.ChronoUnit MONTHS;
    enum_constant public static final java.time.temporal.ChronoUnit NANOS;
    enum_constant public static final java.time.temporal.ChronoUnit SECONDS;
    enum_constant public static final java.time.temporal.ChronoUnit WEEKS;
    enum_constant public static final java.time.temporal.ChronoUnit YEARS;
  }

  public final class IsoFields {
    field public static final java.time.temporal.TemporalField DAY_OF_QUARTER;
    field public static final java.time.temporal.TemporalField QUARTER_OF_YEAR;
    field public static final java.time.temporal.TemporalUnit QUARTER_YEARS;
    field public static final java.time.temporal.TemporalField WEEK_BASED_YEAR;
    field public static final java.time.temporal.TemporalUnit WEEK_BASED_YEARS;
    field public static final java.time.temporal.TemporalField WEEK_OF_WEEK_BASED_YEAR;
  }

  public final class JulianFields {
    field public static final java.time.temporal.TemporalField JULIAN_DAY;
    field public static final java.time.temporal.TemporalField MODIFIED_JULIAN_DAY;
    field public static final java.time.temporal.TemporalField RATA_DIE;
  }

  public interface Temporal extends java.time.temporal.TemporalAccessor {
    method public boolean isSupported(java.time.temporal.TemporalUnit);
    method public default java.time.temporal.Temporal minus(java.time.temporal.TemporalAmount);
    method public default java.time.temporal.Temporal minus(long, java.time.temporal.TemporalUnit);
    method public default java.time.temporal.Temporal plus(java.time.temporal.TemporalAmount);
    method public java.time.temporal.Temporal plus(long, java.time.temporal.TemporalUnit);
    method public long until(java.time.temporal.Temporal, java.time.temporal.TemporalUnit);
    method public default java.time.temporal.Temporal with(java.time.temporal.TemporalAdjuster);
    method public java.time.temporal.Temporal with(java.time.temporal.TemporalField, long);
  }

  public interface TemporalAccessor {
    method public default int get(java.time.temporal.TemporalField);
    method public long getLong(java.time.temporal.TemporalField);
    method public boolean isSupported(java.time.temporal.TemporalField);
    method public default <R> R query(java.time.temporal.TemporalQuery<R>);
    method public default java.time.temporal.ValueRange range(java.time.temporal.TemporalField);
  }

  @java.lang.FunctionalInterface public interface TemporalAdjuster {
    method public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal);
  }

  public final class TemporalAdjusters {
    method public static java.time.temporal.TemporalAdjuster dayOfWeekInMonth(int, java.time.DayOfWeek);
    method public static java.time.temporal.TemporalAdjuster firstDayOfMonth();
    method public static java.time.temporal.TemporalAdjuster firstDayOfNextMonth();
    method public static java.time.temporal.TemporalAdjuster firstDayOfNextYear();
    method public static java.time.temporal.TemporalAdjuster firstDayOfYear();
    method public static java.time.temporal.TemporalAdjuster firstInMonth(java.time.DayOfWeek);
    method public static java.time.temporal.TemporalAdjuster lastDayOfMonth();
    method public static java.time.temporal.TemporalAdjuster lastDayOfYear();
    method public static java.time.temporal.TemporalAdjuster lastInMonth(java.time.DayOfWeek);
    method public static java.time.temporal.TemporalAdjuster next(java.time.DayOfWeek);
    method public static java.time.temporal.TemporalAdjuster nextOrSame(java.time.DayOfWeek);
    method public static java.time.temporal.TemporalAdjuster ofDateAdjuster(java.util.function.UnaryOperator<java.time.LocalDate>);
    method public static java.time.temporal.TemporalAdjuster previous(java.time.DayOfWeek);
    method public static java.time.temporal.TemporalAdjuster previousOrSame(java.time.DayOfWeek);
  }

  public interface TemporalAmount {
    method public java.time.temporal.Temporal addTo(java.time.temporal.Temporal);
    method public long get(java.time.temporal.TemporalUnit);
    method public java.util.List<java.time.temporal.TemporalUnit> getUnits();
    method public java.time.temporal.Temporal subtractFrom(java.time.temporal.Temporal);
  }

  public interface TemporalField {
    method public <R extends java.time.temporal.Temporal> R adjustInto(R, long);
    method public java.time.temporal.TemporalUnit getBaseUnit();
    method public default String getDisplayName(java.util.Locale);
    method public long getFrom(java.time.temporal.TemporalAccessor);
    method public java.time.temporal.TemporalUnit getRangeUnit();
    method public boolean isDateBased();
    method public boolean isSupportedBy(java.time.temporal.TemporalAccessor);
    method public boolean isTimeBased();
    method public java.time.temporal.ValueRange range();
    method public java.time.temporal.ValueRange rangeRefinedBy(java.time.temporal.TemporalAccessor);
    method public default java.time.temporal.TemporalAccessor resolve(java.util.Map<java.time.temporal.TemporalField,java.lang.Long>, java.time.temporal.TemporalAccessor, java.time.format.ResolverStyle);
    method public String toString();
  }

  public final class TemporalQueries {
    method public static java.time.temporal.TemporalQuery<java.time.chrono.Chronology> chronology();
    method public static java.time.temporal.TemporalQuery<java.time.LocalDate> localDate();
    method public static java.time.temporal.TemporalQuery<java.time.LocalTime> localTime();
    method public static java.time.temporal.TemporalQuery<java.time.ZoneOffset> offset();
    method public static java.time.temporal.TemporalQuery<java.time.temporal.TemporalUnit> precision();
    method public static java.time.temporal.TemporalQuery<java.time.ZoneId> zone();
    method public static java.time.temporal.TemporalQuery<java.time.ZoneId> zoneId();
  }

  @java.lang.FunctionalInterface public interface TemporalQuery<R> {
    method public R queryFrom(java.time.temporal.TemporalAccessor);
  }

  public interface TemporalUnit {
    method public <R extends java.time.temporal.Temporal> R addTo(R, long);
    method public long between(java.time.temporal.Temporal, java.time.temporal.Temporal);
    method public java.time.Duration getDuration();
    method public boolean isDateBased();
    method public boolean isDurationEstimated();
    method public default boolean isSupportedBy(java.time.temporal.Temporal);
    method public boolean isTimeBased();
    method public String toString();
  }

  public class UnsupportedTemporalTypeException extends java.time.DateTimeException {
    ctor public UnsupportedTemporalTypeException(String);
    ctor public UnsupportedTemporalTypeException(String, Throwable);
  }

  public final class ValueRange implements java.io.Serializable {
    method public int checkValidIntValue(long, java.time.temporal.TemporalField);
    method public long checkValidValue(long, java.time.temporal.TemporalField);
    method public long getLargestMinimum();
    method public long getMaximum();
    method public long getMinimum();
    method public long getSmallestMaximum();
    method public boolean isFixed();
    method public boolean isIntValue();
    method public boolean isValidIntValue(long);
    method public boolean isValidValue(long);
    method public static java.time.temporal.ValueRange of(long, long);
    method public static java.time.temporal.ValueRange of(long, long, long);
    method public static java.time.temporal.ValueRange of(long, long, long, long);
  }

  public final class WeekFields implements java.io.Serializable {
    method public java.time.temporal.TemporalField dayOfWeek();
    method public java.time.DayOfWeek getFirstDayOfWeek();
    method public int getMinimalDaysInFirstWeek();
    method public static java.time.temporal.WeekFields of(java.util.Locale);
    method public static java.time.temporal.WeekFields of(java.time.DayOfWeek, int);
    method public java.time.temporal.TemporalField weekBasedYear();
    method public java.time.temporal.TemporalField weekOfMonth();
    method public java.time.temporal.TemporalField weekOfWeekBasedYear();
    method public java.time.temporal.TemporalField weekOfYear();
    field public static final java.time.temporal.WeekFields ISO;
    field public static final java.time.temporal.WeekFields SUNDAY_START;
    field public static final java.time.temporal.TemporalUnit WEEK_BASED_YEARS;
  }

}

package java.time.zone {

  public final class ZoneOffsetTransition implements java.lang.Comparable<java.time.zone.ZoneOffsetTransition> java.io.Serializable {
    method public int compareTo(java.time.zone.ZoneOffsetTransition);
    method public java.time.LocalDateTime getDateTimeAfter();
    method public java.time.LocalDateTime getDateTimeBefore();
    method public java.time.Duration getDuration();
    method public java.time.Instant getInstant();
    method public java.time.ZoneOffset getOffsetAfter();
    method public java.time.ZoneOffset getOffsetBefore();
    method public boolean isGap();
    method public boolean isOverlap();
    method public boolean isValidOffset(java.time.ZoneOffset);
    method public static java.time.zone.ZoneOffsetTransition of(java.time.LocalDateTime, java.time.ZoneOffset, java.time.ZoneOffset);
    method public long toEpochSecond();
  }

  public final class ZoneOffsetTransitionRule implements java.io.Serializable {
    method public java.time.zone.ZoneOffsetTransition createTransition(int);
    method public int getDayOfMonthIndicator();
    method public java.time.DayOfWeek getDayOfWeek();
    method public java.time.LocalTime getLocalTime();
    method public java.time.Month getMonth();
    method public java.time.ZoneOffset getOffsetAfter();
    method public java.time.ZoneOffset getOffsetBefore();
    method public java.time.ZoneOffset getStandardOffset();
    method public java.time.zone.ZoneOffsetTransitionRule.TimeDefinition getTimeDefinition();
    method public boolean isMidnightEndOfDay();
    method public static java.time.zone.ZoneOffsetTransitionRule of(java.time.Month, int, java.time.DayOfWeek, java.time.LocalTime, boolean, java.time.zone.ZoneOffsetTransitionRule.TimeDefinition, java.time.ZoneOffset, java.time.ZoneOffset, java.time.ZoneOffset);
  }

  public enum ZoneOffsetTransitionRule.TimeDefinition {
    method public java.time.LocalDateTime createDateTime(java.time.LocalDateTime, java.time.ZoneOffset, java.time.ZoneOffset);
    enum_constant public static final java.time.zone.ZoneOffsetTransitionRule.TimeDefinition STANDARD;
    enum_constant public static final java.time.zone.ZoneOffsetTransitionRule.TimeDefinition UTC;
    enum_constant public static final java.time.zone.ZoneOffsetTransitionRule.TimeDefinition WALL;
  }

  public final class ZoneRules implements java.io.Serializable {
    method public java.time.Duration getDaylightSavings(java.time.Instant);
    method public java.time.ZoneOffset getOffset(java.time.Instant);
    method public java.time.ZoneOffset getOffset(java.time.LocalDateTime);
    method public java.time.ZoneOffset getStandardOffset(java.time.Instant);
    method public java.time.zone.ZoneOffsetTransition getTransition(java.time.LocalDateTime);
    method public java.util.List<java.time.zone.ZoneOffsetTransitionRule> getTransitionRules();
    method public java.util.List<java.time.zone.ZoneOffsetTransition> getTransitions();
    method public java.util.List<java.time.ZoneOffset> getValidOffsets(java.time.LocalDateTime);
    method public boolean isDaylightSavings(java.time.Instant);
    method public boolean isFixedOffset();
    method public boolean isValidOffset(java.time.LocalDateTime, java.time.ZoneOffset);
    method public java.time.zone.ZoneOffsetTransition nextTransition(java.time.Instant);
    method public static java.time.zone.ZoneRules of(java.time.ZoneOffset, java.time.ZoneOffset, java.util.List<java.time.zone.ZoneOffsetTransition>, java.util.List<java.time.zone.ZoneOffsetTransition>, java.util.List<java.time.zone.ZoneOffsetTransitionRule>);
    method public static java.time.zone.ZoneRules of(java.time.ZoneOffset);
    method public java.time.zone.ZoneOffsetTransition previousTransition(java.time.Instant);
  }

  public class ZoneRulesException extends java.time.DateTimeException {
    ctor public ZoneRulesException(String);
    ctor public ZoneRulesException(String, Throwable);
  }

}

package java.util {

  public abstract class AbstractCollection<E> implements java.util.Collection<E> {
    ctor protected AbstractCollection();
    method public boolean add(E);
    method public boolean addAll(@NonNull java.util.Collection<? extends E>);
    method public void clear();
    method public boolean contains(@Nullable Object);
    method public boolean containsAll(@NonNull java.util.Collection<?>);
    method public boolean isEmpty();
    method public boolean remove(@Nullable Object);
    method public boolean removeAll(@NonNull java.util.Collection<?>);
    method public boolean retainAll(@NonNull java.util.Collection<?>);
    method @NonNull public Object[] toArray();
    method @NonNull public <T> T[] toArray(@NonNull T[]);
  }

  public abstract class AbstractList<E> extends java.util.AbstractCollection<E> implements java.util.List<E> {
    ctor protected AbstractList();
    method public void add(int, E);
    method public boolean addAll(int, @NonNull java.util.Collection<? extends E>);
    method public boolean equals(@Nullable Object);
    method public int hashCode();
    method public int indexOf(@Nullable Object);
    method @NonNull public java.util.Iterator<E> iterator();
    method public int lastIndexOf(@Nullable Object);
    method @NonNull public java.util.ListIterator<E> listIterator();
    method @NonNull public java.util.ListIterator<E> listIterator(int);
    method public E remove(int);
    method protected void removeRange(int, int);
    method public E set(int, E);
    method @NonNull public java.util.List<E> subList(int, int);
    field protected transient int modCount;
  }

  public abstract class AbstractMap<K, V> implements java.util.Map<K,V> {
    ctor protected AbstractMap();
    method public void clear();
    method public boolean containsKey(@Nullable Object);
    method public boolean containsValue(@Nullable Object);
    method public boolean equals(@Nullable Object);
    method @Nullable public V get(@Nullable Object);
    method public int hashCode();
    method public boolean isEmpty();
    method @NonNull public java.util.Set<K> keySet();
    method @Nullable public V put(K, V);
    method public void putAll(@NonNull java.util.Map<? extends K,? extends V>);
    method @Nullable public V remove(@Nullable Object);
    method public int size();
    method @NonNull public java.util.Collection<V> values();
  }

  public static class AbstractMap.SimpleEntry<K, V> implements java.util.Map.Entry<K,V> java.io.Serializable {
    ctor public AbstractMap.SimpleEntry(K, V);
    ctor public AbstractMap.SimpleEntry(@NonNull java.util.Map.Entry<? extends K,? extends V>);
    method public boolean equals(@Nullable Object);
    method public K getKey();
    method public V getValue();
    method public int hashCode();
    method public V setValue(V);
  }

  public static class AbstractMap.SimpleImmutableEntry<K, V> implements java.util.Map.Entry<K,V> java.io.Serializable {
    ctor public AbstractMap.SimpleImmutableEntry(K, V);
    ctor public AbstractMap.SimpleImmutableEntry(@NonNull java.util.Map.Entry<? extends K,? extends V>);
    method public boolean equals(@Nullable Object);
    method public K getKey();
    method public V getValue();
    method public int hashCode();
    method public V setValue(V);
  }

  public abstract class AbstractQueue<E> extends java.util.AbstractCollection<E> implements java.util.Queue<E> {
    ctor protected AbstractQueue();
    method public E element();
    method public E remove();
  }

  public abstract class AbstractSequentialList<E> extends java.util.AbstractList<E> {
    ctor protected AbstractSequentialList();
    method public E get(int);
  }

  public abstract class AbstractSet<E> extends java.util.AbstractCollection<E> implements java.util.Set<E> {
    ctor protected AbstractSet();
    method public boolean equals(@Nullable Object);
    method public int hashCode();
  }

  public class ArrayDeque<E> extends java.util.AbstractCollection<E> implements java.lang.Cloneable java.util.Deque<E> java.io.Serializable {
    ctor public ArrayDeque();
    ctor public ArrayDeque(int);
    ctor public ArrayDeque(@NonNull java.util.Collection<? extends E>);
    method public void addFirst(E);
    method public void addLast(E);
    method @NonNull public java.util.ArrayDeque<E> clone();
    method @NonNull public java.util.Iterator<E> descendingIterator();
    method public E element();
    method public void forEach(@NonNull java.util.function.Consumer<? super E>);
    method public E getFirst();
    method public E getLast();
    method @NonNull public java.util.Iterator<E> iterator();
    method public boolean offer(E);
    method public boolean offerFirst(E);
    method public boolean offerLast(E);
    method @Nullable public E peek();
    method @Nullable public E peekFirst();
    method @Nullable public E peekLast();
    method @Nullable public E poll();
    method @Nullable public E pollFirst();
    method @Nullable public E pollLast();
    method public E pop();
    method public void push(E);
    method public E remove();
    method public E removeFirst();
    method public boolean removeFirstOccurrence(@Nullable Object);
    method public boolean removeIf(@NonNull java.util.function.Predicate<? super E>);
    method public E removeLast();
    method public boolean removeLastOccurrence(@Nullable Object);
    method public int size();
    method @NonNull public java.util.Spliterator<E> spliterator();
  }

  public class ArrayList<E> extends java.util.AbstractList<E> implements java.lang.Cloneable java.util.List<E> java.util.RandomAccess java.io.Serializable {
    ctor public ArrayList(int);
    ctor public ArrayList();
    ctor public ArrayList(@NonNull java.util.Collection<? extends E>);
    method @NonNull public Object clone();
    method public void ensureCapacity(int);
    method public void forEach(@NonNull java.util.function.Consumer<? super E>);
    method public E get(int);
    method public boolean removeIf(@NonNull java.util.function.Predicate<? super E>);
    method public void replaceAll(@NonNull java.util.function.UnaryOperator<E>);
    method public int size();
    method public void sort(@Nullable java.util.Comparator<? super E>);
    method @NonNull public java.util.Spliterator<E> spliterator();
    method public void trimToSize();
  }

  public class Arrays {
    method @NonNull @java.lang.SafeVarargs public static <T> java.util.List<T> asList(@NonNull T...);
    method public static int binarySearch(@NonNull long[], long);
    method public static int binarySearch(@NonNull long[], int, int, long);
    method public static int binarySearch(@NonNull int[], int);
    method public static int binarySearch(@NonNull int[], int, int, int);
    method public static int binarySearch(@NonNull short[], short);
    method public static int binarySearch(@NonNull short[], int, int, short);
    method public static int binarySearch(@NonNull char[], char);
    method public static int binarySearch(@NonNull char[], int, int, char);
    method public static int binarySearch(@NonNull byte[], byte);
    method public static int binarySearch(@NonNull byte[], int, int, byte);
    method public static int binarySearch(@NonNull double[], double);
    method public static int binarySearch(@NonNull double[], int, int, double);
    method public static int binarySearch(@NonNull float[], float);
    method public static int binarySearch(@NonNull float[], int, int, float);
    method public static int binarySearch(@NonNull Object[], @NonNull Object);
    method public static int binarySearch(@NonNull Object[], int, int, @NonNull Object);
    method public static <T> int binarySearch(@NonNull T[], T, @Nullable java.util.Comparator<? super T>);
    method public static <T> int binarySearch(@NonNull T[], int, int, T, @Nullable java.util.Comparator<? super T>);
    method public static int compare(@Nullable boolean[], @Nullable boolean[]);
    method public static int compare(@NonNull boolean[], int, int, @NonNull boolean[], int, int);
    method public static int compare(@Nullable byte[], @Nullable byte[]);
    method public static int compare(@NonNull byte[], int, int, @NonNull byte[], int, int);
    method public static int compare(@Nullable short[], @Nullable short[]);
    method public static int compare(@NonNull short[], int, int, @NonNull short[], int, int);
    method public static int compare(@Nullable char[], @Nullable char[]);
    method public static int compare(@NonNull char[], int, int, @NonNull char[], int, int);
    method public static int compare(@Nullable int[], @Nullable int[]);
    method public static int compare(@NonNull int[], int, int, @NonNull int[], int, int);
    method public static int compare(@Nullable long[], @Nullable long[]);
    method public static int compare(@NonNull long[], int, int, @NonNull long[], int, int);
    method public static int compare(@Nullable float[], @Nullable float[]);
    method public static int compare(@NonNull float[], int, int, @NonNull float[], int, int);
    method public static int compare(@Nullable double[], @Nullable double[]);
    method public static int compare(@NonNull double[], int, int, @NonNull double[], int, int);
    method public static <T extends java.lang.Comparable<? super T>> int compare(@Nullable T[], @Nullable T[]);
    method public static <T extends java.lang.Comparable<? super T>> int compare(@NonNull T[], int, int, @NonNull T[], int, int);
    method public static <T> int compare(@Nullable T[], @Nullable T[], @NonNull java.util.Comparator<? super T>);
    method public static <T> int compare(@NonNull T[], int, int, @NonNull T[], int, int, @NonNull java.util.Comparator<? super T>);
    method public static int compareUnsigned(@Nullable byte[], @Nullable byte[]);
    method public static int compareUnsigned(@NonNull byte[], int, int, @NonNull byte[], int, int);
    method public static int compareUnsigned(@Nullable short[], @Nullable short[]);
    method public static int compareUnsigned(@NonNull short[], int, int, @NonNull short[], int, int);
    method public static int compareUnsigned(@Nullable int[], @Nullable int[]);
    method public static int compareUnsigned(@NonNull int[], int, int, @NonNull int[], int, int);
    method public static int compareUnsigned(@Nullable long[], @Nullable long[]);
    method public static int compareUnsigned(@NonNull long[], int, int, @NonNull long[], int, int);
    method @NonNull public static <T> T[] copyOf(@NonNull T[], int);
    method @NonNull public static <T, U> T[] copyOf(@NonNull U[], int, @NonNull Class<? extends T[]>);
    method @NonNull public static byte[] copyOf(@NonNull byte[], int);
    method @NonNull public static short[] copyOf(@NonNull short[], int);
    method @NonNull public static int[] copyOf(@NonNull int[], int);
    method @NonNull public static long[] copyOf(@NonNull long[], int);
    method @NonNull public static char[] copyOf(@NonNull char[], int);
    method @NonNull public static float[] copyOf(@NonNull float[], int);
    method @NonNull public static double[] copyOf(@NonNull double[], int);
    method @NonNull public static boolean[] copyOf(@NonNull boolean[], int);
    method @NonNull public static <T> T[] copyOfRange(@NonNull T[], int, int);
    method @NonNull public static <T, U> T[] copyOfRange(@NonNull U[], int, int, @NonNull Class<? extends T[]>);
    method @NonNull public static byte[] copyOfRange(@NonNull byte[], int, int);
    method @NonNull public static short[] copyOfRange(@NonNull short[], int, int);
    method @NonNull public static int[] copyOfRange(@NonNull int[], int, int);
    method @NonNull public static long[] copyOfRange(@NonNull long[], int, int);
    method @NonNull public static char[] copyOfRange(@NonNull char[], int, int);
    method @NonNull public static float[] copyOfRange(@NonNull float[], int, int);
    method @NonNull public static double[] copyOfRange(@NonNull double[], int, int);
    method @NonNull public static boolean[] copyOfRange(@NonNull boolean[], int, int);
    method public static boolean deepEquals(@Nullable Object[], @Nullable Object[]);
    method public static int deepHashCode(@Nullable Object[]);
    method @NonNull public static String deepToString(@Nullable Object[]);
    method public static boolean equals(@Nullable long[], @Nullable long[]);
    method public static boolean equals(@NonNull long[], int, int, @NonNull long[], int, int);
    method public static boolean equals(@Nullable int[], @Nullable int[]);
    method public static boolean equals(@NonNull int[], int, int, @NonNull int[], int, int);
    method public static boolean equals(@Nullable short[], @Nullable short[]);
    method public static boolean equals(@NonNull short[], int, int, @NonNull short[], int, int);
    method public static boolean equals(@Nullable char[], @Nullable char[]);
    method public static boolean equals(@NonNull char[], int, int, @NonNull char[], int, int);
    method public static boolean equals(@Nullable byte[], @Nullable byte[]);
    method public static boolean equals(@NonNull byte[], int, int, @NonNull byte[], int, int);
    method public static boolean equals(@Nullable boolean[], @Nullable boolean[]);
    method public static boolean equals(@NonNull boolean[], int, int, @NonNull boolean[], int, int);
    method public static boolean equals(@Nullable double[], @Nullable double[]);
    method public static boolean equals(@NonNull double[], int, int, @NonNull double[], int, int);
    method public static boolean equals(@Nullable float[], @Nullable float[]);
    method public static boolean equals(@NonNull float[], int, int, @NonNull float[], int, int);
    method public static boolean equals(@Nullable Object[], @Nullable Object[]);
    method public static boolean equals(@NonNull Object[], int, int, @NonNull Object[], int, int);
    method public static <T> boolean equals(@Nullable T[], @Nullable T[], @NonNull java.util.Comparator<? super T>);
    method public static <T> boolean equals(@NonNull T[], int, int, @NonNull T[], int, int, @NonNull java.util.Comparator<? super T>);
    method public static void fill(@NonNull long[], long);
    method public static void fill(@NonNull long[], int, int, long);
    method public static void fill(@NonNull int[], int);
    method public static void fill(@NonNull int[], int, int, int);
    method public static void fill(@NonNull short[], short);
    method public static void fill(@NonNull short[], int, int, short);
    method public static void fill(@NonNull char[], char);
    method public static void fill(@NonNull char[], int, int, char);
    method public static void fill(@NonNull byte[], byte);
    method public static void fill(@NonNull byte[], int, int, byte);
    method public static void fill(@NonNull boolean[], boolean);
    method public static void fill(@NonNull boolean[], int, int, boolean);
    method public static void fill(@NonNull double[], double);
    method public static void fill(@NonNull double[], int, int, double);
    method public static void fill(@NonNull float[], float);
    method public static void fill(@NonNull float[], int, int, float);
    method public static void fill(@NonNull Object[], @Nullable Object);
    method public static void fill(@NonNull Object[], int, int, @Nullable Object);
    method public static int hashCode(@Nullable long[]);
    method public static int hashCode(@Nullable int[]);
    method public static int hashCode(@Nullable short[]);
    method public static int hashCode(@Nullable char[]);
    method public static int hashCode(@Nullable byte[]);
    method public static int hashCode(@Nullable boolean[]);
    method public static int hashCode(@Nullable float[]);
    method public static int hashCode(@Nullable double[]);
    method public static int hashCode(@Nullable Object[]);
    method public static int mismatch(@NonNull boolean[], @NonNull boolean[]);
    method public static int mismatch(@NonNull boolean[], int, int, @NonNull boolean[], int, int);
    method public static int mismatch(@NonNull byte[], @NonNull byte[]);
    method public static int mismatch(byte[], int, int, byte[], int, int);
    method public static int mismatch(@NonNull char[], @NonNull char[]);
    method public static int mismatch(@NonNull char[], int, int, @NonNull char[], int, int);
    method public static int mismatch(@NonNull short[], @NonNull short[]);
    method public static int mismatch(@NonNull short[], int, int, @NonNull short[], int, int);
    method public static int mismatch(@NonNull int[], @NonNull int[]);
    method public static int mismatch(@NonNull int[], int, int, @NonNull int[], int, int);
    method public static int mismatch(@NonNull long[], @NonNull long[]);
    method public static int mismatch(@NonNull long[], int, int, @NonNull long[], int, int);
    method public static int mismatch(@NonNull float[], @NonNull float[]);
    method public static int mismatch(@NonNull float[], int, int, @NonNull float[], int, int);
    method public static int mismatch(@NonNull double[], @NonNull double[]);
    method public static int mismatch(@NonNull double[], int, int, @NonNull double[], int, int);
    method public static int mismatch(@NonNull Object[], @NonNull Object[]);
    method public static int mismatch(@NonNull Object[], int, int, @NonNull Object[], int, int);
    method public static <T> int mismatch(@NonNull T[], @NonNull T[], @NonNull java.util.Comparator<? super T>);
    method public static <T> int mismatch(@NonNull T[], int, int, @NonNull T[], int, int, @NonNull java.util.Comparator<? super T>);
    method public static <T> void parallelPrefix(@NonNull T[], @NonNull java.util.function.BinaryOperator<T>);
    method public static <T> void parallelPrefix(@NonNull T[], int, int, @NonNull java.util.function.BinaryOperator<T>);
    method public static void parallelPrefix(@NonNull long[], @NonNull java.util.function.LongBinaryOperator);
    method public static void parallelPrefix(@NonNull long[], int, int, @NonNull java.util.function.LongBinaryOperator);
    method public static void parallelPrefix(@NonNull double[], @NonNull java.util.function.DoubleBinaryOperator);
    method public static void parallelPrefix(@NonNull double[], int, int, @NonNull java.util.function.DoubleBinaryOperator);
    method public static void parallelPrefix(@NonNull int[], @NonNull java.util.function.IntBinaryOperator);
    method public static void parallelPrefix(@NonNull int[], int, int, @NonNull java.util.function.IntBinaryOperator);
    method public static <T> void parallelSetAll(@NonNull T[], @NonNull java.util.function.IntFunction<? extends T>);
    method public static void parallelSetAll(@NonNull int[], @NonNull java.util.function.IntUnaryOperator);
    method public static void parallelSetAll(@NonNull long[], @NonNull java.util.function.IntToLongFunction);
    method public static void parallelSetAll(@NonNull double[], @NonNull java.util.function.IntToDoubleFunction);
    method public static void parallelSort(@NonNull byte[]);
    method public static void parallelSort(@NonNull byte[], int, int);
    method public static void parallelSort(@NonNull char[]);
    method public static void parallelSort(@NonNull char[], int, int);
    method public static void parallelSort(@NonNull short[]);
    method public static void parallelSort(@NonNull short[], int, int);
    method public static void parallelSort(@NonNull int[]);
    method public static void parallelSort(@NonNull int[], int, int);
    method public static void parallelSort(@NonNull long[]);
    method public static void parallelSort(@NonNull long[], int, int);
    method public static void parallelSort(@NonNull float[]);
    method public static void parallelSort(@NonNull float[], int, int);
    method public static void parallelSort(@NonNull double[]);
    method public static void parallelSort(@NonNull double[], int, int);
    method public static <T extends java.lang.Comparable<? super T>> void parallelSort(@NonNull T[]);
    method public static <T extends java.lang.Comparable<? super T>> void parallelSort(@NonNull T[], int, int);
    method public static <T> void parallelSort(@NonNull T[], @Nullable java.util.Comparator<? super T>);
    method public static <T> void parallelSort(@NonNull T[], int, int, @Nullable java.util.Comparator<? super T>);
    method public static <T> void setAll(@NonNull T[], @NonNull java.util.function.IntFunction<? extends T>);
    method public static void setAll(@NonNull int[], @NonNull java.util.function.IntUnaryOperator);
    method public static void setAll(@NonNull long[], @NonNull java.util.function.IntToLongFunction);
    method public static void setAll(@NonNull double[], @NonNull java.util.function.IntToDoubleFunction);
    method public static void sort(@NonNull int[]);
    method public static void sort(@NonNull int[], int, int);
    method public static void sort(@NonNull long[]);
    method public static void sort(@NonNull long[], int, int);
    method public static void sort(@NonNull short[]);
    method public static void sort(@NonNull short[], int, int);
    method public static void sort(@NonNull char[]);
    method public static void sort(@NonNull char[], int, int);
    method public static void sort(@NonNull byte[]);
    method public static void sort(@NonNull byte[], int, int);
    method public static void sort(@NonNull float[]);
    method public static void sort(@NonNull float[], int, int);
    method public static void sort(@NonNull double[]);
    method public static void sort(@NonNull double[], int, int);
    method public static void sort(@NonNull Object[]);
    method public static void sort(@NonNull Object[], int, int);
    method public static <T> void sort(@NonNull T[], @Nullable java.util.Comparator<? super T>);
    method public static <T> void sort(@NonNull T[], int, int, @Nullable java.util.Comparator<? super T>);
    method @NonNull public static <T> java.util.Spliterator<T> spliterator(@NonNull T[]);
    method @NonNull public static <T> java.util.Spliterator<T> spliterator(@NonNull T[], int, int);
    method @NonNull public static java.util.Spliterator.OfInt spliterator(@NonNull int[]);
    method @NonNull public static java.util.Spliterator.OfInt spliterator(@NonNull int[], int, int);
    method @NonNull public static java.util.Spliterator.OfLong spliterator(@NonNull long[]);
    method @NonNull public static java.util.Spliterator.OfLong spliterator(@NonNull long[], int, int);
    method @NonNull public static java.util.Spliterator.OfDouble spliterator(@NonNull double[]);
    method @NonNull public static java.util.Spliterator.OfDouble spliterator(@NonNull double[], int, int);
    method @NonNull public static <T> java.util.stream.Stream<T> stream(@NonNull T[]);
    method @NonNull public static <T> java.util.stream.Stream<T> stream(@NonNull T[], int, int);
    method @NonNull public static java.util.stream.IntStream stream(@NonNull int[]);
    method @NonNull public static java.util.stream.IntStream stream(@NonNull int[], int, int);
    method @NonNull public static java.util.stream.LongStream stream(@NonNull long[]);
    method @NonNull public static java.util.stream.LongStream stream(@NonNull long[], int, int);
    method @NonNull public static java.util.stream.DoubleStream stream(@NonNull double[]);
    method @NonNull public static java.util.stream.DoubleStream stream(@NonNull double[], int, int);
    method @NonNull public static String toString(@Nullable long[]);
    method @NonNull public static String toString(@Nullable int[]);
    method @NonNull public static String toString(@Nullable short[]);
    method @NonNull public static String toString(@Nullable char[]);
    method @NonNull public static String toString(@Nullable byte[]);
    method @NonNull public static String toString(@Nullable boolean[]);
    method @NonNull public static String toString(@Nullable float[]);
    method @NonNull public static String toString(@Nullable double[]);
    method @NonNull public static String toString(@Nullable Object[]);
  }

  public class Base64 {
    method public static java.util.Base64.Decoder getDecoder();
    method public static java.util.Base64.Encoder getEncoder();
    method public static java.util.Base64.Decoder getMimeDecoder();
    method public static java.util.Base64.Encoder getMimeEncoder();
    method public static java.util.Base64.Encoder getMimeEncoder(int, byte[]);
    method public static java.util.Base64.Decoder getUrlDecoder();
    method public static java.util.Base64.Encoder getUrlEncoder();
  }

  public static class Base64.Decoder {
    method public byte[] decode(byte[]);
    method public byte[] decode(String);
    method public int decode(byte[], byte[]);
    method public java.nio.ByteBuffer decode(java.nio.ByteBuffer);
    method public java.io.InputStream wrap(java.io.InputStream);
  }

  public static class Base64.Encoder {
    method public byte[] encode(byte[]);
    method public int encode(byte[], byte[]);
    method public java.nio.ByteBuffer encode(java.nio.ByteBuffer);
    method public String encodeToString(byte[]);
    method public java.util.Base64.Encoder withoutPadding();
    method public java.io.OutputStream wrap(java.io.OutputStream);
  }

  public class BitSet implements java.lang.Cloneable java.io.Serializable {
    ctor public BitSet();
    ctor public BitSet(int);
    method public void and(java.util.BitSet);
    method public void andNot(java.util.BitSet);
    method public int cardinality();
    method public void clear(int);
    method public void clear(int, int);
    method public void clear();
    method public Object clone();
    method public void flip(int);
    method public void flip(int, int);
    method public boolean get(int);
    method public java.util.BitSet get(int, int);
    method public boolean intersects(java.util.BitSet);
    method public boolean isEmpty();
    method public int length();
    method public int nextClearBit(int);
    method public int nextSetBit(int);
    method public void or(java.util.BitSet);
    method public int previousClearBit(int);
    method public int previousSetBit(int);
    method public void set(int);
    method public void set(int, boolean);
    method public void set(int, int);
    method public void set(int, int, boolean);
    method public int size();
    method public java.util.stream.IntStream stream();
    method public byte[] toByteArray();
    method public long[] toLongArray();
    method public static java.util.BitSet valueOf(long[]);
    method public static java.util.BitSet valueOf(java.nio.LongBuffer);
    method public static java.util.BitSet valueOf(byte[]);
    method public static java.util.BitSet valueOf(java.nio.ByteBuffer);
    method public void xor(java.util.BitSet);
  }

  public abstract class Calendar implements java.lang.Cloneable java.lang.Comparable<java.util.Calendar> java.io.Serializable {
    ctor protected Calendar();
    ctor protected Calendar(@NonNull java.util.TimeZone, @NonNull java.util.Locale);
    method public abstract void add(int, int);
    method public boolean after(@Nullable Object);
    method public boolean before(@Nullable Object);
    method public final void clear();
    method public final void clear(int);
    method @NonNull public Object clone();
    method public int compareTo(@NonNull java.util.Calendar);
    method protected void complete();
    method protected abstract void computeFields();
    method protected abstract void computeTime();
    method public int get(int);
    method public int getActualMaximum(int);
    method public int getActualMinimum(int);
    method @NonNull public static java.util.Set<java.lang.String> getAvailableCalendarTypes();
    method @NonNull public static java.util.Locale[] getAvailableLocales();
    method @NonNull public String getCalendarType();
    method @Nullable public String getDisplayName(int, int, @NonNull java.util.Locale);
    method @Nullable public java.util.Map<java.lang.String,java.lang.Integer> getDisplayNames(int, int, @NonNull java.util.Locale);
    method public int getFirstDayOfWeek();
    method public abstract int getGreatestMinimum(int);
    method @NonNull public static java.util.Calendar getInstance();
    method @NonNull public static java.util.Calendar getInstance(@NonNull java.util.TimeZone);
    method @NonNull public static java.util.Calendar getInstance(@NonNull java.util.Locale);
    method @NonNull public static java.util.Calendar getInstance(@NonNull java.util.TimeZone, @NonNull java.util.Locale);
    method public abstract int getLeastMaximum(int);
    method public abstract int getMaximum(int);
    method public int getMinimalDaysInFirstWeek();
    method public abstract int getMinimum(int);
    method @NonNull public final java.util.Date getTime();
    method public long getTimeInMillis();
    method @NonNull public java.util.TimeZone getTimeZone();
    method public int getWeekYear();
    method public int getWeeksInWeekYear();
    method protected final int internalGet(int);
    method public boolean isLenient();
    method public final boolean isSet(int);
    method public boolean isWeekDateSupported();
    method public abstract void roll(int, boolean);
    method public void roll(int, int);
    method public void set(int, int);
    method public final void set(int, int, int);
    method public final void set(int, int, int, int, int);
    method public final void set(int, int, int, int, int, int);
    method public void setFirstDayOfWeek(int);
    method public void setLenient(boolean);
    method public void setMinimalDaysInFirstWeek(int);
    method public final void setTime(@NonNull java.util.Date);
    method public void setTimeInMillis(long);
    method public void setTimeZone(@NonNull java.util.TimeZone);
    method public void setWeekDate(int, int, int);
    method @NonNull public final java.time.Instant toInstant();
    field public static final int ALL_STYLES = 0; // 0x0
    field public static final int AM = 0; // 0x0
    field public static final int AM_PM = 9; // 0x9
    field public static final int APRIL = 3; // 0x3
    field public static final int AUGUST = 7; // 0x7
    field public static final int DATE = 5; // 0x5
    field public static final int DAY_OF_MONTH = 5; // 0x5
    field public static final int DAY_OF_WEEK = 7; // 0x7
    field public static final int DAY_OF_WEEK_IN_MONTH = 8; // 0x8
    field public static final int DAY_OF_YEAR = 6; // 0x6
    field public static final int DECEMBER = 11; // 0xb
    field public static final int DST_OFFSET = 16; // 0x10
    field public static final int ERA = 0; // 0x0
    field public static final int FEBRUARY = 1; // 0x1
    field public static final int FIELD_COUNT = 17; // 0x11
    field public static final int FRIDAY = 6; // 0x6
    field public static final int HOUR = 10; // 0xa
    field public static final int HOUR_OF_DAY = 11; // 0xb
    field public static final int JANUARY = 0; // 0x0
    field public static final int JULY = 6; // 0x6
    field public static final int JUNE = 5; // 0x5
    field public static final int LONG = 2; // 0x2
    field public static final int LONG_FORMAT = 2; // 0x2
    field public static final int LONG_STANDALONE = 32770; // 0x8002
    field public static final int MARCH = 2; // 0x2
    field public static final int MAY = 4; // 0x4
    field public static final int MILLISECOND = 14; // 0xe
    field public static final int MINUTE = 12; // 0xc
    field public static final int MONDAY = 2; // 0x2
    field public static final int MONTH = 2; // 0x2
    field public static final int NARROW_FORMAT = 4; // 0x4
    field public static final int NARROW_STANDALONE = 32772; // 0x8004
    field public static final int NOVEMBER = 10; // 0xa
    field public static final int OCTOBER = 9; // 0x9
    field public static final int PM = 1; // 0x1
    field public static final int SATURDAY = 7; // 0x7
    field public static final int SECOND = 13; // 0xd
    field public static final int SEPTEMBER = 8; // 0x8
    field public static final int SHORT = 1; // 0x1
    field public static final int SHORT_FORMAT = 1; // 0x1
    field public static final int SHORT_STANDALONE = 32769; // 0x8001
    field public static final int SUNDAY = 1; // 0x1
    field public static final int THURSDAY = 5; // 0x5
    field public static final int TUESDAY = 3; // 0x3
    field public static final int UNDECIMBER = 12; // 0xc
    field public static final int WEDNESDAY = 4; // 0x4
    field public static final int WEEK_OF_MONTH = 4; // 0x4
    field public static final int WEEK_OF_YEAR = 3; // 0x3
    field public static final int YEAR = 1; // 0x1
    field public static final int ZONE_OFFSET = 15; // 0xf
    field protected boolean areFieldsSet;
    field @NonNull protected int[] fields;
    field @NonNull protected boolean[] isSet;
    field protected boolean isTimeSet;
    field protected long time;
  }

  public static class Calendar.Builder {
    ctor public Calendar.Builder();
    method @NonNull public java.util.Calendar build();
    method @NonNull public java.util.Calendar.Builder set(int, int);
    method @NonNull public java.util.Calendar.Builder setCalendarType(@NonNull String);
    method @NonNull public java.util.Calendar.Builder setDate(int, int, int);
    method @NonNull public java.util.Calendar.Builder setFields(@NonNull int...);
    method @NonNull public java.util.Calendar.Builder setInstant(long);
    method @NonNull public java.util.Calendar.Builder setInstant(@NonNull java.util.Date);
    method @NonNull public java.util.Calendar.Builder setLenient(boolean);
    method @NonNull public java.util.Calendar.Builder setLocale(@NonNull java.util.Locale);
    method @NonNull public java.util.Calendar.Builder setTimeOfDay(int, int, int);
    method @NonNull public java.util.Calendar.Builder setTimeOfDay(int, int, int, int);
    method @NonNull public java.util.Calendar.Builder setTimeZone(@NonNull java.util.TimeZone);
    method @NonNull public java.util.Calendar.Builder setWeekDate(int, int, int);
    method @NonNull public java.util.Calendar.Builder setWeekDefinition(int, int);
  }

  public interface Collection<E> extends java.lang.Iterable<E> {
    method public boolean add(E);
    method public boolean addAll(@NonNull java.util.Collection<? extends E>);
    method public void clear();
    method public boolean contains(@Nullable Object);
    method public boolean containsAll(@NonNull java.util.Collection<?>);
    method public boolean equals(@Nullable Object);
    method public int hashCode();
    method public boolean isEmpty();
    method @NonNull public java.util.Iterator<E> iterator();
    method @NonNull public default java.util.stream.Stream<E> parallelStream();
    method public boolean remove(@Nullable Object);
    method public boolean removeAll(@NonNull java.util.Collection<?>);
    method public default boolean removeIf(@NonNull java.util.function.Predicate<? super E>);
    method public boolean retainAll(@NonNull java.util.Collection<?>);
    method public int size();
    method @NonNull public default java.util.Spliterator<E> spliterator();
    method @NonNull public default java.util.stream.Stream<E> stream();
    method @NonNull public Object[] toArray();
    method @NonNull public <T> T[] toArray(@NonNull T[]);
    method @NonNull public default <T> T[] toArray(@NonNull java.util.function.IntFunction<T[]>);
  }

  public class Collections {
    method @java.lang.SafeVarargs public static <T> boolean addAll(@NonNull java.util.Collection<? super T>, @NonNull T...);
    method @NonNull public static <T> java.util.Queue<T> asLifoQueue(@NonNull java.util.Deque<T>);
    method public static <T> int binarySearch(@NonNull java.util.List<? extends java.lang.Comparable<? super T>>, @NonNull T);
    method public static <T> int binarySearch(@NonNull java.util.List<? extends T>, T, @Nullable java.util.Comparator<? super T>);
    method @NonNull public static <E> java.util.Collection<E> checkedCollection(@NonNull java.util.Collection<E>, @NonNull Class<E>);
    method @NonNull public static <E> java.util.List<E> checkedList(@NonNull java.util.List<E>, @NonNull Class<E>);
    method @NonNull public static <K, V> java.util.Map<K,V> checkedMap(@NonNull java.util.Map<K,V>, @NonNull Class<K>, @NonNull Class<V>);
    method @NonNull public static <K, V> java.util.NavigableMap<K,V> checkedNavigableMap(@NonNull java.util.NavigableMap<K,V>, @NonNull Class<K>, @NonNull Class<V>);
    method @NonNull public static <E> java.util.NavigableSet<E> checkedNavigableSet(@NonNull java.util.NavigableSet<E>, @NonNull Class<E>);
    method @NonNull public static <E> java.util.Queue<E> checkedQueue(@NonNull java.util.Queue<E>, @NonNull Class<E>);
    method @NonNull public static <E> java.util.Set<E> checkedSet(@NonNull java.util.Set<E>, @NonNull Class<E>);
    method @NonNull public static <K, V> java.util.SortedMap<K,V> checkedSortedMap(@NonNull java.util.SortedMap<K,V>, @NonNull Class<K>, @NonNull Class<V>);
    method @NonNull public static <E> java.util.SortedSet<E> checkedSortedSet(@NonNull java.util.SortedSet<E>, @NonNull Class<E>);
    method public static <T> void copy(@NonNull java.util.List<? super T>, @NonNull java.util.List<? extends T>);
    method public static boolean disjoint(@NonNull java.util.Collection<?>, @NonNull java.util.Collection<?>);
    method @NonNull public static <T> java.util.Enumeration<T> emptyEnumeration();
    method @NonNull public static <T> java.util.Iterator<T> emptyIterator();
    method @NonNull public static final <T> java.util.List<T> emptyList();
    method @NonNull public static <T> java.util.ListIterator<T> emptyListIterator();
    method @NonNull public static final <K, V> java.util.Map<K,V> emptyMap();
    method @NonNull public static final <K, V> java.util.NavigableMap<K,V> emptyNavigableMap();
    method @NonNull public static <E> java.util.NavigableSet<E> emptyNavigableSet();
    method @NonNull public static final <T> java.util.Set<T> emptySet();
    method @NonNull public static final <K, V> java.util.SortedMap<K,V> emptySortedMap();
    method @NonNull public static <E> java.util.SortedSet<E> emptySortedSet();
    method @NonNull public static <T> java.util.Enumeration<T> enumeration(@NonNull java.util.Collection<T>);
    method public static <T> void fill(@NonNull java.util.List<? super T>, T);
    method public static int frequency(@NonNull java.util.Collection<?>, @Nullable Object);
    method public static int indexOfSubList(@NonNull java.util.List<?>, @NonNull java.util.List<?>);
    method public static int lastIndexOfSubList(@NonNull java.util.List<?>, @NonNull java.util.List<?>);
    method @NonNull public static <T> java.util.ArrayList<T> list(@NonNull java.util.Enumeration<T>);
    method @NonNull public static <T extends java.lang.Object & java.lang.Comparable<? super T>> T max(@NonNull java.util.Collection<? extends T>);
    method public static <T> T max(@NonNull java.util.Collection<? extends T>, @Nullable java.util.Comparator<? super T>);
    method @NonNull public static <T extends java.lang.Object & java.lang.Comparable<? super T>> T min(@NonNull java.util.Collection<? extends T>);
    method public static <T> T min(@NonNull java.util.Collection<? extends T>, @Nullable java.util.Comparator<? super T>);
    method @NonNull public static <T> java.util.List<T> nCopies(int, T);
    method @NonNull public static <E> java.util.Set<E> newSetFromMap(@NonNull java.util.Map<E,java.lang.Boolean>);
    method public static <T> boolean replaceAll(@NonNull java.util.List<T>, T, T);
    method public static void reverse(@NonNull java.util.List<?>);
    method @NonNull public static <T> java.util.Comparator<T> reverseOrder();
    method @NonNull public static <T> java.util.Comparator<T> reverseOrder(@Nullable java.util.Comparator<T>);
    method public static void rotate(@NonNull java.util.List<?>, int);
    method public static void shuffle(@NonNull java.util.List<?>);
    method public static void shuffle(@NonNull java.util.List<?>, @NonNull java.util.Random);
    method @NonNull public static <T> java.util.Set<T> singleton(T);
    method @NonNull public static <T> java.util.List<T> singletonList(T);
    method @NonNull public static <K, V> java.util.Map<K,V> singletonMap(K, V);
    method public static <T extends java.lang.Comparable<? super T>> void sort(@NonNull java.util.List<T>);
    method public static <T> void sort(@NonNull java.util.List<T>, @Nullable java.util.Comparator<? super T>);
    method public static void swap(@NonNull java.util.List<?>, int, int);
    method @NonNull public static <T> java.util.Collection<T> synchronizedCollection(@NonNull java.util.Collection<T>);
    method @NonNull public static <T> java.util.List<T> synchronizedList(@NonNull java.util.List<T>);
    method @NonNull public static <K, V> java.util.Map<K,V> synchronizedMap(@NonNull java.util.Map<K,V>);
    method @NonNull public static <K, V> java.util.NavigableMap<K,V> synchronizedNavigableMap(@NonNull java.util.NavigableMap<K,V>);
    method @NonNull public static <T> java.util.NavigableSet<T> synchronizedNavigableSet(@NonNull java.util.NavigableSet<T>);
    method @NonNull public static <T> java.util.Set<T> synchronizedSet(@NonNull java.util.Set<T>);
    method @NonNull public static <K, V> java.util.SortedMap<K,V> synchronizedSortedMap(@NonNull java.util.SortedMap<K,V>);
    method @NonNull public static <T> java.util.SortedSet<T> synchronizedSortedSet(@NonNull java.util.SortedSet<T>);
    method @NonNull public static <T> java.util.Collection<T> unmodifiableCollection(@NonNull java.util.Collection<? extends T>);
    method @NonNull public static <T> java.util.List<T> unmodifiableList(@NonNull java.util.List<? extends T>);
    method @NonNull public static <K, V> java.util.Map<K,V> unmodifiableMap(@NonNull java.util.Map<? extends K,? extends V>);
    method @NonNull public static <K, V> java.util.NavigableMap<K,V> unmodifiableNavigableMap(@NonNull java.util.NavigableMap<K,? extends V>);
    method @NonNull public static <T> java.util.NavigableSet<T> unmodifiableNavigableSet(@NonNull java.util.NavigableSet<T>);
    method @NonNull public static <T> java.util.Set<T> unmodifiableSet(@NonNull java.util.Set<? extends T>);
    method @NonNull public static <K, V> java.util.SortedMap<K,V> unmodifiableSortedMap(@NonNull java.util.SortedMap<K,? extends V>);
    method @NonNull public static <T> java.util.SortedSet<T> unmodifiableSortedSet(@NonNull java.util.SortedSet<T>);
    field @NonNull public static final java.util.List EMPTY_LIST;
    field @NonNull public static final java.util.Map EMPTY_MAP;
    field @NonNull public static final java.util.Set EMPTY_SET;
  }

  @java.lang.FunctionalInterface public interface Comparator<T> {
    method public int compare(T, T);
    method public static <T, U> java.util.Comparator<T> comparing(java.util.function.Function<? super T,? extends U>, java.util.Comparator<? super U>);
    method public static <T, U extends java.lang.Comparable<? super U>> java.util.Comparator<T> comparing(java.util.function.Function<? super T,? extends U>);
    method public static <T> java.util.Comparator<T> comparingDouble(java.util.function.ToDoubleFunction<? super T>);
    method public static <T> java.util.Comparator<T> comparingInt(java.util.function.ToIntFunction<? super T>);
    method public static <T> java.util.Comparator<T> comparingLong(java.util.function.ToLongFunction<? super T>);
    method public boolean equals(Object);
    method public static <T extends java.lang.Comparable<? super T>> java.util.Comparator<T> naturalOrder();
    method public static <T> java.util.Comparator<T> nullsFirst(java.util.Comparator<? super T>);
    method public static <T> java.util.Comparator<T> nullsLast(java.util.Comparator<? super T>);
    method public static <T extends java.lang.Comparable<? super T>> java.util.Comparator<T> reverseOrder();
    method public default java.util.Comparator<T> reversed();
    method public default java.util.Comparator<T> thenComparing(java.util.Comparator<? super T>);
    method public default <U> java.util.Comparator<T> thenComparing(java.util.function.Function<? super T,? extends U>, java.util.Comparator<? super U>);
    method public default <U extends java.lang.Comparable<? super U>> java.util.Comparator<T> thenComparing(java.util.function.Function<? super T,? extends U>);
    method public default java.util.Comparator<T> thenComparingDouble(java.util.function.ToDoubleFunction<? super T>);
    method public default java.util.Comparator<T> thenComparingInt(java.util.function.ToIntFunction<? super T>);
    method public default java.util.Comparator<T> thenComparingLong(java.util.function.ToLongFunction<? super T>);
  }

  public class ConcurrentModificationException extends java.lang.RuntimeException {
    ctor public ConcurrentModificationException();
    ctor public ConcurrentModificationException(String);
    ctor public ConcurrentModificationException(Throwable);
    ctor public ConcurrentModificationException(String, Throwable);
  }

  public final class Currency implements java.io.Serializable {
    method public static java.util.Set<java.util.Currency> getAvailableCurrencies();
    method public String getCurrencyCode();
    method public int getDefaultFractionDigits();
    method public String getDisplayName();
    method public String getDisplayName(java.util.Locale);
    method public static java.util.Currency getInstance(String);
    method public static java.util.Currency getInstance(java.util.Locale);
    method public int getNumericCode();
    method public String getNumericCodeAsString();
    method public String getSymbol();
    method public String getSymbol(java.util.Locale);
  }

  public class Date implements java.lang.Cloneable java.lang.Comparable<java.util.Date> java.io.Serializable {
    ctor public Date();
    ctor public Date(long);
    ctor @Deprecated public Date(int, int, int);
    ctor @Deprecated public Date(int, int, int, int, int);
    ctor @Deprecated public Date(int, int, int, int, int, int);
    ctor @Deprecated public Date(String);
    method @Deprecated public static long UTC(int, int, int, int, int, int);
    method public boolean after(java.util.Date);
    method public boolean before(java.util.Date);
    method public Object clone();
    method public int compareTo(java.util.Date);
    method public static java.util.Date from(java.time.Instant);
    method @Deprecated public int getDate();
    method @Deprecated public int getDay();
    method @Deprecated public int getHours();
    method @Deprecated public int getMinutes();
    method @Deprecated public int getMonth();
    method @Deprecated public int getSeconds();
    method public long getTime();
    method @Deprecated public int getTimezoneOffset();
    method @Deprecated public int getYear();
    method @Deprecated public static long parse(String);
    method @Deprecated public void setDate(int);
    method @Deprecated public void setHours(int);
    method @Deprecated public void setMinutes(int);
    method @Deprecated public void setMonth(int);
    method @Deprecated public void setSeconds(int);
    method public void setTime(long);
    method @Deprecated public void setYear(int);
    method @Deprecated public String toGMTString();
    method public java.time.Instant toInstant();
    method @Deprecated public String toLocaleString();
  }

  public interface Deque<E> extends java.util.Queue<E> {
    method public void addFirst(E);
    method public void addLast(E);
    method @NonNull public java.util.Iterator<E> descendingIterator();
    method public E getFirst();
    method public E getLast();
    method public boolean offerFirst(E);
    method public boolean offerLast(E);
    method @Nullable public E peekFirst();
    method @Nullable public E peekLast();
    method @Nullable public E pollFirst();
    method @Nullable public E pollLast();
    method public E pop();
    method public void push(E);
    method public E removeFirst();
    method public boolean removeFirstOccurrence(@Nullable Object);
    method public E removeLast();
    method public boolean removeLastOccurrence(@Nullable Object);
  }

  public abstract class Dictionary<K, V> {
    ctor public Dictionary();
    method public abstract java.util.Enumeration<V> elements();
    method public abstract V get(Object);
    method public abstract boolean isEmpty();
    method public abstract java.util.Enumeration<K> keys();
    method public abstract V put(K, V);
    method public abstract V remove(Object);
    method public abstract int size();
  }

  public class DoubleSummaryStatistics implements java.util.function.DoubleConsumer {
    ctor public DoubleSummaryStatistics();
    ctor public DoubleSummaryStatistics(long, double, double, double) throws java.lang.IllegalArgumentException;
    method public void accept(double);
    method public void combine(java.util.DoubleSummaryStatistics);
    method public final double getAverage();
    method public final long getCount();
    method public final double getMax();
    method public final double getMin();
    method public final double getSum();
  }

  public class DuplicateFormatFlagsException extends java.util.IllegalFormatException {
    ctor public DuplicateFormatFlagsException(String);
    method public String getFlags();
  }

  public class EmptyStackException extends java.lang.RuntimeException {
    ctor public EmptyStackException();
  }

  public class EnumMap<K extends java.lang.Enum<K>, V> extends java.util.AbstractMap<K,V> implements java.lang.Cloneable java.io.Serializable {
    ctor public EnumMap(Class<K>);
    ctor public EnumMap(java.util.EnumMap<K,? extends V>);
    ctor public EnumMap(java.util.Map<K,? extends V>);
    method public java.util.EnumMap<K,V> clone();
    method public java.util.Set<java.util.Map.Entry<K,V>> entrySet();
    method public V put(K, V);
  }

  public abstract class EnumSet<E extends java.lang.Enum<E>> extends java.util.AbstractSet<E> implements java.lang.Cloneable java.io.Serializable {
    method public static <E extends java.lang.Enum<E>> java.util.EnumSet<E> allOf(Class<E>);
    method public java.util.EnumSet<E> clone();
    method public static <E extends java.lang.Enum<E>> java.util.EnumSet<E> complementOf(java.util.EnumSet<E>);
    method public static <E extends java.lang.Enum<E>> java.util.EnumSet<E> copyOf(java.util.EnumSet<E>);
    method public static <E extends java.lang.Enum<E>> java.util.EnumSet<E> copyOf(java.util.Collection<E>);
    method public static <E extends java.lang.Enum<E>> java.util.EnumSet<E> noneOf(Class<E>);
    method public static <E extends java.lang.Enum<E>> java.util.EnumSet<E> of(E);
    method public static <E extends java.lang.Enum<E>> java.util.EnumSet<E> of(E, E);
    method public static <E extends java.lang.Enum<E>> java.util.EnumSet<E> of(E, E, E);
    method public static <E extends java.lang.Enum<E>> java.util.EnumSet<E> of(E, E, E, E);
    method public static <E extends java.lang.Enum<E>> java.util.EnumSet<E> of(E, E, E, E, E);
    method @java.lang.SafeVarargs public static <E extends java.lang.Enum<E>> java.util.EnumSet<E> of(E, E...);
    method public static <E extends java.lang.Enum<E>> java.util.EnumSet<E> range(E, E);
  }

  public interface Enumeration<E> {
    method public default java.util.Iterator<E> asIterator();
    method public boolean hasMoreElements();
    method public E nextElement();
  }

  public interface EventListener {
  }

  public abstract class EventListenerProxy<T extends java.util.EventListener> implements java.util.EventListener {
    ctor public EventListenerProxy(T);
    method public T getListener();
  }

  public class EventObject implements java.io.Serializable {
    ctor public EventObject(Object);
    method public Object getSource();
    field protected transient Object source;
  }

  public class FormatFlagsConversionMismatchException extends java.util.IllegalFormatException {
    ctor public FormatFlagsConversionMismatchException(String, char);
    method public char getConversion();
    method public String getFlags();
  }

  public interface Formattable {
    method public void formatTo(java.util.Formatter, int, int, int);
  }

  public class FormattableFlags {
    field public static final int ALTERNATE = 4; // 0x4
    field public static final int LEFT_JUSTIFY = 1; // 0x1
    field public static final int UPPERCASE = 2; // 0x2
  }

  public final class Formatter implements java.io.Closeable java.io.Flushable {
    ctor public Formatter();
    ctor public Formatter(Appendable);
    ctor public Formatter(java.util.Locale);
    ctor public Formatter(Appendable, java.util.Locale);
    ctor public Formatter(String) throws java.io.FileNotFoundException;
    ctor public Formatter(String, String) throws java.io.FileNotFoundException, java.io.UnsupportedEncodingException;
    ctor public Formatter(String, String, java.util.Locale) throws java.io.FileNotFoundException, java.io.UnsupportedEncodingException;
    ctor public Formatter(String, java.nio.charset.Charset, java.util.Locale) throws java.io.IOException;
    ctor public Formatter(java.io.File) throws java.io.FileNotFoundException;
    ctor public Formatter(java.io.File, String) throws java.io.FileNotFoundException, java.io.UnsupportedEncodingException;
    ctor public Formatter(java.io.File, String, java.util.Locale) throws java.io.FileNotFoundException, java.io.UnsupportedEncodingException;
    ctor public Formatter(java.io.File, java.nio.charset.Charset, java.util.Locale) throws java.io.IOException;
    ctor public Formatter(java.io.PrintStream);
    ctor public Formatter(java.io.OutputStream);
    ctor public Formatter(java.io.OutputStream, String) throws java.io.UnsupportedEncodingException;
    ctor public Formatter(java.io.OutputStream, String, java.util.Locale) throws java.io.UnsupportedEncodingException;
    ctor public Formatter(java.io.OutputStream, java.nio.charset.Charset, java.util.Locale);
    method public void close();
    method public void flush();
    method public java.util.Formatter format(String, java.lang.Object...);
    method public java.util.Formatter format(java.util.Locale, String, java.lang.Object...);
    method public java.io.IOException ioException();
    method public java.util.Locale locale();
    method public Appendable out();
  }

  public enum Formatter.BigDecimalLayoutForm {
    enum_constant public static final java.util.Formatter.BigDecimalLayoutForm DECIMAL_FLOAT;
    enum_constant public static final java.util.Formatter.BigDecimalLayoutForm SCIENTIFIC;
  }

  public class FormatterClosedException extends java.lang.IllegalStateException {
    ctor public FormatterClosedException();
  }

  public class GregorianCalendar extends java.util.Calendar {
    ctor public GregorianCalendar();
    ctor public GregorianCalendar(java.util.TimeZone);
    ctor public GregorianCalendar(java.util.Locale);
    ctor public GregorianCalendar(java.util.TimeZone, java.util.Locale);
    ctor public GregorianCalendar(int, int, int);
    ctor public GregorianCalendar(int, int, int, int, int);
    ctor public GregorianCalendar(int, int, int, int, int, int);
    method public void add(int, int);
    method protected void computeFields();
    method protected void computeTime();
    method public static java.util.GregorianCalendar from(java.time.ZonedDateTime);
    method public int getGreatestMinimum(int);
    method public final java.util.Date getGregorianChange();
    method public int getLeastMaximum(int);
    method public int getMaximum(int);
    method public int getMinimum(int);
    method public boolean isLeapYear(int);
    method public final boolean isWeekDateSupported();
    method public void roll(int, boolean);
    method public void setGregorianChange(java.util.Date);
    method public java.time.ZonedDateTime toZonedDateTime();
    field public static final int AD = 1; // 0x1
    field public static final int BC = 0; // 0x0
  }

  public class HashMap<K, V> extends java.util.AbstractMap<K,V> implements java.lang.Cloneable java.util.Map<K,V> java.io.Serializable {
    ctor public HashMap(int, float);
    ctor public HashMap(int);
    ctor public HashMap();
    ctor public HashMap(@NonNull java.util.Map<? extends K,? extends V>);
    method @NonNull public Object clone();
    method @Nullable public V compute(K, @NonNull java.util.function.BiFunction<? super K,? super V,? extends V>);
    method @Nullable public V computeIfAbsent(K, @NonNull java.util.function.Function<? super K,? extends V>);
    method @Nullable public V computeIfPresent(K, @NonNull java.util.function.BiFunction<? super K,? super V,? extends V>);
    method @NonNull public java.util.Set<java.util.Map.Entry<K,V>> entrySet();
    method public void forEach(@NonNull java.util.function.BiConsumer<? super K,? super V>);
    method @Nullable public V getOrDefault(@Nullable Object, @Nullable V);
    method @Nullable public V merge(K, @NonNull V, @NonNull java.util.function.BiFunction<? super V,? super V,? extends V>);
    method @Nullable public V putIfAbsent(K, V);
    method public boolean remove(@Nullable Object, @Nullable Object);
    method public boolean replace(K, @Nullable V, V);
    method @Nullable public V replace(K, V);
    method public void replaceAll(@NonNull java.util.function.BiFunction<? super K,? super V,? extends V>);
  }

  public class HashSet<E> extends java.util.AbstractSet<E> implements java.lang.Cloneable java.io.Serializable java.util.Set<E> {
    ctor public HashSet();
    ctor public HashSet(@NonNull java.util.Collection<? extends E>);
    ctor public HashSet(int, float);
    ctor public HashSet(int);
    method @NonNull public Object clone();
    method @NonNull public java.util.Iterator<E> iterator();
    method public int size();
    method @NonNull public java.util.Spliterator<E> spliterator();
  }

  public class Hashtable<K, V> extends java.util.Dictionary<K,V> implements java.lang.Cloneable java.util.Map<K,V> java.io.Serializable {
    ctor public Hashtable(int, float);
    ctor public Hashtable(int);
    ctor public Hashtable();
    ctor public Hashtable(java.util.Map<? extends K,? extends V>);
    method public void clear();
    method public Object clone();
    method public V compute(K, java.util.function.BiFunction<? super K,? super V,? extends V>);
    method public V computeIfAbsent(K, java.util.function.Function<? super K,? extends V>);
    method public V computeIfPresent(K, java.util.function.BiFunction<? super K,? super V,? extends V>);
    method public boolean contains(Object);
    method public boolean containsKey(Object);
    method public boolean containsValue(Object);
    method public java.util.Enumeration<V> elements();
    method public java.util.Set<java.util.Map.Entry<K,V>> entrySet();
    method public boolean equals(Object);
    method public void forEach(java.util.function.BiConsumer<? super K,? super V>);
    method public V get(Object);
    method public V getOrDefault(Object, V);
    method public int hashCode();
    method public boolean isEmpty();
    method public java.util.Set<K> keySet();
    method public java.util.Enumeration<K> keys();
    method public V merge(K, V, java.util.function.BiFunction<? super V,? super V,? extends V>);
    method public V put(K, V);
    method public void putAll(java.util.Map<? extends K,? extends V>);
    method public V putIfAbsent(K, V);
    method protected void rehash();
    method public V remove(Object);
    method public boolean remove(Object, Object);
    method public boolean replace(K, V, V);
    method public V replace(K, V);
    method public void replaceAll(java.util.function.BiFunction<? super K,? super V,? extends V>);
    method public int size();
    method public java.util.Collection<V> values();
  }

  public final class HexFormat {
    method public String delimiter();
    method public String formatHex(byte[]);
    method public String formatHex(byte[], int, int);
    method public <A extends java.lang.Appendable> A formatHex(A, byte[]);
    method public <A extends java.lang.Appendable> A formatHex(A, byte[], int, int);
    method public static int fromHexDigit(int);
    method public static int fromHexDigits(CharSequence);
    method public static int fromHexDigits(CharSequence, int, int);
    method public static long fromHexDigitsToLong(CharSequence);
    method public static long fromHexDigitsToLong(CharSequence, int, int);
    method public static boolean isHexDigit(int);
    method public boolean isUpperCase();
    method public static java.util.HexFormat of();
    method public static java.util.HexFormat ofDelimiter(String);
    method public byte[] parseHex(CharSequence);
    method public byte[] parseHex(CharSequence, int, int);
    method public byte[] parseHex(char[], int, int);
    method public String prefix();
    method public String suffix();
    method public <A extends java.lang.Appendable> A toHexDigits(A, byte);
    method public String toHexDigits(byte);
    method public String toHexDigits(char);
    method public String toHexDigits(short);
    method public String toHexDigits(int);
    method public String toHexDigits(long);
    method public String toHexDigits(long, int);
    method public char toHighHexDigit(int);
    method public char toLowHexDigit(int);
    method public java.util.HexFormat withDelimiter(String);
    method public java.util.HexFormat withLowerCase();
    method public java.util.HexFormat withPrefix(String);
    method public java.util.HexFormat withSuffix(String);
    method public java.util.HexFormat withUpperCase();
  }

  public class IdentityHashMap<K, V> extends java.util.AbstractMap<K,V> implements java.lang.Cloneable java.util.Map<K,V> java.io.Serializable {
    ctor public IdentityHashMap();
    ctor public IdentityHashMap(int);
    ctor public IdentityHashMap(java.util.Map<? extends K,? extends V>);
    method public Object clone();
    method public java.util.Set<java.util.Map.Entry<K,V>> entrySet();
    method public void forEach(java.util.function.BiConsumer<? super K,? super V>);
    method public void replaceAll(java.util.function.BiFunction<? super K,? super V,? extends V>);
  }

  public class IllegalFormatCodePointException extends java.util.IllegalFormatException {
    ctor public IllegalFormatCodePointException(int);
    method public int getCodePoint();
  }

  public class IllegalFormatConversionException extends java.util.IllegalFormatException {
    ctor public IllegalFormatConversionException(char, Class<?>);
    method public Class<?> getArgumentClass();
    method public char getConversion();
  }

  public class IllegalFormatException extends java.lang.IllegalArgumentException {
  }

  public class IllegalFormatFlagsException extends java.util.IllegalFormatException {
    ctor public IllegalFormatFlagsException(String);
    method public String getFlags();
  }

  public class IllegalFormatPrecisionException extends java.util.IllegalFormatException {
    ctor public IllegalFormatPrecisionException(int);
    method public int getPrecision();
  }

  public class IllegalFormatWidthException extends java.util.IllegalFormatException {
    ctor public IllegalFormatWidthException(int);
    method public int getWidth();
  }

  public class IllformedLocaleException extends java.lang.RuntimeException {
    ctor public IllformedLocaleException();
    ctor public IllformedLocaleException(String);
    ctor public IllformedLocaleException(String, int);
    method public int getErrorIndex();
  }

  public class InputMismatchException extends java.util.NoSuchElementException {
    ctor public InputMismatchException();
    ctor public InputMismatchException(String);
  }

  public class IntSummaryStatistics implements java.util.function.IntConsumer {
    ctor public IntSummaryStatistics();
    ctor public IntSummaryStatistics(long, int, int, long) throws java.lang.IllegalArgumentException;
    method public void accept(int);
    method public void combine(java.util.IntSummaryStatistics);
    method public final double getAverage();
    method public final long getCount();
    method public final int getMax();
    method public final int getMin();
    method public final long getSum();
  }

  public class InvalidPropertiesFormatException extends java.io.IOException {
    ctor public InvalidPropertiesFormatException(Throwable);
    ctor public InvalidPropertiesFormatException(String);
  }

  public interface Iterator<E> {
    method public default void forEachRemaining(@NonNull java.util.function.Consumer<? super E>);
    method public boolean hasNext();
    method public E next();
    method public default void remove();
  }

  public class LinkedHashMap<K, V> extends java.util.HashMap<K,V> implements java.util.Map<K,V> {
    ctor public LinkedHashMap(int, float);
    ctor public LinkedHashMap(int);
    ctor public LinkedHashMap();
    ctor public LinkedHashMap(java.util.Map<? extends K,? extends V>);
    ctor public LinkedHashMap(int, float, boolean);
    method protected boolean removeEldestEntry(java.util.Map.Entry<K,V>);
  }

  public class LinkedHashSet<E> extends java.util.HashSet<E> implements java.lang.Cloneable java.io.Serializable java.util.Set<E> {
    ctor public LinkedHashSet(int, float);
    ctor public LinkedHashSet(int);
    ctor public LinkedHashSet();
    ctor public LinkedHashSet(java.util.Collection<? extends E>);
  }

  public class LinkedList<E> extends java.util.AbstractSequentialList<E> implements java.lang.Cloneable java.util.Deque<E> java.util.List<E> java.io.Serializable {
    ctor public LinkedList();
    ctor public LinkedList(@NonNull java.util.Collection<? extends E>);
    method public void addFirst(E);
    method public void addLast(E);
    method @NonNull public Object clone();
    method @NonNull public java.util.Iterator<E> descendingIterator();
    method public E element();
    method public E getFirst();
    method public E getLast();
    method @NonNull public java.util.ListIterator<E> listIterator(int);
    method public boolean offer(E);
    method public boolean offerFirst(E);
    method public boolean offerLast(E);
    method @Nullable public E peek();
    method @Nullable public E peekFirst();
    method @Nullable public E peekLast();
    method @Nullable public E poll();
    method @Nullable public E pollFirst();
    method @Nullable public E pollLast();
    method public E pop();
    method public void push(E);
    method public E remove();
    method public E removeFirst();
    method public boolean removeFirstOccurrence(@Nullable Object);
    method public E removeLast();
    method public boolean removeLastOccurrence(@Nullable Object);
    method public int size();
    method @NonNull public java.util.Spliterator<E> spliterator();
  }

  public interface List<E> extends java.util.Collection<E> {
    method public void add(int, E);
    method public boolean addAll(int, @NonNull java.util.Collection<? extends E>);
    method @NonNull public static <E> java.util.List<E> copyOf(@NonNull java.util.Collection<? extends E>);
    method public E get(int);
    method public int indexOf(@Nullable Object);
    method public int lastIndexOf(@Nullable Object);
    method @NonNull public java.util.ListIterator<E> listIterator();
    method @NonNull public java.util.ListIterator<E> listIterator(int);
    method @NonNull public static <E> java.util.List<E> of();
    method @NonNull public static <E> java.util.List<E> of(@NonNull E);
    method @NonNull public static <E> java.util.List<E> of(@NonNull E, @NonNull E);
    method @NonNull public static <E> java.util.List<E> of(@NonNull E, @NonNull E, @NonNull E);
    method @NonNull public static <E> java.util.List<E> of(@NonNull E, @NonNull E, @NonNull E, @NonNull E);
    method @NonNull public static <E> java.util.List<E> of(@NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E);
    method @NonNull public static <E> java.util.List<E> of(@NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E);
    method @NonNull public static <E> java.util.List<E> of(@NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E);
    method @NonNull public static <E> java.util.List<E> of(@NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E);
    method @NonNull public static <E> java.util.List<E> of(@NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E);
    method @NonNull public static <E> java.util.List<E> of(@NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E);
    method @NonNull @java.lang.SafeVarargs public static <E> java.util.List<E> of(@NonNull E...);
    method public E remove(int);
    method public default void replaceAll(@NonNull java.util.function.UnaryOperator<E>);
    method public E set(int, E);
    method public default void sort(@Nullable java.util.Comparator<? super E>);
    method @NonNull public java.util.List<E> subList(int, int);
  }

  public interface ListIterator<E> extends java.util.Iterator<E> {
    method public void add(E);
    method public boolean hasPrevious();
    method public int nextIndex();
    method public E previous();
    method public int previousIndex();
    method public void remove();
    method public void set(E);
  }

  public abstract class ListResourceBundle extends java.util.ResourceBundle {
    ctor public ListResourceBundle();
    method protected abstract Object[][] getContents();
    method public java.util.Enumeration<java.lang.String> getKeys();
    method public final Object handleGetObject(String);
  }

  public final class Locale implements java.lang.Cloneable java.io.Serializable {
    ctor public Locale(@NonNull String, @NonNull String, @NonNull String);
    ctor public Locale(@NonNull String, @NonNull String);
    ctor public Locale(@NonNull String);
    method @NonNull public Object clone();
    method @NonNull public static java.util.List<java.util.Locale> filter(@NonNull java.util.List<java.util.Locale.LanguageRange>, @NonNull java.util.Collection<java.util.Locale>, @NonNull java.util.Locale.FilteringMode);
    method @NonNull public static java.util.List<java.util.Locale> filter(@NonNull java.util.List<java.util.Locale.LanguageRange>, @NonNull java.util.Collection<java.util.Locale>);
    method @NonNull public static java.util.List<java.lang.String> filterTags(@NonNull java.util.List<java.util.Locale.LanguageRange>, @NonNull java.util.Collection<java.lang.String>, @NonNull java.util.Locale.FilteringMode);
    method @NonNull public static java.util.List<java.lang.String> filterTags(@NonNull java.util.List<java.util.Locale.LanguageRange>, @NonNull java.util.Collection<java.lang.String>);
    method @NonNull public static java.util.Locale forLanguageTag(@NonNull String);
    method @NonNull public static java.util.Locale[] getAvailableLocales();
    method @NonNull public String getCountry();
    method @NonNull public static java.util.Locale getDefault();
    method @NonNull public static java.util.Locale getDefault(@NonNull java.util.Locale.Category);
    method @NonNull public String getDisplayCountry();
    method @NonNull public String getDisplayCountry(@NonNull java.util.Locale);
    method @NonNull public String getDisplayLanguage();
    method @NonNull public String getDisplayLanguage(@NonNull java.util.Locale);
    method @NonNull public String getDisplayName();
    method @NonNull public String getDisplayName(@NonNull java.util.Locale);
    method @NonNull public String getDisplayScript();
    method @NonNull public String getDisplayScript(@NonNull java.util.Locale);
    method @NonNull public String getDisplayVariant();
    method @NonNull public String getDisplayVariant(@NonNull java.util.Locale);
    method @Nullable public String getExtension(char);
    method @NonNull public java.util.Set<java.lang.Character> getExtensionKeys();
    method @NonNull public String getISO3Country() throws java.util.MissingResourceException;
    method @NonNull public String getISO3Language() throws java.util.MissingResourceException;
    method @NonNull public static String[] getISOCountries();
    method @NonNull public static java.util.Set<java.lang.String> getISOCountries(@NonNull java.util.Locale.IsoCountryCode);
    method @NonNull public static String[] getISOLanguages();
    method @NonNull public String getLanguage();
    method @NonNull public String getScript();
    method @NonNull public java.util.Set<java.lang.String> getUnicodeLocaleAttributes();
    method @NonNull public java.util.Set<java.lang.String> getUnicodeLocaleKeys();
    method @Nullable public String getUnicodeLocaleType(@NonNull String);
    method @NonNull public String getVariant();
    method public boolean hasExtensions();
    method @Nullable public static java.util.Locale lookup(@NonNull java.util.List<java.util.Locale.LanguageRange>, @NonNull java.util.Collection<java.util.Locale>);
    method @Nullable public static String lookupTag(@NonNull java.util.List<java.util.Locale.LanguageRange>, @NonNull java.util.Collection<java.lang.String>);
    method public static void setDefault(@NonNull java.util.Locale);
    method public static void setDefault(@NonNull java.util.Locale.Category, @NonNull java.util.Locale);
    method @NonNull public java.util.Locale stripExtensions();
    method @NonNull public String toLanguageTag();
    field @NonNull public static final java.util.Locale CANADA;
    field @NonNull public static final java.util.Locale CANADA_FRENCH;
    field @NonNull public static final java.util.Locale CHINA;
    field @NonNull public static final java.util.Locale CHINESE;
    field @NonNull public static final java.util.Locale ENGLISH;
    field @NonNull public static final java.util.Locale FRANCE;
    field @NonNull public static final java.util.Locale FRENCH;
    field @NonNull public static final java.util.Locale GERMAN;
    field @NonNull public static final java.util.Locale GERMANY;
    field @NonNull public static final java.util.Locale ITALIAN;
    field @NonNull public static final java.util.Locale ITALY;
    field @NonNull public static final java.util.Locale JAPAN;
    field @NonNull public static final java.util.Locale JAPANESE;
    field @NonNull public static final java.util.Locale KOREA;
    field @NonNull public static final java.util.Locale KOREAN;
    field @NonNull public static final java.util.Locale PRC;
    field public static final char PRIVATE_USE_EXTENSION = 120; // 0x0078 'x'
    field @NonNull public static final java.util.Locale ROOT;
    field @NonNull public static final java.util.Locale SIMPLIFIED_CHINESE;
    field @NonNull public static final java.util.Locale TAIWAN;
    field @NonNull public static final java.util.Locale TRADITIONAL_CHINESE;
    field @NonNull public static final java.util.Locale UK;
    field public static final char UNICODE_LOCALE_EXTENSION = 117; // 0x0075 'u'
    field @NonNull public static final java.util.Locale US;
  }

  public static final class Locale.Builder {
    ctor public Locale.Builder();
    method @NonNull public java.util.Locale.Builder addUnicodeLocaleAttribute(@NonNull String);
    method @NonNull public java.util.Locale build();
    method @NonNull public java.util.Locale.Builder clear();
    method @NonNull public java.util.Locale.Builder clearExtensions();
    method @NonNull public java.util.Locale.Builder removeUnicodeLocaleAttribute(@NonNull String);
    method @NonNull public java.util.Locale.Builder setExtension(char, @Nullable String);
    method @NonNull public java.util.Locale.Builder setLanguage(@Nullable String);
    method @NonNull public java.util.Locale.Builder setLanguageTag(@NonNull String);
    method @NonNull public java.util.Locale.Builder setLocale(@NonNull java.util.Locale);
    method @NonNull public java.util.Locale.Builder setRegion(@Nullable String);
    method @NonNull public java.util.Locale.Builder setScript(@Nullable String);
    method @NonNull public java.util.Locale.Builder setUnicodeLocaleKeyword(@NonNull String, @Nullable String);
    method @NonNull public java.util.Locale.Builder setVariant(@Nullable String);
  }

  public enum Locale.Category {
    enum_constant public static final java.util.Locale.Category DISPLAY;
    enum_constant public static final java.util.Locale.Category FORMAT;
  }

  public enum Locale.FilteringMode {
    enum_constant public static final java.util.Locale.FilteringMode AUTOSELECT_FILTERING;
    enum_constant public static final java.util.Locale.FilteringMode EXTENDED_FILTERING;
    enum_constant public static final java.util.Locale.FilteringMode IGNORE_EXTENDED_RANGES;
    enum_constant public static final java.util.Locale.FilteringMode MAP_EXTENDED_RANGES;
    enum_constant public static final java.util.Locale.FilteringMode REJECT_EXTENDED_RANGES;
  }

  public enum Locale.IsoCountryCode {
    enum_constant public static final java.util.Locale.IsoCountryCode PART1_ALPHA2;
    enum_constant public static final java.util.Locale.IsoCountryCode PART1_ALPHA3;
    enum_constant public static final java.util.Locale.IsoCountryCode PART3;
  }

  public static final class Locale.LanguageRange {
    ctor public Locale.LanguageRange(@NonNull String);
    ctor public Locale.LanguageRange(@NonNull String, double);
    method @NonNull public String getRange();
    method public double getWeight();
    method @NonNull public static java.util.List<java.util.Locale.LanguageRange> mapEquivalents(@NonNull java.util.List<java.util.Locale.LanguageRange>, @NonNull java.util.Map<java.lang.String,java.util.List<java.lang.String>>);
    method @NonNull public static java.util.List<java.util.Locale.LanguageRange> parse(@NonNull String);
    method @NonNull public static java.util.List<java.util.Locale.LanguageRange> parse(@NonNull String, @NonNull java.util.Map<java.lang.String,java.util.List<java.lang.String>>);
    field public static final double MAX_WEIGHT = 1.0;
    field public static final double MIN_WEIGHT = 0.0;
  }

  public class LongSummaryStatistics implements java.util.function.IntConsumer java.util.function.LongConsumer {
    ctor public LongSummaryStatistics();
    ctor public LongSummaryStatistics(long, long, long, long) throws java.lang.IllegalArgumentException;
    method public void accept(int);
    method public void accept(long);
    method public void combine(java.util.LongSummaryStatistics);
    method public final double getAverage();
    method public final long getCount();
    method public final long getMax();
    method public final long getMin();
    method public final long getSum();
  }

  public interface Map<K, V> {
    method public void clear();
    method @Nullable public default V compute(K, @NonNull java.util.function.BiFunction<? super K,? super V,? extends V>);
    method @Nullable public default V computeIfAbsent(K, @NonNull java.util.function.Function<? super K,? extends V>);
    method @Nullable public default V computeIfPresent(K, @NonNull java.util.function.BiFunction<? super K,? super V,? extends V>);
    method public boolean containsKey(@Nullable Object);
    method public boolean containsValue(@Nullable Object);
    method @NonNull public static <K, V> java.util.Map<K,V> copyOf(@NonNull java.util.Map<? extends K,? extends V>);
    method @NonNull public static <K, V> java.util.Map.Entry<K,V> entry(@NonNull K, @NonNull V);
    method @NonNull public java.util.Set<java.util.Map.Entry<K,V>> entrySet();
    method public boolean equals(@Nullable Object);
    method public default void forEach(@NonNull java.util.function.BiConsumer<? super K,? super V>);
    method @Nullable public V get(@Nullable Object);
    method @Nullable public default V getOrDefault(@Nullable Object, @Nullable V);
    method public int hashCode();
    method public boolean isEmpty();
    method @NonNull public java.util.Set<K> keySet();
    method @Nullable public default V merge(K, @NonNull V, @NonNull java.util.function.BiFunction<? super V,? super V,? extends V>);
    method @NonNull public static <K, V> java.util.Map<K,V> of();
    method @NonNull public static <K, V> java.util.Map<K,V> of(@NonNull K, @NonNull V);
    method @NonNull public static <K, V> java.util.Map<K,V> of(@NonNull K, @NonNull V, @NonNull K, @NonNull V);
    method @NonNull public static <K, V> java.util.Map<K,V> of(@NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V);
    method @NonNull public static <K, V> java.util.Map<K,V> of(@NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V);
    method @NonNull public static <K, V> java.util.Map<K,V> of(@NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V);
    method @NonNull public static <K, V> java.util.Map<K,V> of(@NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V);
    method @NonNull public static <K, V> java.util.Map<K,V> of(@NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V);
    method @NonNull public static <K, V> java.util.Map<K,V> of(@NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V);
    method @NonNull public static <K, V> java.util.Map<K,V> of(@NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V);
    method @NonNull public static <K, V> java.util.Map<K,V> of(@NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V, @NonNull K, @NonNull V);
    method @NonNull @java.lang.SafeVarargs public static <K, V> java.util.Map<K,V> ofEntries(@NonNull java.util.Map.Entry<? extends K,? extends V>...);
    method @Nullable public V put(K, V);
    method public void putAll(@NonNull java.util.Map<? extends K,? extends V>);
    method @Nullable public default V putIfAbsent(K, V);
    method @Nullable public V remove(@Nullable Object);
    method public default boolean remove(@Nullable Object, @Nullable Object);
    method public default boolean replace(K, @Nullable V, V);
    method @Nullable public default V replace(K, V);
    method public default void replaceAll(@NonNull java.util.function.BiFunction<? super K,? super V,? extends V>);
    method public int size();
    method @NonNull public java.util.Collection<V> values();
  }

  public static interface Map.Entry<K, V> {
    method @NonNull public static <K extends java.lang.Comparable<? super K>, V> java.util.Comparator<java.util.Map.Entry<K,V>> comparingByKey();
    method @NonNull public static <K, V> java.util.Comparator<java.util.Map.Entry<K,V>> comparingByKey(@NonNull java.util.Comparator<? super K>);
    method @NonNull public static <K, V extends java.lang.Comparable<? super V>> java.util.Comparator<java.util.Map.Entry<K,V>> comparingByValue();
    method @NonNull public static <K, V> java.util.Comparator<java.util.Map.Entry<K,V>> comparingByValue(@NonNull java.util.Comparator<? super V>);
    method @FlaggedApi("com.android.libcore.v_apis") @NonNull public static <K, V> java.util.Map.Entry<K,V> copyOf(@NonNull java.util.Map.Entry<? extends K,? extends V>);
    method public boolean equals(@Nullable Object);
    method public K getKey();
    method public V getValue();
    method public int hashCode();
    method public V setValue(V);
  }

  public class MissingFormatArgumentException extends java.util.IllegalFormatException {
    ctor public MissingFormatArgumentException(String);
    method public String getFormatSpecifier();
  }

  public class MissingFormatWidthException extends java.util.IllegalFormatException {
    ctor public MissingFormatWidthException(String);
    method public String getFormatSpecifier();
  }

  public class MissingResourceException extends java.lang.RuntimeException {
    ctor public MissingResourceException(String, String, String);
    method public String getClassName();
    method public String getKey();
  }

  public interface NavigableMap<K, V> extends java.util.SortedMap<K,V> {
    method @Nullable public java.util.Map.Entry<K,V> ceilingEntry(K);
    method @Nullable public K ceilingKey(K);
    method @NonNull public java.util.NavigableSet<K> descendingKeySet();
    method @NonNull public java.util.NavigableMap<K,V> descendingMap();
    method @Nullable public java.util.Map.Entry<K,V> firstEntry();
    method @Nullable public java.util.Map.Entry<K,V> floorEntry(K);
    method @Nullable public K floorKey(K);
    method @NonNull public java.util.NavigableMap<K,V> headMap(K, boolean);
    method @Nullable public java.util.Map.Entry<K,V> higherEntry(K);
    method @Nullable public K higherKey(K);
    method @Nullable public java.util.Map.Entry<K,V> lastEntry();
    method @Nullable public java.util.Map.Entry<K,V> lowerEntry(K);
    method @Nullable public K lowerKey(K);
    method @NonNull public java.util.NavigableSet<K> navigableKeySet();
    method @Nullable public java.util.Map.Entry<K,V> pollFirstEntry();
    method @Nullable public java.util.Map.Entry<K,V> pollLastEntry();
    method @NonNull public java.util.NavigableMap<K,V> subMap(K, boolean, K, boolean);
    method @NonNull public java.util.NavigableMap<K,V> tailMap(K, boolean);
  }

  public interface NavigableSet<E> extends java.util.SortedSet<E> {
    method public E ceiling(E);
    method public java.util.Iterator<E> descendingIterator();
    method public java.util.NavigableSet<E> descendingSet();
    method public E floor(E);
    method public java.util.NavigableSet<E> headSet(E, boolean);
    method public E higher(E);
    method public E lower(E);
    method public E pollFirst();
    method public E pollLast();
    method public java.util.NavigableSet<E> subSet(E, boolean, E, boolean);
    method public java.util.NavigableSet<E> tailSet(E, boolean);
  }

  public class NoSuchElementException extends java.lang.RuntimeException {
    ctor public NoSuchElementException();
    ctor public NoSuchElementException(String, Throwable);
    ctor public NoSuchElementException(Throwable);
    ctor public NoSuchElementException(String);
  }

  public final class Objects {
    method public static int checkFromIndexSize(int, int, int);
    method public static long checkFromIndexSize(long, long, long);
    method public static int checkFromToIndex(int, int, int);
    method public static long checkFromToIndex(long, long, long);
    method public static int checkIndex(int, int);
    method public static long checkIndex(long, long);
    method public static <T> int compare(T, T, @NonNull java.util.Comparator<? super T>);
    method public static boolean deepEquals(@Nullable Object, @Nullable Object);
    method public static boolean equals(@Nullable Object, @Nullable Object);
    method public static int hash(@Nullable java.lang.Object...);
    method public static int hashCode(@Nullable Object);
    method public static boolean isNull(@Nullable Object);
    method public static boolean nonNull(@Nullable Object);
    method @NonNull public static <T> T requireNonNull(@Nullable T);
    method @NonNull public static <T> T requireNonNull(@Nullable T, @NonNull String);
    method @NonNull public static <T> T requireNonNull(@Nullable T, @NonNull java.util.function.Supplier<java.lang.String>);
    method @NonNull public static <T> T requireNonNullElse(@Nullable T, @NonNull T);
    method @NonNull public static <T> T requireNonNullElseGet(@Nullable T, @NonNull java.util.function.Supplier<? extends T>);
    method @NonNull public static String toString(@Nullable Object);
    method @NonNull public static String toString(@Nullable Object, @NonNull String);
  }

  @Deprecated public class Observable {
    ctor @Deprecated public Observable();
    method @Deprecated public void addObserver(java.util.Observer);
    method @Deprecated protected void clearChanged();
    method @Deprecated public int countObservers();
    method @Deprecated public void deleteObserver(java.util.Observer);
    method @Deprecated public void deleteObservers();
    method @Deprecated public boolean hasChanged();
    method @Deprecated public void notifyObservers();
    method @Deprecated public void notifyObservers(Object);
    method @Deprecated protected void setChanged();
  }

  @Deprecated public interface Observer {
    method @Deprecated public void update(java.util.Observable, Object);
  }

  public final class Optional<T> {
    method public static <T> java.util.Optional<T> empty();
    method public java.util.Optional<T> filter(java.util.function.Predicate<? super T>);
    method public <U> java.util.Optional<U> flatMap(java.util.function.Function<? super T,? extends java.util.Optional<? extends U>>);
    method public T get();
    method public void ifPresent(java.util.function.Consumer<? super T>);
    method public void ifPresentOrElse(java.util.function.Consumer<? super T>, Runnable);
    method public boolean isEmpty();
    method public boolean isPresent();
    method public <U> java.util.Optional<U> map(java.util.function.Function<? super T,? extends U>);
    method public static <T> java.util.Optional<T> of(T);
    method public static <T> java.util.Optional<T> ofNullable(T);
    method public java.util.Optional<T> or(java.util.function.Supplier<? extends java.util.Optional<? extends T>>);
    method public T orElse(T);
    method public T orElseGet(java.util.function.Supplier<? extends T>);
    method public T orElseThrow();
    method public <X extends java.lang.Throwable> T orElseThrow(java.util.function.Supplier<? extends X>) throws X;
    method public java.util.stream.Stream<T> stream();
  }

  public final class OptionalDouble {
    method public static java.util.OptionalDouble empty();
    method public double getAsDouble();
    method public void ifPresent(java.util.function.DoubleConsumer);
    method public void ifPresentOrElse(java.util.function.DoubleConsumer, Runnable);
    method public boolean isEmpty();
    method public boolean isPresent();
    method public static java.util.OptionalDouble of(double);
    method public double orElse(double);
    method public double orElseGet(java.util.function.DoubleSupplier);
    method public double orElseThrow();
    method public <X extends java.lang.Throwable> double orElseThrow(java.util.function.Supplier<? extends X>) throws X;
    method public java.util.stream.DoubleStream stream();
  }

  public final class OptionalInt {
    method public static java.util.OptionalInt empty();
    method public int getAsInt();
    method public void ifPresent(java.util.function.IntConsumer);
    method public void ifPresentOrElse(java.util.function.IntConsumer, Runnable);
    method public boolean isEmpty();
    method public boolean isPresent();
    method public static java.util.OptionalInt of(int);
    method public int orElse(int);
    method public int orElseGet(java.util.function.IntSupplier);
    method public int orElseThrow();
    method public <X extends java.lang.Throwable> int orElseThrow(java.util.function.Supplier<? extends X>) throws X;
    method public java.util.stream.IntStream stream();
  }

  public final class OptionalLong {
    method public static java.util.OptionalLong empty();
    method public long getAsLong();
    method public void ifPresent(java.util.function.LongConsumer);
    method public void ifPresentOrElse(java.util.function.LongConsumer, Runnable);
    method public boolean isEmpty();
    method public boolean isPresent();
    method public static java.util.OptionalLong of(long);
    method public long orElse(long);
    method public long orElseGet(java.util.function.LongSupplier);
    method public long orElseThrow();
    method public <X extends java.lang.Throwable> long orElseThrow(java.util.function.Supplier<? extends X>) throws X;
    method public java.util.stream.LongStream stream();
  }

  public interface PrimitiveIterator<T, T_CONS> extends java.util.Iterator<T> {
    method public void forEachRemaining(T_CONS);
  }

  public static interface PrimitiveIterator.OfDouble extends java.util.PrimitiveIterator<java.lang.Double,java.util.function.DoubleConsumer> {
    method public default void forEachRemaining(java.util.function.DoubleConsumer);
    method public default void forEachRemaining(java.util.function.Consumer<? super java.lang.Double>);
    method public default Double next();
    method public double nextDouble();
  }

  public static interface PrimitiveIterator.OfInt extends java.util.PrimitiveIterator<java.lang.Integer,java.util.function.IntConsumer> {
    method public default void forEachRemaining(java.util.function.IntConsumer);
    method public default void forEachRemaining(java.util.function.Consumer<? super java.lang.Integer>);
    method public default Integer next();
    method public int nextInt();
  }

  public static interface PrimitiveIterator.OfLong extends java.util.PrimitiveIterator<java.lang.Long,java.util.function.LongConsumer> {
    method public default void forEachRemaining(java.util.function.LongConsumer);
    method public default void forEachRemaining(java.util.function.Consumer<? super java.lang.Long>);
    method public default Long next();
    method public long nextLong();
  }

  public class PriorityQueue<E> extends java.util.AbstractQueue<E> implements java.io.Serializable {
    ctor public PriorityQueue();
    ctor public PriorityQueue(int);
    ctor public PriorityQueue(java.util.Comparator<? super E>);
    ctor public PriorityQueue(int, java.util.Comparator<? super E>);
    ctor public PriorityQueue(java.util.Collection<? extends E>);
    ctor public PriorityQueue(java.util.PriorityQueue<? extends E>);
    ctor public PriorityQueue(java.util.SortedSet<? extends E>);
    method public java.util.Comparator<? super E> comparator();
    method public void forEach(java.util.function.Consumer<? super E>);
    method public java.util.Iterator<E> iterator();
    method public boolean offer(E);
    method public E peek();
    method public E poll();
    method public boolean removeIf(java.util.function.Predicate<? super E>);
    method public int size();
    method public final java.util.Spliterator<E> spliterator();
  }

  public class Properties extends java.util.Hashtable<java.lang.Object,java.lang.Object> {
    ctor public Properties();
    ctor @FlaggedApi("com.android.libcore.v_apis") public Properties(int);
    ctor public Properties(java.util.Properties);
    method public Object compute(Object, java.util.function.BiFunction<? super java.lang.Object,? super java.lang.Object,?>);
    method public Object computeIfAbsent(Object, java.util.function.Function<? super java.lang.Object,?>);
    method public Object computeIfPresent(Object, java.util.function.BiFunction<? super java.lang.Object,? super java.lang.Object,?>);
    method public java.util.Enumeration<java.lang.Object> elements();
    method public java.util.Set<java.util.Map.Entry<java.lang.Object,java.lang.Object>> entrySet();
    method public void forEach(java.util.function.BiConsumer<? super java.lang.Object,? super java.lang.Object>);
    method public Object get(Object);
    method public Object getOrDefault(Object, Object);
    method public String getProperty(String);
    method public String getProperty(String, String);
    method public java.util.Set<java.lang.Object> keySet();
    method public java.util.Enumeration<java.lang.Object> keys();
    method public void list(java.io.PrintStream);
    method public void list(java.io.PrintWriter);
    method public void load(java.io.Reader) throws java.io.IOException;
    method public void load(java.io.InputStream) throws java.io.IOException;
    method public void loadFromXML(java.io.InputStream) throws java.io.IOException, java.util.InvalidPropertiesFormatException;
    method public Object merge(Object, Object, java.util.function.BiFunction<? super java.lang.Object,? super java.lang.Object,?>);
    method public java.util.Enumeration<?> propertyNames();
    method public Object put(Object, Object);
    method public void putAll(java.util.Map<?,?>);
    method public Object putIfAbsent(Object, Object);
    method public Object remove(Object);
    method public boolean replace(Object, Object, Object);
    method public Object replace(Object, Object);
    method public void replaceAll(java.util.function.BiFunction<? super java.lang.Object,? super java.lang.Object,?>);
    method @Deprecated public void save(java.io.OutputStream, String);
    method public Object setProperty(String, String);
    method public void store(java.io.Writer, String) throws java.io.IOException;
    method public void store(java.io.OutputStream, String) throws java.io.IOException;
    method public void storeToXML(java.io.OutputStream, String) throws java.io.IOException;
    method public void storeToXML(java.io.OutputStream, String, String) throws java.io.IOException;
    method @FlaggedApi("com.android.libcore.v_apis") public void storeToXML(java.io.OutputStream, String, java.nio.charset.Charset) throws java.io.IOException;
    method public java.util.Set<java.lang.String> stringPropertyNames();
    method public java.util.Collection<java.lang.Object> values();
    field protected volatile java.util.Properties defaults;
  }

  public final class PropertyPermission extends java.security.BasicPermission {
    ctor public PropertyPermission(String, String);
  }

  public class PropertyResourceBundle extends java.util.ResourceBundle {
    ctor public PropertyResourceBundle(java.io.InputStream) throws java.io.IOException;
    ctor public PropertyResourceBundle(java.io.Reader) throws java.io.IOException;
    method public java.util.Enumeration<java.lang.String> getKeys();
    method public Object handleGetObject(String);
  }

  public interface Queue<E> extends java.util.Collection<E> {
    method public E element();
    method public boolean offer(E);
    method @Nullable public E peek();
    method @Nullable public E poll();
    method public E remove();
  }

  public class Random implements java.util.random.RandomGenerator java.io.Serializable {
    ctor public Random();
    ctor public Random(long);
    method public java.util.stream.DoubleStream doubles(long);
    method public java.util.stream.DoubleStream doubles();
    method public java.util.stream.DoubleStream doubles(long, double, double);
    method public java.util.stream.DoubleStream doubles(double, double);
    method public java.util.stream.IntStream ints(long);
    method public java.util.stream.IntStream ints();
    method public java.util.stream.IntStream ints(long, int, int);
    method public java.util.stream.IntStream ints(int, int);
    method public java.util.stream.LongStream longs(long);
    method public java.util.stream.LongStream longs();
    method public java.util.stream.LongStream longs(long, long, long);
    method public java.util.stream.LongStream longs(long, long);
    method protected int next(int);
    method public boolean nextBoolean();
    method public void nextBytes(byte[]);
    method public double nextDouble();
    method public float nextFloat();
    method public double nextGaussian();
    method public int nextInt();
    method public int nextInt(int);
    method public long nextLong();
    method public void setSeed(long);
  }

  public interface RandomAccess {
  }

  public abstract class ResourceBundle {
    ctor public ResourceBundle();
    method public static final void clearCache();
    method public static final void clearCache(ClassLoader);
    method public boolean containsKey(String);
    method public String getBaseBundleName();
    method public static final java.util.ResourceBundle getBundle(String);
    method public static final java.util.ResourceBundle getBundle(String, java.util.ResourceBundle.Control);
    method public static final java.util.ResourceBundle getBundle(String, java.util.Locale);
    method public static final java.util.ResourceBundle getBundle(String, java.util.Locale, java.util.ResourceBundle.Control);
    method public static java.util.ResourceBundle getBundle(String, java.util.Locale, ClassLoader);
    method public static java.util.ResourceBundle getBundle(String, java.util.Locale, ClassLoader, java.util.ResourceBundle.Control);
    method public abstract java.util.Enumeration<java.lang.String> getKeys();
    method public java.util.Locale getLocale();
    method public final Object getObject(String);
    method public final String getString(String);
    method public final String[] getStringArray(String);
    method protected abstract Object handleGetObject(String);
    method protected java.util.Set<java.lang.String> handleKeySet();
    method public java.util.Set<java.lang.String> keySet();
    method protected void setParent(java.util.ResourceBundle);
    field protected java.util.ResourceBundle parent;
  }

  public static class ResourceBundle.Control {
    ctor protected ResourceBundle.Control();
    method public java.util.List<java.util.Locale> getCandidateLocales(String, java.util.Locale);
    method public static final java.util.ResourceBundle.Control getControl(java.util.List<java.lang.String>);
    method public java.util.Locale getFallbackLocale(String, java.util.Locale);
    method public java.util.List<java.lang.String> getFormats(String);
    method public static final java.util.ResourceBundle.Control getNoFallbackControl(java.util.List<java.lang.String>);
    method public long getTimeToLive(String, java.util.Locale);
    method public boolean needsReload(String, java.util.Locale, String, ClassLoader, java.util.ResourceBundle, long);
    method public java.util.ResourceBundle newBundle(String, java.util.Locale, String, ClassLoader, boolean) throws java.io.IOException, java.lang.IllegalAccessException, java.lang.InstantiationException;
    method public String toBundleName(String, java.util.Locale);
    method public final String toResourceName(String, String);
    field public static final java.util.List<java.lang.String> FORMAT_CLASS;
    field public static final java.util.List<java.lang.String> FORMAT_DEFAULT;
    field public static final java.util.List<java.lang.String> FORMAT_PROPERTIES;
    field public static final long TTL_DONT_CACHE = -1L; // 0xffffffffffffffffL
    field public static final long TTL_NO_EXPIRATION_CONTROL = -2L; // 0xfffffffffffffffeL
  }

  public final class Scanner implements java.io.Closeable java.util.Iterator<java.lang.String> {
    ctor public Scanner(Readable);
    ctor public Scanner(java.io.InputStream);
    ctor public Scanner(java.io.InputStream, String);
    ctor public Scanner(java.io.InputStream, java.nio.charset.Charset);
    ctor public Scanner(java.io.File) throws java.io.FileNotFoundException;
    ctor public Scanner(java.io.File, String) throws java.io.FileNotFoundException;
    ctor public Scanner(java.io.File, java.nio.charset.Charset) throws java.io.IOException;
    ctor public Scanner(java.nio.file.Path) throws java.io.IOException;
    ctor public Scanner(java.nio.file.Path, String) throws java.io.IOException;
    ctor public Scanner(java.nio.file.Path, java.nio.charset.Charset) throws java.io.IOException;
    ctor public Scanner(String);
    ctor public Scanner(java.nio.channels.ReadableByteChannel);
    ctor public Scanner(java.nio.channels.ReadableByteChannel, String);
    ctor public Scanner(java.nio.channels.ReadableByteChannel, java.nio.charset.Charset);
    method public void close();
    method public java.util.regex.Pattern delimiter();
    method public java.util.stream.Stream<java.util.regex.MatchResult> findAll(java.util.regex.Pattern);
    method public java.util.stream.Stream<java.util.regex.MatchResult> findAll(String);
    method public String findInLine(String);
    method public String findInLine(java.util.regex.Pattern);
    method public String findWithinHorizon(String, int);
    method public String findWithinHorizon(java.util.regex.Pattern, int);
    method public boolean hasNext();
    method public boolean hasNext(String);
    method public boolean hasNext(java.util.regex.Pattern);
    method public boolean hasNextBigDecimal();
    method public boolean hasNextBigInteger();
    method public boolean hasNextBigInteger(int);
    method public boolean hasNextBoolean();
    method public boolean hasNextByte();
    method public boolean hasNextByte(int);
    method public boolean hasNextDouble();
    method public boolean hasNextFloat();
    method public boolean hasNextInt();
    method public boolean hasNextInt(int);
    method public boolean hasNextLine();
    method public boolean hasNextLong();
    method public boolean hasNextLong(int);
    method public boolean hasNextShort();
    method public boolean hasNextShort(int);
    method public java.io.IOException ioException();
    method public java.util.Locale locale();
    method public java.util.regex.MatchResult match();
    method public String next();
    method public String next(String);
    method public String next(java.util.regex.Pattern);
    method public java.math.BigDecimal nextBigDecimal();
    method public java.math.BigInteger nextBigInteger();
    method public java.math.BigInteger nextBigInteger(int);
    method public boolean nextBoolean();
    method public byte nextByte();
    method public byte nextByte(int);
    method public double nextDouble();
    method public float nextFloat();
    method public int nextInt();
    method public int nextInt(int);
    method public String nextLine();
    method public long nextLong();
    method public long nextLong(int);
    method public short nextShort();
    method public short nextShort(int);
    method public int radix();
    method public void remove();
    method public java.util.Scanner reset();
    method public java.util.Scanner skip(java.util.regex.Pattern);
    method public java.util.Scanner skip(String);
    method public java.util.stream.Stream<java.lang.String> tokens();
    method public java.util.Scanner useDelimiter(java.util.regex.Pattern);
    method public java.util.Scanner useDelimiter(String);
    method public java.util.Scanner useLocale(java.util.Locale);
    method public java.util.Scanner useRadix(int);
  }

  public class ServiceConfigurationError extends java.lang.Error {
    ctor public ServiceConfigurationError(String);
    ctor public ServiceConfigurationError(String, Throwable);
  }

  public final class ServiceLoader<S> implements java.lang.Iterable<S> {
    method public java.util.Optional<S> findFirst();
    method public java.util.Iterator<S> iterator();
    method public static <S> java.util.ServiceLoader<S> load(Class<S>, ClassLoader);
    method public static <S> java.util.ServiceLoader<S> load(Class<S>);
    method public static <S> java.util.ServiceLoader<S> loadInstalled(Class<S>);
    method public void reload();
    method @FlaggedApi("com.android.libcore.v_apis") public java.util.stream.Stream<java.util.ServiceLoader.Provider<S>> stream();
  }

  @FlaggedApi("com.android.libcore.v_apis") public static interface ServiceLoader.Provider<S> extends java.util.function.Supplier<S> {
    method public S get();
    method public Class<? extends S> type();
  }

  public interface Set<E> extends java.util.Collection<E> {
    method @NonNull public static <E> java.util.Set<E> copyOf(@NonNull java.util.Collection<? extends E>);
    method @NonNull public static <E> java.util.Set<E> of();
    method @NonNull public static <E> java.util.Set<E> of(@NonNull E);
    method @NonNull public static <E> java.util.Set<E> of(@NonNull E, @NonNull E);
    method @NonNull public static <E> java.util.Set<E> of(@NonNull E, @NonNull E, @NonNull E);
    method @NonNull public static <E> java.util.Set<E> of(@NonNull E, @NonNull E, @NonNull E, @NonNull E);
    method @NonNull public static <E> java.util.Set<E> of(@NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E);
    method @NonNull public static <E> java.util.Set<E> of(@NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E);
    method @NonNull public static <E> java.util.Set<E> of(@NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E);
    method @NonNull public static <E> java.util.Set<E> of(@NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E);
    method @NonNull public static <E> java.util.Set<E> of(@NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E);
    method @NonNull public static <E> java.util.Set<E> of(@NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E, @NonNull E);
    method @NonNull @java.lang.SafeVarargs public static <E> java.util.Set<E> of(@NonNull E...);
  }

  public class SimpleTimeZone extends java.util.TimeZone {
    ctor public SimpleTimeZone(int, String);
    ctor public SimpleTimeZone(int, String, int, int, int, int, int, int, int, int);
    ctor public SimpleTimeZone(int, String, int, int, int, int, int, int, int, int, int);
    ctor public SimpleTimeZone(int, String, int, int, int, int, int, int, int, int, int, int, int);
    method public int getOffset(int, int, int, int, int, int);
    method public int getRawOffset();
    method public boolean inDaylightTime(java.util.Date);
    method public void setDSTSavings(int);
    method public void setEndRule(int, int, int, int);
    method public void setEndRule(int, int, int);
    method public void setEndRule(int, int, int, int, boolean);
    method public void setRawOffset(int);
    method public void setStartRule(int, int, int, int);
    method public void setStartRule(int, int, int);
    method public void setStartRule(int, int, int, int, boolean);
    method public void setStartYear(int);
    method public boolean useDaylightTime();
    field public static final int STANDARD_TIME = 1; // 0x1
    field public static final int UTC_TIME = 2; // 0x2
    field public static final int WALL_TIME = 0; // 0x0
  }

  public interface SortedMap<K, V> extends java.util.Map<K,V> {
    method @Nullable public java.util.Comparator<? super K> comparator();
    method public K firstKey();
    method @NonNull public java.util.SortedMap<K,V> headMap(K);
    method public K lastKey();
    method @NonNull public java.util.SortedMap<K,V> subMap(K, K);
    method @NonNull public java.util.SortedMap<K,V> tailMap(K);
  }

  public interface SortedSet<E> extends java.util.Set<E> {
    method public java.util.Comparator<? super E> comparator();
    method public E first();
    method public java.util.SortedSet<E> headSet(E);
    method public E last();
    method public java.util.SortedSet<E> subSet(E, E);
    method public java.util.SortedSet<E> tailSet(E);
  }

  public interface Spliterator<T> {
    method public int characteristics();
    method public long estimateSize();
    method public default void forEachRemaining(java.util.function.Consumer<? super T>);
    method public default java.util.Comparator<? super T> getComparator();
    method public default long getExactSizeIfKnown();
    method public default boolean hasCharacteristics(int);
    method public boolean tryAdvance(java.util.function.Consumer<? super T>);
    method public java.util.Spliterator<T> trySplit();
    field public static final int CONCURRENT = 4096; // 0x1000
    field public static final int DISTINCT = 1; // 0x1
    field public static final int IMMUTABLE = 1024; // 0x400
    field public static final int NONNULL = 256; // 0x100
    field public static final int ORDERED = 16; // 0x10
    field public static final int SIZED = 64; // 0x40
    field public static final int SORTED = 4; // 0x4
    field public static final int SUBSIZED = 16384; // 0x4000
  }

  public static interface Spliterator.OfDouble extends java.util.Spliterator.OfPrimitive<java.lang.Double,java.util.function.DoubleConsumer,java.util.Spliterator.OfDouble> {
    method public default void forEachRemaining(java.util.function.DoubleConsumer);
    method public default void forEachRemaining(java.util.function.Consumer<? super java.lang.Double>);
    method public boolean tryAdvance(java.util.function.DoubleConsumer);
    method public default boolean tryAdvance(java.util.function.Consumer<? super java.lang.Double>);
    method public java.util.Spliterator.OfDouble trySplit();
  }

  public static interface Spliterator.OfInt extends java.util.Spliterator.OfPrimitive<java.lang.Integer,java.util.function.IntConsumer,java.util.Spliterator.OfInt> {
    method public default void forEachRemaining(java.util.function.IntConsumer);
    method public default void forEachRemaining(java.util.function.Consumer<? super java.lang.Integer>);
    method public boolean tryAdvance(java.util.function.IntConsumer);
    method public default boolean tryAdvance(java.util.function.Consumer<? super java.lang.Integer>);
    method public java.util.Spliterator.OfInt trySplit();
  }

  public static interface Spliterator.OfLong extends java.util.Spliterator.OfPrimitive<java.lang.Long,java.util.function.LongConsumer,java.util.Spliterator.OfLong> {
    method public default void forEachRemaining(java.util.function.LongConsumer);
    method public default void forEachRemaining(java.util.function.Consumer<? super java.lang.Long>);
    method public boolean tryAdvance(java.util.function.LongConsumer);
    method public default boolean tryAdvance(java.util.function.Consumer<? super java.lang.Long>);
    method public java.util.Spliterator.OfLong trySplit();
  }

  public static interface Spliterator.OfPrimitive<T, T_CONS, T_SPLITR extends java.util.Spliterator.OfPrimitive<T, T_CONS, T_SPLITR>> extends java.util.Spliterator<T> {
    method public default void forEachRemaining(T_CONS);
    method public boolean tryAdvance(T_CONS);
    method public T_SPLITR trySplit();
  }

  public final class Spliterators {
    method public static java.util.Spliterator.OfDouble emptyDoubleSpliterator();
    method public static java.util.Spliterator.OfInt emptyIntSpliterator();
    method public static java.util.Spliterator.OfLong emptyLongSpliterator();
    method public static <T> java.util.Spliterator<T> emptySpliterator();
    method public static <T> java.util.Iterator<T> iterator(java.util.Spliterator<? extends T>);
    method public static java.util.PrimitiveIterator.OfInt iterator(java.util.Spliterator.OfInt);
    method public static java.util.PrimitiveIterator.OfLong iterator(java.util.Spliterator.OfLong);
    method public static java.util.PrimitiveIterator.OfDouble iterator(java.util.Spliterator.OfDouble);
    method public static <T> java.util.Spliterator<T> spliterator(Object[], int);
    method public static <T> java.util.Spliterator<T> spliterator(Object[], int, int, int);
    method public static java.util.Spliterator.OfInt spliterator(int[], int);
    method public static java.util.Spliterator.OfInt spliterator(int[], int, int, int);
    method public static java.util.Spliterator.OfLong spliterator(long[], int);
    method public static java.util.Spliterator.OfLong spliterator(long[], int, int, int);
    method public static java.util.Spliterator.OfDouble spliterator(double[], int);
    method public static java.util.Spliterator.OfDouble spliterator(double[], int, int, int);
    method public static <T> java.util.Spliterator<T> spliterator(java.util.Collection<? extends T>, int);
    method public static <T> java.util.Spliterator<T> spliterator(java.util.Iterator<? extends T>, long, int);
    method public static java.util.Spliterator.OfInt spliterator(java.util.PrimitiveIterator.OfInt, long, int);
    method public static java.util.Spliterator.OfLong spliterator(java.util.PrimitiveIterator.OfLong, long, int);
    method public static java.util.Spliterator.OfDouble spliterator(java.util.PrimitiveIterator.OfDouble, long, int);
    method public static <T> java.util.Spliterator<T> spliteratorUnknownSize(java.util.Iterator<? extends T>, int);
    method public static java.util.Spliterator.OfInt spliteratorUnknownSize(java.util.PrimitiveIterator.OfInt, int);
    method public static java.util.Spliterator.OfLong spliteratorUnknownSize(java.util.PrimitiveIterator.OfLong, int);
    method public static java.util.Spliterator.OfDouble spliteratorUnknownSize(java.util.PrimitiveIterator.OfDouble, int);
  }

  public abstract static class Spliterators.AbstractDoubleSpliterator implements java.util.Spliterator.OfDouble {
    ctor protected Spliterators.AbstractDoubleSpliterator(long, int);
    method public int characteristics();
    method public long estimateSize();
    method public java.util.Spliterator.OfDouble trySplit();
  }

  public abstract static class Spliterators.AbstractIntSpliterator implements java.util.Spliterator.OfInt {
    ctor protected Spliterators.AbstractIntSpliterator(long, int);
    method public int characteristics();
    method public long estimateSize();
    method public java.util.Spliterator.OfInt trySplit();
  }

  public abstract static class Spliterators.AbstractLongSpliterator implements java.util.Spliterator.OfLong {
    ctor protected Spliterators.AbstractLongSpliterator(long, int);
    method public int characteristics();
    method public long estimateSize();
    method public java.util.Spliterator.OfLong trySplit();
  }

  public abstract static class Spliterators.AbstractSpliterator<T> implements java.util.Spliterator<T> {
    ctor protected Spliterators.AbstractSpliterator(long, int);
    method public int characteristics();
    method public long estimateSize();
    method public java.util.Spliterator<T> trySplit();
  }

  public final class SplittableRandom implements java.util.random.RandomGenerator java.util.random.RandomGenerator.SplittableGenerator {
    ctor public SplittableRandom(long);
    ctor public SplittableRandom();
    method public java.util.stream.DoubleStream doubles(long);
    method public java.util.stream.DoubleStream doubles();
    method public java.util.stream.DoubleStream doubles(long, double, double);
    method public java.util.stream.DoubleStream doubles(double, double);
    method public java.util.stream.IntStream ints(long);
    method public java.util.stream.IntStream ints();
    method public java.util.stream.IntStream ints(long, int, int);
    method public java.util.stream.IntStream ints(int, int);
    method public java.util.stream.LongStream longs(long);
    method public java.util.stream.LongStream longs();
    method public java.util.stream.LongStream longs(long, long, long);
    method public java.util.stream.LongStream longs(long, long);
    method public void nextBytes(byte[]);
    method public int nextInt();
    method public long nextLong();
    method public java.util.SplittableRandom split();
    method @FlaggedApi("com.android.libcore.v_apis") public java.util.SplittableRandom split(java.util.random.RandomGenerator.SplittableGenerator);
    method @FlaggedApi("com.android.libcore.v_apis") public java.util.stream.Stream<java.util.random.RandomGenerator.SplittableGenerator> splits();
    method @FlaggedApi("com.android.libcore.v_apis") public java.util.stream.Stream<java.util.random.RandomGenerator.SplittableGenerator> splits(long);
    method @FlaggedApi("com.android.libcore.v_apis") public java.util.stream.Stream<java.util.random.RandomGenerator.SplittableGenerator> splits(java.util.random.RandomGenerator.SplittableGenerator);
    method @FlaggedApi("com.android.libcore.v_apis") public java.util.stream.Stream<java.util.random.RandomGenerator.SplittableGenerator> splits(long, java.util.random.RandomGenerator.SplittableGenerator);
  }

  public class Stack<E> extends java.util.Vector<E> {
    ctor public Stack();
    method public boolean empty();
    method public E peek();
    method public E pop();
    method public E push(E);
    method public int search(Object);
  }

  public final class StringJoiner {
    ctor public StringJoiner(CharSequence);
    ctor public StringJoiner(CharSequence, CharSequence, CharSequence);
    method public java.util.StringJoiner add(CharSequence);
    method public int length();
    method public java.util.StringJoiner merge(java.util.StringJoiner);
    method public java.util.StringJoiner setEmptyValue(CharSequence);
  }

  public class StringTokenizer implements java.util.Enumeration<java.lang.Object> {
    ctor public StringTokenizer(String, String, boolean);
    ctor public StringTokenizer(String, String);
    ctor public StringTokenizer(String);
    method public int countTokens();
    method public boolean hasMoreElements();
    method public boolean hasMoreTokens();
    method public Object nextElement();
    method public String nextToken();
    method public String nextToken(String);
  }

  public abstract class TimeZone implements java.lang.Cloneable java.io.Serializable {
    ctor public TimeZone();
    method public Object clone();
    method public static String[] getAvailableIDs(int);
    method public static String[] getAvailableIDs();
    method public int getDSTSavings();
    method public static java.util.TimeZone getDefault();
    method public final String getDisplayName();
    method public final String getDisplayName(java.util.Locale);
    method public final String getDisplayName(boolean, int);
    method public String getDisplayName(boolean, int, java.util.Locale);
    method public String getID();
    method public abstract int getOffset(int, int, int, int, int, int);
    method public int getOffset(long);
    method public abstract int getRawOffset();
    method public static java.util.TimeZone getTimeZone(String);
    method public static java.util.TimeZone getTimeZone(java.time.ZoneId);
    method public boolean hasSameRules(java.util.TimeZone);
    method public abstract boolean inDaylightTime(java.util.Date);
    method public boolean observesDaylightTime();
    method public static void setDefault(java.util.TimeZone);
    method public void setID(String);
    method public abstract void setRawOffset(int);
    method public java.time.ZoneId toZoneId();
    method public abstract boolean useDaylightTime();
    field public static final int LONG = 1; // 0x1
    field public static final int SHORT = 0; // 0x0
  }

  public class Timer {
    ctor public Timer();
    ctor public Timer(boolean);
    ctor public Timer(String);
    ctor public Timer(String, boolean);
    method public void cancel();
    method public int purge();
    method public void schedule(java.util.TimerTask, long);
    method public void schedule(java.util.TimerTask, java.util.Date);
    method public void schedule(java.util.TimerTask, long, long);
    method public void schedule(java.util.TimerTask, java.util.Date, long);
    method public void scheduleAtFixedRate(java.util.TimerTask, long, long);
    method public void scheduleAtFixedRate(java.util.TimerTask, java.util.Date, long);
  }

  public abstract class TimerTask implements java.lang.Runnable {
    ctor protected TimerTask();
    method public boolean cancel();
    method public long scheduledExecutionTime();
  }

  public class TooManyListenersException extends java.lang.Exception {
    ctor public TooManyListenersException();
    ctor public TooManyListenersException(String);
  }

  public class TreeMap<K, V> extends java.util.AbstractMap<K,V> implements java.lang.Cloneable java.util.NavigableMap<K,V> java.io.Serializable {
    ctor public TreeMap();
    ctor public TreeMap(@Nullable java.util.Comparator<? super K>);
    ctor public TreeMap(@NonNull java.util.Map<? extends K,? extends V>);
    ctor public TreeMap(@NonNull java.util.SortedMap<K,? extends V>);
    method @Nullable public java.util.Map.Entry<K,V> ceilingEntry(K);
    method @Nullable public K ceilingKey(K);
    method @NonNull public Object clone();
    method @Nullable public java.util.Comparator<? super K> comparator();
    method @Nullable public V compute(K, @NonNull java.util.function.BiFunction<? super K,? super V,? extends V>);
    method @Nullable public V computeIfAbsent(K, @NonNull java.util.function.Function<? super K,? extends V>);
    method @Nullable public V computeIfPresent(K, @NonNull java.util.function.BiFunction<? super K,? super V,? extends V>);
    method @NonNull public java.util.NavigableSet<K> descendingKeySet();
    method @NonNull public java.util.NavigableMap<K,V> descendingMap();
    method @NonNull public java.util.Set<java.util.Map.Entry<K,V>> entrySet();
    method @Nullable public java.util.Map.Entry<K,V> firstEntry();
    method public K firstKey();
    method @Nullable public java.util.Map.Entry<K,V> floorEntry(K);
    method @Nullable public K floorKey(K);
    method public void forEach(@NonNull java.util.function.BiConsumer<? super K,? super V>);
    method @NonNull public java.util.NavigableMap<K,V> headMap(K, boolean);
    method @NonNull public java.util.SortedMap<K,V> headMap(K);
    method @Nullable public java.util.Map.Entry<K,V> higherEntry(K);
    method @Nullable public K higherKey(K);
    method @Nullable public java.util.Map.Entry<K,V> lastEntry();
    method public K lastKey();
    method @Nullable public java.util.Map.Entry<K,V> lowerEntry(K);
    method @Nullable public K lowerKey(K);
    method @Nullable public V merge(K, @NonNull V, @NonNull java.util.function.BiFunction<? super V,? super V,? extends V>);
    method @NonNull public java.util.NavigableSet<K> navigableKeySet();
    method @Nullable public java.util.Map.Entry<K,V> pollFirstEntry();
    method @Nullable public java.util.Map.Entry<K,V> pollLastEntry();
    method @Nullable public V putIfAbsent(K, V);
    method public boolean replace(K, @Nullable V, V);
    method public V replace(K, V);
    method public void replaceAll(@NonNull java.util.function.BiFunction<? super K,? super V,? extends V>);
    method @NonNull public java.util.NavigableMap<K,V> subMap(K, boolean, K, boolean);
    method @NonNull public java.util.SortedMap<K,V> subMap(K, K);
    method @NonNull public java.util.NavigableMap<K,V> tailMap(K, boolean);
    method @NonNull public java.util.SortedMap<K,V> tailMap(K);
  }

  public class TreeSet<E> extends java.util.AbstractSet<E> implements java.lang.Cloneable java.util.NavigableSet<E> java.io.Serializable {
    ctor public TreeSet();
    ctor public TreeSet(java.util.Comparator<? super E>);
    ctor public TreeSet(java.util.Collection<? extends E>);
    ctor public TreeSet(java.util.SortedSet<E>);
    method public E ceiling(E);
    method public Object clone();
    method public java.util.Comparator<? super E> comparator();
    method public java.util.Iterator<E> descendingIterator();
    method public java.util.NavigableSet<E> descendingSet();
    method public E first();
    method public E floor(E);
    method public java.util.NavigableSet<E> headSet(E, boolean);
    method public java.util.SortedSet<E> headSet(E);
    method public E higher(E);
    method public java.util.Iterator<E> iterator();
    method public E last();
    method public E lower(E);
    method public E pollFirst();
    method public E pollLast();
    method public int size();
    method public java.util.Spliterator<E> spliterator();
    method public java.util.NavigableSet<E> subSet(E, boolean, E, boolean);
    method public java.util.SortedSet<E> subSet(E, E);
    method public java.util.NavigableSet<E> tailSet(E, boolean);
    method public java.util.SortedSet<E> tailSet(E);
  }

  public final class UUID implements java.lang.Comparable<java.util.UUID> java.io.Serializable {
    ctor public UUID(long, long);
    method public int clockSequence();
    method public int compareTo(java.util.UUID);
    method public static java.util.UUID fromString(String);
    method public long getLeastSignificantBits();
    method public long getMostSignificantBits();
    method public static java.util.UUID nameUUIDFromBytes(byte[]);
    method public long node();
    method public static java.util.UUID randomUUID();
    method public long timestamp();
    method public int variant();
    method public int version();
  }

  public class UnknownFormatConversionException extends java.util.IllegalFormatException {
    ctor public UnknownFormatConversionException(String);
    method public String getConversion();
  }

  public class UnknownFormatFlagsException extends java.util.IllegalFormatException {
    ctor public UnknownFormatFlagsException(String);
    method public String getFlags();
  }

  public class Vector<E> extends java.util.AbstractList<E> implements java.lang.Cloneable java.util.List<E> java.util.RandomAccess java.io.Serializable {
    ctor public Vector(int, int);
    ctor public Vector(int);
    ctor public Vector();
    ctor public Vector(@NonNull java.util.Collection<? extends E>);
    method public void addElement(E);
    method public int capacity();
    method @NonNull public Object clone();
    method public void copyInto(@NonNull Object[]);
    method public E elementAt(int);
    method @NonNull public java.util.Enumeration<E> elements();
    method public void ensureCapacity(int);
    method public E firstElement();
    method public void forEach(@NonNull java.util.function.Consumer<? super E>);
    method public E get(int);
    method public int indexOf(@Nullable Object, int);
    method public void insertElementAt(E, int);
    method public E lastElement();
    method public int lastIndexOf(@Nullable Object, int);
    method public void removeAllElements();
    method public boolean removeElement(@Nullable Object);
    method public void removeElementAt(int);
    method public boolean removeIf(@NonNull java.util.function.Predicate<? super E>);
    method public void replaceAll(@NonNull java.util.function.UnaryOperator<E>);
    method public void setElementAt(E, int);
    method public void setSize(int);
    method public int size();
    method public void sort(@Nullable java.util.Comparator<? super E>);
    method @NonNull public java.util.Spliterator<E> spliterator();
    method public void trimToSize();
    field protected int capacityIncrement;
    field protected int elementCount;
    field @NonNull protected Object[] elementData;
  }

  public class WeakHashMap<K, V> extends java.util.AbstractMap<K,V> implements java.util.Map<K,V> {
    ctor public WeakHashMap(int, float);
    ctor public WeakHashMap(int);
    ctor public WeakHashMap();
    ctor public WeakHashMap(@NonNull java.util.Map<? extends K,? extends V>);
    method @NonNull public java.util.Set<java.util.Map.Entry<K,V>> entrySet();
    method public void forEach(@NonNull java.util.function.BiConsumer<? super K,? super V>);
    method public void replaceAll(@NonNull java.util.function.BiFunction<? super K,? super V,? extends V>);
  }

}

package java.util.concurrent {

  public abstract class AbstractExecutorService implements java.util.concurrent.ExecutorService {
    ctor public AbstractExecutorService();
    method public <T> java.util.List<java.util.concurrent.Future<T>> invokeAll(java.util.Collection<? extends java.util.concurrent.Callable<T>>) throws java.lang.InterruptedException;
    method public <T> java.util.List<java.util.concurrent.Future<T>> invokeAll(java.util.Collection<? extends java.util.concurrent.Callable<T>>, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public <T> T invokeAny(java.util.Collection<? extends java.util.concurrent.Callable<T>>) throws java.util.concurrent.ExecutionException, java.lang.InterruptedException;
    method public <T> T invokeAny(java.util.Collection<? extends java.util.concurrent.Callable<T>>, long, java.util.concurrent.TimeUnit) throws java.util.concurrent.ExecutionException, java.lang.InterruptedException, java.util.concurrent.TimeoutException;
    method protected <T> java.util.concurrent.RunnableFuture<T> newTaskFor(Runnable, T);
    method protected <T> java.util.concurrent.RunnableFuture<T> newTaskFor(java.util.concurrent.Callable<T>);
    method public java.util.concurrent.Future<?> submit(Runnable);
    method public <T> java.util.concurrent.Future<T> submit(Runnable, T);
    method public <T> java.util.concurrent.Future<T> submit(java.util.concurrent.Callable<T>);
  }

  public class ArrayBlockingQueue<E> extends java.util.AbstractQueue<E> implements java.util.concurrent.BlockingQueue<E> java.io.Serializable {
    ctor public ArrayBlockingQueue(int);
    ctor public ArrayBlockingQueue(int, boolean);
    ctor public ArrayBlockingQueue(int, boolean, java.util.Collection<? extends E>);
    method public int drainTo(java.util.Collection<? super E>);
    method public int drainTo(java.util.Collection<? super E>, int);
    method public void forEach(java.util.function.Consumer<? super E>);
    method public java.util.Iterator<E> iterator();
    method public boolean offer(E);
    method public boolean offer(E, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public E peek();
    method public E poll();
    method public E poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public void put(E) throws java.lang.InterruptedException;
    method public int remainingCapacity();
    method public boolean removeIf(java.util.function.Predicate<? super E>);
    method public int size();
    method public java.util.Spliterator<E> spliterator();
    method public E take() throws java.lang.InterruptedException;
  }

  public interface BlockingDeque<E> extends java.util.concurrent.BlockingQueue<E> java.util.Deque<E> {
    method public boolean add(E);
    method public boolean contains(Object);
    method public E element();
    method public java.util.Iterator<E> iterator();
    method public boolean offer(E);
    method public boolean offerFirst(E, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public boolean offerLast(E, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public E peek();
    method public E poll();
    method public E pollFirst(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public E pollLast(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public void putFirst(E) throws java.lang.InterruptedException;
    method public void putLast(E) throws java.lang.InterruptedException;
    method public E remove();
    method public boolean remove(Object);
    method public int size();
    method public E takeFirst() throws java.lang.InterruptedException;
    method public E takeLast() throws java.lang.InterruptedException;
  }

  public interface BlockingQueue<E> extends java.util.Queue<E> {
    method public int drainTo(java.util.Collection<? super E>);
    method public int drainTo(java.util.Collection<? super E>, int);
    method public boolean offer(E, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public E poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public void put(E) throws java.lang.InterruptedException;
    method public int remainingCapacity();
    method public E take() throws java.lang.InterruptedException;
  }

  public class BrokenBarrierException extends java.lang.Exception {
    ctor public BrokenBarrierException();
    ctor public BrokenBarrierException(String);
  }

  @java.lang.FunctionalInterface public interface Callable<V> {
    method public V call() throws java.lang.Exception;
  }

  public class CancellationException extends java.lang.IllegalStateException {
    ctor public CancellationException();
    ctor public CancellationException(String);
  }

  public class CompletableFuture<T> implements java.util.concurrent.CompletionStage<T> java.util.concurrent.Future<T> {
    ctor public CompletableFuture();
    method public java.util.concurrent.CompletableFuture<java.lang.Void> acceptEither(java.util.concurrent.CompletionStage<? extends T>, java.util.function.Consumer<? super T>);
    method public java.util.concurrent.CompletableFuture<java.lang.Void> acceptEitherAsync(java.util.concurrent.CompletionStage<? extends T>, java.util.function.Consumer<? super T>);
    method public java.util.concurrent.CompletableFuture<java.lang.Void> acceptEitherAsync(java.util.concurrent.CompletionStage<? extends T>, java.util.function.Consumer<? super T>, java.util.concurrent.Executor);
    method public static java.util.concurrent.CompletableFuture<java.lang.Void> allOf(java.util.concurrent.CompletableFuture<?>...);
    method public static java.util.concurrent.CompletableFuture<java.lang.Object> anyOf(java.util.concurrent.CompletableFuture<?>...);
    method public <U> java.util.concurrent.CompletableFuture<U> applyToEither(java.util.concurrent.CompletionStage<? extends T>, java.util.function.Function<? super T,U>);
    method public <U> java.util.concurrent.CompletableFuture<U> applyToEitherAsync(java.util.concurrent.CompletionStage<? extends T>, java.util.function.Function<? super T,U>);
    method public <U> java.util.concurrent.CompletableFuture<U> applyToEitherAsync(java.util.concurrent.CompletionStage<? extends T>, java.util.function.Function<? super T,U>, java.util.concurrent.Executor);
    method public boolean cancel(boolean);
    method public boolean complete(T);
    method public java.util.concurrent.CompletableFuture<T> completeAsync(java.util.function.Supplier<? extends T>, java.util.concurrent.Executor);
    method public java.util.concurrent.CompletableFuture<T> completeAsync(java.util.function.Supplier<? extends T>);
    method public boolean completeExceptionally(Throwable);
    method public java.util.concurrent.CompletableFuture<T> completeOnTimeout(T, long, java.util.concurrent.TimeUnit);
    method public static <U> java.util.concurrent.CompletableFuture<U> completedFuture(U);
    method public static <U> java.util.concurrent.CompletionStage<U> completedStage(U);
    method public java.util.concurrent.CompletableFuture<T> copy();
    method public java.util.concurrent.Executor defaultExecutor();
    method public static java.util.concurrent.Executor delayedExecutor(long, java.util.concurrent.TimeUnit, java.util.concurrent.Executor);
    method public static java.util.concurrent.Executor delayedExecutor(long, java.util.concurrent.TimeUnit);
    method public java.util.concurrent.CompletableFuture<T> exceptionally(java.util.function.Function<java.lang.Throwable,? extends T>);
    method public java.util.concurrent.CompletableFuture<T> exceptionallyAsync(java.util.function.Function<java.lang.Throwable,? extends T>);
    method public java.util.concurrent.CompletableFuture<T> exceptionallyAsync(java.util.function.Function<java.lang.Throwable,? extends T>, java.util.concurrent.Executor);
    method public java.util.concurrent.CompletableFuture<T> exceptionallyCompose(java.util.function.Function<java.lang.Throwable,? extends java.util.concurrent.CompletionStage<T>>);
    method public java.util.concurrent.CompletableFuture<T> exceptionallyComposeAsync(java.util.function.Function<java.lang.Throwable,? extends java.util.concurrent.CompletionStage<T>>);
    method public java.util.concurrent.CompletableFuture<T> exceptionallyComposeAsync(java.util.function.Function<java.lang.Throwable,? extends java.util.concurrent.CompletionStage<T>>, java.util.concurrent.Executor);
    method public static <U> java.util.concurrent.CompletableFuture<U> failedFuture(Throwable);
    method public static <U> java.util.concurrent.CompletionStage<U> failedStage(Throwable);
    method public T get() throws java.util.concurrent.ExecutionException, java.lang.InterruptedException;
    method public T get(long, java.util.concurrent.TimeUnit) throws java.util.concurrent.ExecutionException, java.lang.InterruptedException, java.util.concurrent.TimeoutException;
    method public T getNow(T);
    method public int getNumberOfDependents();
    method public <U> java.util.concurrent.CompletableFuture<U> handle(java.util.function.BiFunction<? super T,java.lang.Throwable,? extends U>);
    method public <U> java.util.concurrent.CompletableFuture<U> handleAsync(java.util.function.BiFunction<? super T,java.lang.Throwable,? extends U>);
    method public <U> java.util.concurrent.CompletableFuture<U> handleAsync(java.util.function.BiFunction<? super T,java.lang.Throwable,? extends U>, java.util.concurrent.Executor);
    method public boolean isCancelled();
    method public boolean isCompletedExceptionally();
    method public boolean isDone();
    method public T join();
    method public java.util.concurrent.CompletionStage<T> minimalCompletionStage();
    method public <U> java.util.concurrent.CompletableFuture<U> newIncompleteFuture();
    method public void obtrudeException(Throwable);
    method public void obtrudeValue(T);
    method public java.util.concurrent.CompletableFuture<T> orTimeout(long, java.util.concurrent.TimeUnit);
    method public java.util.concurrent.CompletableFuture<java.lang.Void> runAfterBoth(java.util.concurrent.CompletionStage<?>, Runnable);
    method public java.util.concurrent.CompletableFuture<java.lang.Void> runAfterBothAsync(java.util.concurrent.CompletionStage<?>, Runnable);
    method public java.util.concurrent.CompletableFuture<java.lang.Void> runAfterBothAsync(java.util.concurrent.CompletionStage<?>, Runnable, java.util.concurrent.Executor);
    method public java.util.concurrent.CompletableFuture<java.lang.Void> runAfterEither(java.util.concurrent.CompletionStage<?>, Runnable);
    method public java.util.concurrent.CompletableFuture<java.lang.Void> runAfterEitherAsync(java.util.concurrent.CompletionStage<?>, Runnable);
    method public java.util.concurrent.CompletableFuture<java.lang.Void> runAfterEitherAsync(java.util.concurrent.CompletionStage<?>, Runnable, java.util.concurrent.Executor);
    method public static java.util.concurrent.CompletableFuture<java.lang.Void> runAsync(Runnable);
    method public static java.util.concurrent.CompletableFuture<java.lang.Void> runAsync(Runnable, java.util.concurrent.Executor);
    method public static <U> java.util.concurrent.CompletableFuture<U> supplyAsync(java.util.function.Supplier<U>);
    method public static <U> java.util.concurrent.CompletableFuture<U> supplyAsync(java.util.function.Supplier<U>, java.util.concurrent.Executor);
    method public java.util.concurrent.CompletableFuture<java.lang.Void> thenAccept(java.util.function.Consumer<? super T>);
    method public java.util.concurrent.CompletableFuture<java.lang.Void> thenAcceptAsync(java.util.function.Consumer<? super T>);
    method public java.util.concurrent.CompletableFuture<java.lang.Void> thenAcceptAsync(java.util.function.Consumer<? super T>, java.util.concurrent.Executor);
    method public <U> java.util.concurrent.CompletableFuture<java.lang.Void> thenAcceptBoth(java.util.concurrent.CompletionStage<? extends U>, java.util.function.BiConsumer<? super T,? super U>);
    method public <U> java.util.concurrent.CompletableFuture<java.lang.Void> thenAcceptBothAsync(java.util.concurrent.CompletionStage<? extends U>, java.util.function.BiConsumer<? super T,? super U>);
    method public <U> java.util.concurrent.CompletableFuture<java.lang.Void> thenAcceptBothAsync(java.util.concurrent.CompletionStage<? extends U>, java.util.function.BiConsumer<? super T,? super U>, java.util.concurrent.Executor);
    method public <U> java.util.concurrent.CompletableFuture<U> thenApply(java.util.function.Function<? super T,? extends U>);
    method public <U> java.util.concurrent.CompletableFuture<U> thenApplyAsync(java.util.function.Function<? super T,? extends U>);
    method public <U> java.util.concurrent.CompletableFuture<U> thenApplyAsync(java.util.function.Function<? super T,? extends U>, java.util.concurrent.Executor);
    method public <U, V> java.util.concurrent.CompletableFuture<V> thenCombine(java.util.concurrent.CompletionStage<? extends U>, java.util.function.BiFunction<? super T,? super U,? extends V>);
    method public <U, V> java.util.concurrent.CompletableFuture<V> thenCombineAsync(java.util.concurrent.CompletionStage<? extends U>, java.util.function.BiFunction<? super T,? super U,? extends V>);
    method public <U, V> java.util.concurrent.CompletableFuture<V> thenCombineAsync(java.util.concurrent.CompletionStage<? extends U>, java.util.function.BiFunction<? super T,? super U,? extends V>, java.util.concurrent.Executor);
    method public <U> java.util.concurrent.CompletableFuture<U> thenCompose(java.util.function.Function<? super T,? extends java.util.concurrent.CompletionStage<U>>);
    method public <U> java.util.concurrent.CompletableFuture<U> thenComposeAsync(java.util.function.Function<? super T,? extends java.util.concurrent.CompletionStage<U>>);
    method public <U> java.util.concurrent.CompletableFuture<U> thenComposeAsync(java.util.function.Function<? super T,? extends java.util.concurrent.CompletionStage<U>>, java.util.concurrent.Executor);
    method public java.util.concurrent.CompletableFuture<java.lang.Void> thenRun(Runnable);
    method public java.util.concurrent.CompletableFuture<java.lang.Void> thenRunAsync(Runnable);
    method public java.util.concurrent.CompletableFuture<java.lang.Void> thenRunAsync(Runnable, java.util.concurrent.Executor);
    method public java.util.concurrent.CompletableFuture<T> toCompletableFuture();
    method public java.util.concurrent.CompletableFuture<T> whenComplete(java.util.function.BiConsumer<? super T,? super java.lang.Throwable>);
    method public java.util.concurrent.CompletableFuture<T> whenCompleteAsync(java.util.function.BiConsumer<? super T,? super java.lang.Throwable>);
    method public java.util.concurrent.CompletableFuture<T> whenCompleteAsync(java.util.function.BiConsumer<? super T,? super java.lang.Throwable>, java.util.concurrent.Executor);
  }

  public static interface CompletableFuture.AsynchronousCompletionTask {
  }

  public class CompletionException extends java.lang.RuntimeException {
    ctor protected CompletionException();
    ctor protected CompletionException(String);
    ctor public CompletionException(String, Throwable);
    ctor public CompletionException(Throwable);
  }

  public interface CompletionService<V> {
    method public java.util.concurrent.Future<V> poll();
    method public java.util.concurrent.Future<V> poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public java.util.concurrent.Future<V> submit(java.util.concurrent.Callable<V>);
    method public java.util.concurrent.Future<V> submit(Runnable, V);
    method public java.util.concurrent.Future<V> take() throws java.lang.InterruptedException;
  }

  public interface CompletionStage<T> {
    method public java.util.concurrent.CompletionStage<java.lang.Void> acceptEither(java.util.concurrent.CompletionStage<? extends T>, java.util.function.Consumer<? super T>);
    method public java.util.concurrent.CompletionStage<java.lang.Void> acceptEitherAsync(java.util.concurrent.CompletionStage<? extends T>, java.util.function.Consumer<? super T>);
    method public java.util.concurrent.CompletionStage<java.lang.Void> acceptEitherAsync(java.util.concurrent.CompletionStage<? extends T>, java.util.function.Consumer<? super T>, java.util.concurrent.Executor);
    method public <U> java.util.concurrent.CompletionStage<U> applyToEither(java.util.concurrent.CompletionStage<? extends T>, java.util.function.Function<? super T,U>);
    method public <U> java.util.concurrent.CompletionStage<U> applyToEitherAsync(java.util.concurrent.CompletionStage<? extends T>, java.util.function.Function<? super T,U>);
    method public <U> java.util.concurrent.CompletionStage<U> applyToEitherAsync(java.util.concurrent.CompletionStage<? extends T>, java.util.function.Function<? super T,U>, java.util.concurrent.Executor);
    method public java.util.concurrent.CompletionStage<T> exceptionally(java.util.function.Function<java.lang.Throwable,? extends T>);
    method public default java.util.concurrent.CompletionStage<T> exceptionallyAsync(java.util.function.Function<java.lang.Throwable,? extends T>);
    method public default java.util.concurrent.CompletionStage<T> exceptionallyAsync(java.util.function.Function<java.lang.Throwable,? extends T>, java.util.concurrent.Executor);
    method public default java.util.concurrent.CompletionStage<T> exceptionallyCompose(java.util.function.Function<java.lang.Throwable,? extends java.util.concurrent.CompletionStage<T>>);
    method public default java.util.concurrent.CompletionStage<T> exceptionallyComposeAsync(java.util.function.Function<java.lang.Throwable,? extends java.util.concurrent.CompletionStage<T>>);
    method public default java.util.concurrent.CompletionStage<T> exceptionallyComposeAsync(java.util.function.Function<java.lang.Throwable,? extends java.util.concurrent.CompletionStage<T>>, java.util.concurrent.Executor);
    method public <U> java.util.concurrent.CompletionStage<U> handle(java.util.function.BiFunction<? super T,java.lang.Throwable,? extends U>);
    method public <U> java.util.concurrent.CompletionStage<U> handleAsync(java.util.function.BiFunction<? super T,java.lang.Throwable,? extends U>);
    method public <U> java.util.concurrent.CompletionStage<U> handleAsync(java.util.function.BiFunction<? super T,java.lang.Throwable,? extends U>, java.util.concurrent.Executor);
    method public java.util.concurrent.CompletionStage<java.lang.Void> runAfterBoth(java.util.concurrent.CompletionStage<?>, Runnable);
    method public java.util.concurrent.CompletionStage<java.lang.Void> runAfterBothAsync(java.util.concurrent.CompletionStage<?>, Runnable);
    method public java.util.concurrent.CompletionStage<java.lang.Void> runAfterBothAsync(java.util.concurrent.CompletionStage<?>, Runnable, java.util.concurrent.Executor);
    method public java.util.concurrent.CompletionStage<java.lang.Void> runAfterEither(java.util.concurrent.CompletionStage<?>, Runnable);
    method public java.util.concurrent.CompletionStage<java.lang.Void> runAfterEitherAsync(java.util.concurrent.CompletionStage<?>, Runnable);
    method public java.util.concurrent.CompletionStage<java.lang.Void> runAfterEitherAsync(java.util.concurrent.CompletionStage<?>, Runnable, java.util.concurrent.Executor);
    method public java.util.concurrent.CompletionStage<java.lang.Void> thenAccept(java.util.function.Consumer<? super T>);
    method public java.util.concurrent.CompletionStage<java.lang.Void> thenAcceptAsync(java.util.function.Consumer<? super T>);
    method public java.util.concurrent.CompletionStage<java.lang.Void> thenAcceptAsync(java.util.function.Consumer<? super T>, java.util.concurrent.Executor);
    method public <U> java.util.concurrent.CompletionStage<java.lang.Void> thenAcceptBoth(java.util.concurrent.CompletionStage<? extends U>, java.util.function.BiConsumer<? super T,? super U>);
    method public <U> java.util.concurrent.CompletionStage<java.lang.Void> thenAcceptBothAsync(java.util.concurrent.CompletionStage<? extends U>, java.util.function.BiConsumer<? super T,? super U>);
    method public <U> java.util.concurrent.CompletionStage<java.lang.Void> thenAcceptBothAsync(java.util.concurrent.CompletionStage<? extends U>, java.util.function.BiConsumer<? super T,? super U>, java.util.concurrent.Executor);
    method public <U> java.util.concurrent.CompletionStage<U> thenApply(java.util.function.Function<? super T,? extends U>);
    method public <U> java.util.concurrent.CompletionStage<U> thenApplyAsync(java.util.function.Function<? super T,? extends U>);
    method public <U> java.util.concurrent.CompletionStage<U> thenApplyAsync(java.util.function.Function<? super T,? extends U>, java.util.concurrent.Executor);
    method public <U, V> java.util.concurrent.CompletionStage<V> thenCombine(java.util.concurrent.CompletionStage<? extends U>, java.util.function.BiFunction<? super T,? super U,? extends V>);
    method public <U, V> java.util.concurrent.CompletionStage<V> thenCombineAsync(java.util.concurrent.CompletionStage<? extends U>, java.util.function.BiFunction<? super T,? super U,? extends V>);
    method public <U, V> java.util.concurrent.CompletionStage<V> thenCombineAsync(java.util.concurrent.CompletionStage<? extends U>, java.util.function.BiFunction<? super T,? super U,? extends V>, java.util.concurrent.Executor);
    method public <U> java.util.concurrent.CompletionStage<U> thenCompose(java.util.function.Function<? super T,? extends java.util.concurrent.CompletionStage<U>>);
    method public <U> java.util.concurrent.CompletionStage<U> thenComposeAsync(java.util.function.Function<? super T,? extends java.util.concurrent.CompletionStage<U>>);
    method public <U> java.util.concurrent.CompletionStage<U> thenComposeAsync(java.util.function.Function<? super T,? extends java.util.concurrent.CompletionStage<U>>, java.util.concurrent.Executor);
    method public java.util.concurrent.CompletionStage<java.lang.Void> thenRun(Runnable);
    method public java.util.concurrent.CompletionStage<java.lang.Void> thenRunAsync(Runnable);
    method public java.util.concurrent.CompletionStage<java.lang.Void> thenRunAsync(Runnable, java.util.concurrent.Executor);
    method public java.util.concurrent.CompletableFuture<T> toCompletableFuture();
    method public java.util.concurrent.CompletionStage<T> whenComplete(java.util.function.BiConsumer<? super T,? super java.lang.Throwable>);
    method public java.util.concurrent.CompletionStage<T> whenCompleteAsync(java.util.function.BiConsumer<? super T,? super java.lang.Throwable>);
    method public java.util.concurrent.CompletionStage<T> whenCompleteAsync(java.util.function.BiConsumer<? super T,? super java.lang.Throwable>, java.util.concurrent.Executor);
  }

  public class ConcurrentHashMap<K, V> extends java.util.AbstractMap<K,V> implements java.util.concurrent.ConcurrentMap<K,V> java.io.Serializable {
    ctor public ConcurrentHashMap();
    ctor public ConcurrentHashMap(int);
    ctor public ConcurrentHashMap(@NonNull java.util.Map<? extends K,? extends V>);
    ctor public ConcurrentHashMap(int, float);
    ctor public ConcurrentHashMap(int, float, int);
    method @Nullable public V compute(@NonNull K, @NonNull java.util.function.BiFunction<? super K,? super V,? extends V>);
    method @Nullable public V computeIfAbsent(@NonNull K, @NonNull java.util.function.Function<? super K,? extends V>);
    method @Nullable public V computeIfPresent(@NonNull K, @NonNull java.util.function.BiFunction<? super K,? super V,? extends V>);
    method public boolean contains(@NonNull Object);
    method @NonNull public java.util.Enumeration<V> elements();
    method @NonNull public java.util.Set<java.util.Map.Entry<K,V>> entrySet();
    method public void forEach(@NonNull java.util.function.BiConsumer<? super K,? super V>);
    method public void forEach(long, @NonNull java.util.function.BiConsumer<? super K,? super V>);
    method public <U> void forEach(long, @NonNull java.util.function.BiFunction<? super K,? super V,? extends U>, @NonNull java.util.function.Consumer<? super U>);
    method public void forEachEntry(long, @NonNull java.util.function.Consumer<? super java.util.Map.Entry<K,V>>);
    method public <U> void forEachEntry(long, @NonNull java.util.function.Function<java.util.Map.Entry<K,V>,? extends U>, @NonNull java.util.function.Consumer<? super U>);
    method public void forEachKey(long, @NonNull java.util.function.Consumer<? super K>);
    method public <U> void forEachKey(long, @NonNull java.util.function.Function<? super K,? extends U>, @NonNull java.util.function.Consumer<? super U>);
    method public void forEachValue(long, @NonNull java.util.function.Consumer<? super V>);
    method public <U> void forEachValue(long, @NonNull java.util.function.Function<? super V,? extends U>, @NonNull java.util.function.Consumer<? super U>);
    method @Nullable public V getOrDefault(@NonNull Object, @Nullable V);
    method @NonNull public java.util.concurrent.ConcurrentHashMap.KeySetView<K,V> keySet(@NonNull V);
    method @NonNull public java.util.Enumeration<K> keys();
    method public long mappingCount();
    method @Nullable public V merge(@NonNull K, @NonNull V, @NonNull java.util.function.BiFunction<? super V,? super V,? extends V>);
    method @NonNull public static <K> java.util.concurrent.ConcurrentHashMap.KeySetView<K,java.lang.Boolean> newKeySet();
    method @NonNull public static <K> java.util.concurrent.ConcurrentHashMap.KeySetView<K,java.lang.Boolean> newKeySet(int);
    method @Nullable public V putIfAbsent(@NonNull K, @NonNull V);
    method @Nullable public <U> U reduce(long, @NonNull java.util.function.BiFunction<? super K,? super V,? extends U>, @NonNull java.util.function.BiFunction<? super U,? super U,? extends U>);
    method @Nullable public java.util.Map.Entry<K,V> reduceEntries(long, @NonNull java.util.function.BiFunction<java.util.Map.Entry<K,V>,java.util.Map.Entry<K,V>,? extends java.util.Map.Entry<K,V>>);
    method @Nullable public <U> U reduceEntries(long, @NonNull java.util.function.Function<java.util.Map.Entry<K,V>,? extends U>, @NonNull java.util.function.BiFunction<? super U,? super U,? extends U>);
    method public double reduceEntriesToDouble(long, @NonNull java.util.function.ToDoubleFunction<java.util.Map.Entry<K,V>>, double, @NonNull java.util.function.DoubleBinaryOperator);
    method public int reduceEntriesToInt(long, @NonNull java.util.function.ToIntFunction<java.util.Map.Entry<K,V>>, int, @NonNull java.util.function.IntBinaryOperator);
    method public long reduceEntriesToLong(long, @NonNull java.util.function.ToLongFunction<java.util.Map.Entry<K,V>>, long, @NonNull java.util.function.LongBinaryOperator);
    method @Nullable public K reduceKeys(long, @NonNull java.util.function.BiFunction<? super K,? super K,? extends K>);
    method @Nullable public <U> U reduceKeys(long, @NonNull java.util.function.Function<? super K,? extends U>, @NonNull java.util.function.BiFunction<? super U,? super U,? extends U>);
    method public double reduceKeysToDouble(long, @NonNull java.util.function.ToDoubleFunction<? super K>, double, @NonNull java.util.function.DoubleBinaryOperator);
    method public int reduceKeysToInt(long, @NonNull java.util.function.ToIntFunction<? super K>, int, @NonNull java.util.function.IntBinaryOperator);
    method public long reduceKeysToLong(long, @NonNull java.util.function.ToLongFunction<? super K>, long, @NonNull java.util.function.LongBinaryOperator);
    method public double reduceToDouble(long, @NonNull java.util.function.ToDoubleBiFunction<? super K,? super V>, double, @NonNull java.util.function.DoubleBinaryOperator);
    method public int reduceToInt(long, @NonNull java.util.function.ToIntBiFunction<? super K,? super V>, int, @NonNull java.util.function.IntBinaryOperator);
    method public long reduceToLong(long, @NonNull java.util.function.ToLongBiFunction<? super K,? super V>, long, @NonNull java.util.function.LongBinaryOperator);
    method @Nullable public V reduceValues(long, @NonNull java.util.function.BiFunction<? super V,? super V,? extends V>);
    method @Nullable public <U> U reduceValues(long, @NonNull java.util.function.Function<? super V,? extends U>, @NonNull java.util.function.BiFunction<? super U,? super U,? extends U>);
    method public double reduceValuesToDouble(long, @NonNull java.util.function.ToDoubleFunction<? super V>, double, @NonNull java.util.function.DoubleBinaryOperator);
    method public int reduceValuesToInt(long, @NonNull java.util.function.ToIntFunction<? super V>, int, @NonNull java.util.function.IntBinaryOperator);
    method public long reduceValuesToLong(long, @NonNull java.util.function.ToLongFunction<? super V>, long, @NonNull java.util.function.LongBinaryOperator);
    method public boolean remove(@NonNull Object, @Nullable Object);
    method public boolean replace(@NonNull K, @NonNull V, @NonNull V);
    method @Nullable public V replace(@NonNull K, @NonNull V);
    method public void replaceAll(@NonNull java.util.function.BiFunction<? super K,? super V,? extends V>);
    method @Nullable public <U> U search(long, @NonNull java.util.function.BiFunction<? super K,? super V,? extends U>);
    method @Nullable public <U> U searchEntries(long, @NonNull java.util.function.Function<java.util.Map.Entry<K,V>,? extends U>);
    method @Nullable public <U> U searchKeys(long, @NonNull java.util.function.Function<? super K,? extends U>);
    method @Nullable public <U> U searchValues(long, @NonNull java.util.function.Function<? super V,? extends U>);
  }

  public static class ConcurrentHashMap.KeySetView<K, V> implements java.util.Collection<K> java.io.Serializable java.util.Set<K> {
    method public boolean add(@NonNull K);
    method public boolean addAll(@NonNull java.util.Collection<? extends K>);
    method public final void clear();
    method public boolean contains(@NonNull Object);
    method public final boolean containsAll(@NonNull java.util.Collection<?>);
    method public boolean equals(@Nullable Object);
    method public void forEach(@NonNull java.util.function.Consumer<? super K>);
    method @NonNull public java.util.concurrent.ConcurrentHashMap<K,V> getMap();
    method @Nullable public V getMappedValue();
    method public int hashCode();
    method public final boolean isEmpty();
    method @NonNull public java.util.Iterator<K> iterator();
    method public boolean remove(@NonNull Object);
    method public boolean removeAll(@NonNull java.util.Collection<?>);
    method public final boolean retainAll(@NonNull java.util.Collection<?>);
    method public final int size();
    method @NonNull public java.util.Spliterator<K> spliterator();
    method @NonNull public final Object[] toArray();
    method @NonNull public final <T> T[] toArray(@NonNull T[]);
    method @NonNull public final String toString();
  }

  public class ConcurrentLinkedDeque<E> extends java.util.AbstractCollection<E> implements java.util.Deque<E> java.io.Serializable {
    ctor public ConcurrentLinkedDeque();
    ctor public ConcurrentLinkedDeque(java.util.Collection<? extends E>);
    method public void addFirst(E);
    method public void addLast(E);
    method public java.util.Iterator<E> descendingIterator();
    method public E element();
    method public void forEach(java.util.function.Consumer<? super E>);
    method public E getFirst();
    method public E getLast();
    method public java.util.Iterator<E> iterator();
    method public boolean offer(E);
    method public boolean offerFirst(E);
    method public boolean offerLast(E);
    method public E peek();
    method public E peekFirst();
    method public E peekLast();
    method public E poll();
    method public E pollFirst();
    method public E pollLast();
    method public E pop();
    method public void push(E);
    method public E remove();
    method public E removeFirst();
    method public boolean removeFirstOccurrence(Object);
    method public boolean removeIf(java.util.function.Predicate<? super E>);
    method public E removeLast();
    method public boolean removeLastOccurrence(Object);
    method public int size();
    method public java.util.Spliterator<E> spliterator();
  }

  public class ConcurrentLinkedQueue<E> extends java.util.AbstractQueue<E> implements java.util.Queue<E> java.io.Serializable {
    ctor public ConcurrentLinkedQueue();
    ctor public ConcurrentLinkedQueue(java.util.Collection<? extends E>);
    method public void forEach(java.util.function.Consumer<? super E>);
    method public java.util.Iterator<E> iterator();
    method public boolean offer(E);
    method public E peek();
    method public E poll();
    method public boolean removeIf(java.util.function.Predicate<? super E>);
    method public int size();
    method public java.util.Spliterator<E> spliterator();
  }

  public interface ConcurrentMap<K, V> extends java.util.Map<K,V> {
    method public V putIfAbsent(K, V);
    method public boolean remove(Object, Object);
    method public boolean replace(K, V, V);
    method public V replace(K, V);
  }

  public interface ConcurrentNavigableMap<K, V> extends java.util.concurrent.ConcurrentMap<K,V> java.util.NavigableMap<K,V> {
    method public java.util.concurrent.ConcurrentNavigableMap<K,V> descendingMap();
    method public java.util.concurrent.ConcurrentNavigableMap<K,V> headMap(K, boolean);
    method public java.util.concurrent.ConcurrentNavigableMap<K,V> headMap(K);
    method public java.util.NavigableSet<K> keySet();
    method public java.util.concurrent.ConcurrentNavigableMap<K,V> subMap(K, boolean, K, boolean);
    method public java.util.concurrent.ConcurrentNavigableMap<K,V> subMap(K, K);
    method public java.util.concurrent.ConcurrentNavigableMap<K,V> tailMap(K, boolean);
    method public java.util.concurrent.ConcurrentNavigableMap<K,V> tailMap(K);
  }

  public class ConcurrentSkipListMap<K, V> extends java.util.AbstractMap<K,V> implements java.lang.Cloneable java.util.concurrent.ConcurrentNavigableMap<K,V> java.io.Serializable {
    ctor public ConcurrentSkipListMap();
    ctor public ConcurrentSkipListMap(java.util.Comparator<? super K>);
    ctor public ConcurrentSkipListMap(java.util.Map<? extends K,? extends V>);
    ctor public ConcurrentSkipListMap(java.util.SortedMap<K,? extends V>);
    method public java.util.Map.Entry<K,V> ceilingEntry(K);
    method public K ceilingKey(K);
    method public java.util.concurrent.ConcurrentSkipListMap<K,V> clone();
    method public java.util.Comparator<? super K> comparator();
    method public V compute(K, java.util.function.BiFunction<? super K,? super V,? extends V>);
    method public V computeIfAbsent(K, java.util.function.Function<? super K,? extends V>);
    method public V computeIfPresent(K, java.util.function.BiFunction<? super K,? super V,? extends V>);
    method public java.util.NavigableSet<K> descendingKeySet();
    method public java.util.concurrent.ConcurrentNavigableMap<K,V> descendingMap();
    method public java.util.Set<java.util.Map.Entry<K,V>> entrySet();
    method public java.util.Map.Entry<K,V> firstEntry();
    method public K firstKey();
    method public java.util.Map.Entry<K,V> floorEntry(K);
    method public K floorKey(K);
    method public void forEach(java.util.function.BiConsumer<? super K,? super V>);
    method public V getOrDefault(Object, V);
    method public java.util.concurrent.ConcurrentNavigableMap<K,V> headMap(K, boolean);
    method public java.util.concurrent.ConcurrentNavigableMap<K,V> headMap(K);
    method public java.util.Map.Entry<K,V> higherEntry(K);
    method public K higherKey(K);
    method public java.util.NavigableSet<K> keySet();
    method public java.util.Map.Entry<K,V> lastEntry();
    method public K lastKey();
    method public java.util.Map.Entry<K,V> lowerEntry(K);
    method public K lowerKey(K);
    method public V merge(K, V, java.util.function.BiFunction<? super V,? super V,? extends V>);
    method public java.util.NavigableSet<K> navigableKeySet();
    method public java.util.Map.Entry<K,V> pollFirstEntry();
    method public java.util.Map.Entry<K,V> pollLastEntry();
    method public V putIfAbsent(K, V);
    method public boolean remove(Object, Object);
    method public boolean replace(K, V, V);
    method public V replace(K, V);
    method public void replaceAll(java.util.function.BiFunction<? super K,? super V,? extends V>);
    method public java.util.concurrent.ConcurrentNavigableMap<K,V> subMap(K, boolean, K, boolean);
    method public java.util.concurrent.ConcurrentNavigableMap<K,V> subMap(K, K);
    method public java.util.concurrent.ConcurrentNavigableMap<K,V> tailMap(K, boolean);
    method public java.util.concurrent.ConcurrentNavigableMap<K,V> tailMap(K);
  }

  public class ConcurrentSkipListSet<E> extends java.util.AbstractSet<E> implements java.lang.Cloneable java.util.NavigableSet<E> java.io.Serializable {
    ctor public ConcurrentSkipListSet();
    ctor public ConcurrentSkipListSet(java.util.Comparator<? super E>);
    ctor public ConcurrentSkipListSet(java.util.Collection<? extends E>);
    ctor public ConcurrentSkipListSet(java.util.SortedSet<E>);
    method public E ceiling(E);
    method public java.util.concurrent.ConcurrentSkipListSet<E> clone();
    method public java.util.Comparator<? super E> comparator();
    method public java.util.Iterator<E> descendingIterator();
    method public java.util.NavigableSet<E> descendingSet();
    method public E first();
    method public E floor(E);
    method public java.util.NavigableSet<E> headSet(E, boolean);
    method public java.util.NavigableSet<E> headSet(E);
    method public E higher(E);
    method public java.util.Iterator<E> iterator();
    method public E last();
    method public E lower(E);
    method public E pollFirst();
    method public E pollLast();
    method public int size();
    method public java.util.Spliterator<E> spliterator();
    method public java.util.NavigableSet<E> subSet(E, boolean, E, boolean);
    method public java.util.NavigableSet<E> subSet(E, E);
    method public java.util.NavigableSet<E> tailSet(E, boolean);
    method public java.util.NavigableSet<E> tailSet(E);
  }

  public class CopyOnWriteArrayList<E> implements java.lang.Cloneable java.util.List<E> java.util.RandomAccess java.io.Serializable {
    ctor public CopyOnWriteArrayList();
    ctor public CopyOnWriteArrayList(@NonNull java.util.Collection<? extends E>);
    ctor public CopyOnWriteArrayList(@NonNull E[]);
    method public boolean add(E);
    method public void add(int, E);
    method public boolean addAll(@NonNull java.util.Collection<? extends E>);
    method public boolean addAll(int, @NonNull java.util.Collection<? extends E>);
    method public int addAllAbsent(@NonNull java.util.Collection<? extends E>);
    method public boolean addIfAbsent(E);
    method public void clear();
    method @NonNull public Object clone();
    method public boolean contains(@Nullable Object);
    method public boolean containsAll(@NonNull java.util.Collection<?>);
    method public boolean equals(@Nullable Object);
    method public void forEach(@NonNull java.util.function.Consumer<? super E>);
    method public E get(int);
    method public int hashCode();
    method public int indexOf(@Nullable Object);
    method public int indexOf(@Nullable E, int);
    method public boolean isEmpty();
    method @NonNull public java.util.Iterator<E> iterator();
    method public int lastIndexOf(@Nullable Object);
    method public int lastIndexOf(@Nullable E, int);
    method @NonNull public java.util.ListIterator<E> listIterator();
    method @NonNull public java.util.ListIterator<E> listIterator(int);
    method public E remove(int);
    method public boolean remove(@Nullable Object);
    method public boolean removeAll(@NonNull java.util.Collection<?>);
    method public boolean removeIf(@NonNull java.util.function.Predicate<? super E>);
    method public void replaceAll(@NonNull java.util.function.UnaryOperator<E>);
    method public boolean retainAll(@NonNull java.util.Collection<?>);
    method public E set(int, E);
    method public int size();
    method public void sort(@Nullable java.util.Comparator<? super E>);
    method @NonNull public java.util.Spliterator<E> spliterator();
    method @NonNull public java.util.List<E> subList(int, int);
    method @NonNull public Object[] toArray();
    method @NonNull public <T> T[] toArray(@NonNull T[]);
  }

  public class CopyOnWriteArraySet<E> extends java.util.AbstractSet<E> implements java.io.Serializable {
    ctor public CopyOnWriteArraySet();
    ctor public CopyOnWriteArraySet(java.util.Collection<? extends E>);
    method public void forEach(java.util.function.Consumer<? super E>);
    method public java.util.Iterator<E> iterator();
    method public boolean removeIf(java.util.function.Predicate<? super E>);
    method public int size();
    method public java.util.Spliterator<E> spliterator();
  }

  public class CountDownLatch {
    ctor public CountDownLatch(int);
    method public void await() throws java.lang.InterruptedException;
    method public boolean await(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public void countDown();
    method public long getCount();
  }

  public abstract class CountedCompleter<T> extends java.util.concurrent.ForkJoinTask<T> {
    ctor protected CountedCompleter(java.util.concurrent.CountedCompleter<?>, int);
    ctor protected CountedCompleter(java.util.concurrent.CountedCompleter<?>);
    ctor protected CountedCompleter();
    method public final void addToPendingCount(int);
    method public final boolean compareAndSetPendingCount(int, int);
    method public void complete(T);
    method public abstract void compute();
    method public final int decrementPendingCountUnlessZero();
    method protected final boolean exec();
    method public final java.util.concurrent.CountedCompleter<?> firstComplete();
    method public final java.util.concurrent.CountedCompleter<?> getCompleter();
    method public final int getPendingCount();
    method public T getRawResult();
    method public final java.util.concurrent.CountedCompleter<?> getRoot();
    method public final void helpComplete(int);
    method public final java.util.concurrent.CountedCompleter<?> nextComplete();
    method public void onCompletion(java.util.concurrent.CountedCompleter<?>);
    method public boolean onExceptionalCompletion(Throwable, java.util.concurrent.CountedCompleter<?>);
    method public final void propagateCompletion();
    method public final void quietlyCompleteRoot();
    method public final void setPendingCount(int);
    method protected void setRawResult(T);
    method public final void tryComplete();
  }

  public class CyclicBarrier {
    ctor public CyclicBarrier(int, Runnable);
    ctor public CyclicBarrier(int);
    method public int await() throws java.util.concurrent.BrokenBarrierException, java.lang.InterruptedException;
    method public int await(long, java.util.concurrent.TimeUnit) throws java.util.concurrent.BrokenBarrierException, java.lang.InterruptedException, java.util.concurrent.TimeoutException;
    method public int getNumberWaiting();
    method public int getParties();
    method public boolean isBroken();
    method public void reset();
  }

  public class DelayQueue<E extends java.util.concurrent.Delayed> extends java.util.AbstractQueue<E> implements java.util.concurrent.BlockingQueue<E> {
    ctor public DelayQueue();
    ctor public DelayQueue(java.util.Collection<? extends E>);
    method public boolean add(E);
    method public int drainTo(java.util.Collection<? super E>);
    method public int drainTo(java.util.Collection<? super E>, int);
    method public java.util.Iterator<E> iterator();
    method public boolean offer(E);
    method public boolean offer(E, long, java.util.concurrent.TimeUnit);
    method public E peek();
    method public E poll();
    method public E poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public void put(E);
    method public int remainingCapacity();
    method public int size();
    method public E take() throws java.lang.InterruptedException;
  }

  public interface Delayed extends java.lang.Comparable<java.util.concurrent.Delayed> {
    method public long getDelay(java.util.concurrent.TimeUnit);
  }

  public class Exchanger<V> {
    ctor public Exchanger();
    method public V exchange(V) throws java.lang.InterruptedException;
    method public V exchange(V, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.TimeoutException;
  }

  public class ExecutionException extends java.lang.Exception {
    ctor protected ExecutionException();
    ctor protected ExecutionException(String);
    ctor public ExecutionException(String, Throwable);
    ctor public ExecutionException(Throwable);
  }

  public interface Executor {
    method public void execute(Runnable);
  }

  public class ExecutorCompletionService<V> implements java.util.concurrent.CompletionService<V> {
    ctor public ExecutorCompletionService(java.util.concurrent.Executor);
    ctor public ExecutorCompletionService(java.util.concurrent.Executor, java.util.concurrent.BlockingQueue<java.util.concurrent.Future<V>>);
    method public java.util.concurrent.Future<V> poll();
    method public java.util.concurrent.Future<V> poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public java.util.concurrent.Future<V> submit(java.util.concurrent.Callable<V>);
    method public java.util.concurrent.Future<V> submit(Runnable, V);
    method public java.util.concurrent.Future<V> take() throws java.lang.InterruptedException;
  }

  public interface ExecutorService extends java.util.concurrent.Executor {
    method public boolean awaitTermination(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public <T> java.util.List<java.util.concurrent.Future<T>> invokeAll(java.util.Collection<? extends java.util.concurrent.Callable<T>>) throws java.lang.InterruptedException;
    method public <T> java.util.List<java.util.concurrent.Future<T>> invokeAll(java.util.Collection<? extends java.util.concurrent.Callable<T>>, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public <T> T invokeAny(java.util.Collection<? extends java.util.concurrent.Callable<T>>) throws java.util.concurrent.ExecutionException, java.lang.InterruptedException;
    method public <T> T invokeAny(java.util.Collection<? extends java.util.concurrent.Callable<T>>, long, java.util.concurrent.TimeUnit) throws java.util.concurrent.ExecutionException, java.lang.InterruptedException, java.util.concurrent.TimeoutException;
    method public boolean isShutdown();
    method public boolean isTerminated();
    method public void shutdown();
    method public java.util.List<java.lang.Runnable> shutdownNow();
    method public <T> java.util.concurrent.Future<T> submit(java.util.concurrent.Callable<T>);
    method public <T> java.util.concurrent.Future<T> submit(Runnable, T);
    method public java.util.concurrent.Future<?> submit(Runnable);
  }

  public class Executors {
    method public static <T> java.util.concurrent.Callable<T> callable(Runnable, T);
    method public static java.util.concurrent.Callable<java.lang.Object> callable(Runnable);
    method public static java.util.concurrent.Callable<java.lang.Object> callable(java.security.PrivilegedAction<?>);
    method public static java.util.concurrent.Callable<java.lang.Object> callable(java.security.PrivilegedExceptionAction<?>);
    method public static java.util.concurrent.ThreadFactory defaultThreadFactory();
    method public static java.util.concurrent.ExecutorService newCachedThreadPool();
    method public static java.util.concurrent.ExecutorService newCachedThreadPool(java.util.concurrent.ThreadFactory);
    method public static java.util.concurrent.ExecutorService newFixedThreadPool(int);
    method public static java.util.concurrent.ExecutorService newFixedThreadPool(int, java.util.concurrent.ThreadFactory);
    method public static java.util.concurrent.ScheduledExecutorService newScheduledThreadPool(int);
    method public static java.util.concurrent.ScheduledExecutorService newScheduledThreadPool(int, java.util.concurrent.ThreadFactory);
    method public static java.util.concurrent.ExecutorService newSingleThreadExecutor();
    method public static java.util.concurrent.ExecutorService newSingleThreadExecutor(java.util.concurrent.ThreadFactory);
    method public static java.util.concurrent.ScheduledExecutorService newSingleThreadScheduledExecutor();
    method public static java.util.concurrent.ScheduledExecutorService newSingleThreadScheduledExecutor(java.util.concurrent.ThreadFactory);
    method public static java.util.concurrent.ExecutorService newWorkStealingPool(int);
    method public static java.util.concurrent.ExecutorService newWorkStealingPool();
    method @Deprecated public static <T> java.util.concurrent.Callable<T> privilegedCallable(java.util.concurrent.Callable<T>);
    method @Deprecated public static <T> java.util.concurrent.Callable<T> privilegedCallableUsingCurrentClassLoader(java.util.concurrent.Callable<T>);
    method @Deprecated public static java.util.concurrent.ThreadFactory privilegedThreadFactory();
    method public static java.util.concurrent.ExecutorService unconfigurableExecutorService(java.util.concurrent.ExecutorService);
    method public static java.util.concurrent.ScheduledExecutorService unconfigurableScheduledExecutorService(java.util.concurrent.ScheduledExecutorService);
  }

  public final class Flow {
    method public static int defaultBufferSize();
  }

  public static interface Flow.Processor<T, R> extends java.util.concurrent.Flow.Subscriber<T> java.util.concurrent.Flow.Publisher<R> {
  }

  @java.lang.FunctionalInterface public static interface Flow.Publisher<T> {
    method public void subscribe(java.util.concurrent.Flow.Subscriber<? super T>);
  }

  public static interface Flow.Subscriber<T> {
    method public void onComplete();
    method public void onError(Throwable);
    method public void onNext(T);
    method public void onSubscribe(java.util.concurrent.Flow.Subscription);
  }

  public static interface Flow.Subscription {
    method public void cancel();
    method public void request(long);
  }

  public class ForkJoinPool extends java.util.concurrent.AbstractExecutorService {
    ctor public ForkJoinPool();
    ctor public ForkJoinPool(int);
    ctor public ForkJoinPool(int, java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory, java.lang.Thread.UncaughtExceptionHandler, boolean);
    ctor public ForkJoinPool(int, java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory, java.lang.Thread.UncaughtExceptionHandler, boolean, int, int, int, java.util.function.Predicate<? super java.util.concurrent.ForkJoinPool>, long, java.util.concurrent.TimeUnit);
    method public boolean awaitQuiescence(long, java.util.concurrent.TimeUnit);
    method public boolean awaitTermination(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public static java.util.concurrent.ForkJoinPool commonPool();
    method protected int drainTasksTo(java.util.Collection<? super java.util.concurrent.ForkJoinTask<?>>);
    method public void execute(java.util.concurrent.ForkJoinTask<?>);
    method public void execute(Runnable);
    method public int getActiveThreadCount();
    method public boolean getAsyncMode();
    method public static int getCommonPoolParallelism();
    method public java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory getFactory();
    method public int getParallelism();
    method public int getPoolSize();
    method public int getQueuedSubmissionCount();
    method public long getQueuedTaskCount();
    method public int getRunningThreadCount();
    method public long getStealCount();
    method public java.lang.Thread.UncaughtExceptionHandler getUncaughtExceptionHandler();
    method public boolean hasQueuedSubmissions();
    method public <T> T invoke(java.util.concurrent.ForkJoinTask<T>);
    method public <T> java.util.List<java.util.concurrent.Future<T>> invokeAll(java.util.Collection<? extends java.util.concurrent.Callable<T>>);
    method public boolean isQuiescent();
    method public boolean isShutdown();
    method public boolean isTerminated();
    method public boolean isTerminating();
    method public static void managedBlock(java.util.concurrent.ForkJoinPool.ManagedBlocker) throws java.lang.InterruptedException;
    method protected java.util.concurrent.ForkJoinTask<?> pollSubmission();
    method public void shutdown();
    method public java.util.List<java.lang.Runnable> shutdownNow();
    method public <T> java.util.concurrent.ForkJoinTask<T> submit(java.util.concurrent.ForkJoinTask<T>);
    method public <T> java.util.concurrent.ForkJoinTask<T> submit(java.util.concurrent.Callable<T>);
    method public <T> java.util.concurrent.ForkJoinTask<T> submit(Runnable, T);
    method public java.util.concurrent.ForkJoinTask<?> submit(Runnable);
    field public static final java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory;
  }

  public static interface ForkJoinPool.ForkJoinWorkerThreadFactory {
    method public java.util.concurrent.ForkJoinWorkerThread newThread(java.util.concurrent.ForkJoinPool);
  }

  public static interface ForkJoinPool.ManagedBlocker {
    method public boolean block() throws java.lang.InterruptedException;
    method public boolean isReleasable();
  }

  public abstract class ForkJoinTask<V> implements java.util.concurrent.Future<V> java.io.Serializable {
    ctor public ForkJoinTask();
    method public static java.util.concurrent.ForkJoinTask<?> adapt(Runnable);
    method public static <T> java.util.concurrent.ForkJoinTask<T> adapt(Runnable, T);
    method public static <T> java.util.concurrent.ForkJoinTask<T> adapt(java.util.concurrent.Callable<? extends T>);
    method public boolean cancel(boolean);
    method public final boolean compareAndSetForkJoinTaskTag(short, short);
    method public void complete(V);
    method public void completeExceptionally(Throwable);
    method protected abstract boolean exec();
    method public final java.util.concurrent.ForkJoinTask<V> fork();
    method public final V get() throws java.util.concurrent.ExecutionException, java.lang.InterruptedException;
    method public final V get(long, java.util.concurrent.TimeUnit) throws java.util.concurrent.ExecutionException, java.lang.InterruptedException, java.util.concurrent.TimeoutException;
    method public final Throwable getException();
    method public final short getForkJoinTaskTag();
    method public static java.util.concurrent.ForkJoinPool getPool();
    method public static int getQueuedTaskCount();
    method public abstract V getRawResult();
    method public static int getSurplusQueuedTaskCount();
    method public static void helpQuiesce();
    method public static boolean inForkJoinPool();
    method public final V invoke();
    method public static void invokeAll(java.util.concurrent.ForkJoinTask<?>, java.util.concurrent.ForkJoinTask<?>);
    method public static void invokeAll(java.util.concurrent.ForkJoinTask<?>...);
    method public static <T extends java.util.concurrent.ForkJoinTask<?>> java.util.Collection<T> invokeAll(java.util.Collection<T>);
    method public final boolean isCancelled();
    method public final boolean isCompletedAbnormally();
    method public final boolean isCompletedNormally();
    method public final boolean isDone();
    method public final V join();
    method protected static java.util.concurrent.ForkJoinTask<?> peekNextLocalTask();
    method protected static java.util.concurrent.ForkJoinTask<?> pollNextLocalTask();
    method protected static java.util.concurrent.ForkJoinTask<?> pollTask();
    method public final void quietlyComplete();
    method public final void quietlyInvoke();
    method public final void quietlyJoin();
    method public void reinitialize();
    method public final short setForkJoinTaskTag(short);
    method protected abstract void setRawResult(V);
    method public boolean tryUnfork();
  }

  public class ForkJoinWorkerThread extends java.lang.Thread {
    ctor protected ForkJoinWorkerThread(java.util.concurrent.ForkJoinPool);
    method public java.util.concurrent.ForkJoinPool getPool();
    method public int getPoolIndex();
    method protected void onStart();
    method protected void onTermination(Throwable);
  }

  public interface Future<V> {
    method public boolean cancel(boolean);
    method public V get() throws java.util.concurrent.ExecutionException, java.lang.InterruptedException;
    method public V get(long, java.util.concurrent.TimeUnit) throws java.util.concurrent.ExecutionException, java.lang.InterruptedException, java.util.concurrent.TimeoutException;
    method public boolean isCancelled();
    method public boolean isDone();
  }

  public class FutureTask<V> implements java.util.concurrent.RunnableFuture<V> {
    ctor public FutureTask(java.util.concurrent.Callable<V>);
    ctor public FutureTask(Runnable, V);
    method public boolean cancel(boolean);
    method protected void done();
    method public V get() throws java.util.concurrent.ExecutionException, java.lang.InterruptedException;
    method public V get(long, java.util.concurrent.TimeUnit) throws java.util.concurrent.ExecutionException, java.lang.InterruptedException, java.util.concurrent.TimeoutException;
    method public boolean isCancelled();
    method public boolean isDone();
    method public void run();
    method protected boolean runAndReset();
    method protected void set(V);
    method protected void setException(Throwable);
  }

  public class LinkedBlockingDeque<E> extends java.util.AbstractQueue<E> implements java.util.concurrent.BlockingDeque<E> java.io.Serializable {
    ctor public LinkedBlockingDeque();
    ctor public LinkedBlockingDeque(int);
    ctor public LinkedBlockingDeque(java.util.Collection<? extends E>);
    method public void addFirst(E);
    method public void addLast(E);
    method public java.util.Iterator<E> descendingIterator();
    method public int drainTo(java.util.Collection<? super E>);
    method public int drainTo(java.util.Collection<? super E>, int);
    method public void forEach(java.util.function.Consumer<? super E>);
    method public E getFirst();
    method public E getLast();
    method public java.util.Iterator<E> iterator();
    method public boolean offer(E);
    method public boolean offer(E, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public boolean offerFirst(E);
    method public boolean offerFirst(E, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public boolean offerLast(E);
    method public boolean offerLast(E, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public E peek();
    method public E peekFirst();
    method public E peekLast();
    method public E poll();
    method public E poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public E pollFirst();
    method public E pollFirst(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public E pollLast();
    method public E pollLast(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public E pop();
    method public void push(E);
    method public void put(E) throws java.lang.InterruptedException;
    method public void putFirst(E) throws java.lang.InterruptedException;
    method public void putLast(E) throws java.lang.InterruptedException;
    method public int remainingCapacity();
    method public E removeFirst();
    method public boolean removeFirstOccurrence(Object);
    method public boolean removeIf(java.util.function.Predicate<? super E>);
    method public E removeLast();
    method public boolean removeLastOccurrence(Object);
    method public int size();
    method public java.util.Spliterator<E> spliterator();
    method public E take() throws java.lang.InterruptedException;
    method public E takeFirst() throws java.lang.InterruptedException;
    method public E takeLast() throws java.lang.InterruptedException;
  }

  public class LinkedBlockingQueue<E> extends java.util.AbstractQueue<E> implements java.util.concurrent.BlockingQueue<E> java.io.Serializable {
    ctor public LinkedBlockingQueue();
    ctor public LinkedBlockingQueue(int);
    ctor public LinkedBlockingQueue(java.util.Collection<? extends E>);
    method public int drainTo(java.util.Collection<? super E>);
    method public int drainTo(java.util.Collection<? super E>, int);
    method public void forEach(java.util.function.Consumer<? super E>);
    method public java.util.Iterator<E> iterator();
    method public boolean offer(E, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public boolean offer(E);
    method public E peek();
    method public E poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public E poll();
    method public void put(E) throws java.lang.InterruptedException;
    method public int remainingCapacity();
    method public boolean removeIf(java.util.function.Predicate<? super E>);
    method public int size();
    method public java.util.Spliterator<E> spliterator();
    method public E take() throws java.lang.InterruptedException;
  }

  public class LinkedTransferQueue<E> extends java.util.AbstractQueue<E> implements java.io.Serializable java.util.concurrent.TransferQueue<E> {
    ctor public LinkedTransferQueue();
    ctor public LinkedTransferQueue(java.util.Collection<? extends E>);
    method public int drainTo(java.util.Collection<? super E>);
    method public int drainTo(java.util.Collection<? super E>, int);
    method public void forEach(java.util.function.Consumer<? super E>);
    method public int getWaitingConsumerCount();
    method public boolean hasWaitingConsumer();
    method public java.util.Iterator<E> iterator();
    method public boolean offer(E, long, java.util.concurrent.TimeUnit);
    method public boolean offer(E);
    method public E peek();
    method public E poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public E poll();
    method public void put(E);
    method public int remainingCapacity();
    method public boolean removeIf(java.util.function.Predicate<? super E>);
    method public int size();
    method public java.util.Spliterator<E> spliterator();
    method public E take() throws java.lang.InterruptedException;
    method public void transfer(E) throws java.lang.InterruptedException;
    method public boolean tryTransfer(E);
    method public boolean tryTransfer(E, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
  }

  public class Phaser {
    ctor public Phaser();
    ctor public Phaser(int);
    ctor public Phaser(java.util.concurrent.Phaser);
    ctor public Phaser(java.util.concurrent.Phaser, int);
    method public int arrive();
    method public int arriveAndAwaitAdvance();
    method public int arriveAndDeregister();
    method public int awaitAdvance(int);
    method public int awaitAdvanceInterruptibly(int) throws java.lang.InterruptedException;
    method public int awaitAdvanceInterruptibly(int, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.TimeoutException;
    method public int bulkRegister(int);
    method public void forceTermination();
    method public int getArrivedParties();
    method public java.util.concurrent.Phaser getParent();
    method public final int getPhase();
    method public int getRegisteredParties();
    method public java.util.concurrent.Phaser getRoot();
    method public int getUnarrivedParties();
    method public boolean isTerminated();
    method protected boolean onAdvance(int, int);
    method public int register();
  }

  public class PriorityBlockingQueue<E> extends java.util.AbstractQueue<E> implements java.util.concurrent.BlockingQueue<E> java.io.Serializable {
    ctor public PriorityBlockingQueue();
    ctor public PriorityBlockingQueue(int);
    ctor public PriorityBlockingQueue(int, java.util.Comparator<? super E>);
    ctor public PriorityBlockingQueue(java.util.Collection<? extends E>);
    method public java.util.Comparator<? super E> comparator();
    method public int drainTo(java.util.Collection<? super E>);
    method public int drainTo(java.util.Collection<? super E>, int);
    method public void forEach(java.util.function.Consumer<? super E>);
    method public java.util.Iterator<E> iterator();
    method public boolean offer(E);
    method public boolean offer(E, long, java.util.concurrent.TimeUnit);
    method public E peek();
    method public E poll();
    method public E poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public void put(E);
    method public int remainingCapacity();
    method public boolean removeIf(java.util.function.Predicate<? super E>);
    method public int size();
    method public java.util.Spliterator<E> spliterator();
    method public E take() throws java.lang.InterruptedException;
  }

  public abstract class RecursiveAction extends java.util.concurrent.ForkJoinTask<java.lang.Void> {
    ctor public RecursiveAction();
    method protected abstract void compute();
    method protected final boolean exec();
    method public final Void getRawResult();
    method protected final void setRawResult(Void);
  }

  public abstract class RecursiveTask<V> extends java.util.concurrent.ForkJoinTask<V> {
    ctor public RecursiveTask();
    method protected abstract V compute();
    method protected final boolean exec();
    method public final V getRawResult();
    method protected final void setRawResult(V);
  }

  public class RejectedExecutionException extends java.lang.RuntimeException {
    ctor public RejectedExecutionException();
    ctor public RejectedExecutionException(String);
    ctor public RejectedExecutionException(String, Throwable);
    ctor public RejectedExecutionException(Throwable);
  }

  public interface RejectedExecutionHandler {
    method public void rejectedExecution(Runnable, java.util.concurrent.ThreadPoolExecutor);
  }

  public interface RunnableFuture<V> extends java.lang.Runnable java.util.concurrent.Future<V> {
  }

  public interface RunnableScheduledFuture<V> extends java.util.concurrent.RunnableFuture<V> java.util.concurrent.ScheduledFuture<V> {
    method public boolean isPeriodic();
  }

  public interface ScheduledExecutorService extends java.util.concurrent.ExecutorService {
    method public java.util.concurrent.ScheduledFuture<?> schedule(Runnable, long, java.util.concurrent.TimeUnit);
    method public <V> java.util.concurrent.ScheduledFuture<V> schedule(java.util.concurrent.Callable<V>, long, java.util.concurrent.TimeUnit);
    method public java.util.concurrent.ScheduledFuture<?> scheduleAtFixedRate(Runnable, long, long, java.util.concurrent.TimeUnit);
    method public java.util.concurrent.ScheduledFuture<?> scheduleWithFixedDelay(Runnable, long, long, java.util.concurrent.TimeUnit);
  }

  public interface ScheduledFuture<V> extends java.util.concurrent.Delayed java.util.concurrent.Future<V> {
  }

  public class ScheduledThreadPoolExecutor extends java.util.concurrent.ThreadPoolExecutor implements java.util.concurrent.ScheduledExecutorService {
    ctor public ScheduledThreadPoolExecutor(int);
    ctor public ScheduledThreadPoolExecutor(int, java.util.concurrent.ThreadFactory);
    ctor public ScheduledThreadPoolExecutor(int, java.util.concurrent.RejectedExecutionHandler);
    ctor public ScheduledThreadPoolExecutor(int, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler);
    method protected <V> java.util.concurrent.RunnableScheduledFuture<V> decorateTask(Runnable, java.util.concurrent.RunnableScheduledFuture<V>);
    method protected <V> java.util.concurrent.RunnableScheduledFuture<V> decorateTask(java.util.concurrent.Callable<V>, java.util.concurrent.RunnableScheduledFuture<V>);
    method public boolean getContinueExistingPeriodicTasksAfterShutdownPolicy();
    method public boolean getExecuteExistingDelayedTasksAfterShutdownPolicy();
    method public boolean getRemoveOnCancelPolicy();
    method public java.util.concurrent.ScheduledFuture<?> schedule(Runnable, long, java.util.concurrent.TimeUnit);
    method public <V> java.util.concurrent.ScheduledFuture<V> schedule(java.util.concurrent.Callable<V>, long, java.util.concurrent.TimeUnit);
    method public java.util.concurrent.ScheduledFuture<?> scheduleAtFixedRate(Runnable, long, long, java.util.concurrent.TimeUnit);
    method public java.util.concurrent.ScheduledFuture<?> scheduleWithFixedDelay(Runnable, long, long, java.util.concurrent.TimeUnit);
    method public void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean);
    method public void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean);
    method public void setRemoveOnCancelPolicy(boolean);
  }

  public class Semaphore implements java.io.Serializable {
    ctor public Semaphore(int);
    ctor public Semaphore(int, boolean);
    method public void acquire() throws java.lang.InterruptedException;
    method public void acquire(int) throws java.lang.InterruptedException;
    method public void acquireUninterruptibly();
    method public void acquireUninterruptibly(int);
    method public int availablePermits();
    method public int drainPermits();
    method public final int getQueueLength();
    method protected java.util.Collection<java.lang.Thread> getQueuedThreads();
    method public final boolean hasQueuedThreads();
    method public boolean isFair();
    method protected void reducePermits(int);
    method public void release();
    method public void release(int);
    method public boolean tryAcquire();
    method public boolean tryAcquire(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public boolean tryAcquire(int);
    method public boolean tryAcquire(int, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
  }

  public class SubmissionPublisher<T> implements java.lang.AutoCloseable java.util.concurrent.Flow.Publisher<T> {
    ctor public SubmissionPublisher(java.util.concurrent.Executor, int, java.util.function.BiConsumer<? super java.util.concurrent.Flow.Subscriber<? super T>,? super java.lang.Throwable>);
    ctor public SubmissionPublisher(java.util.concurrent.Executor, int);
    ctor public SubmissionPublisher();
    method public void close();
    method public void closeExceptionally(Throwable);
    method public java.util.concurrent.CompletableFuture<java.lang.Void> consume(java.util.function.Consumer<? super T>);
    method public int estimateMaximumLag();
    method public long estimateMinimumDemand();
    method public Throwable getClosedException();
    method public java.util.concurrent.Executor getExecutor();
    method public int getMaxBufferCapacity();
    method public int getNumberOfSubscribers();
    method public java.util.List<java.util.concurrent.Flow.Subscriber<? super T>> getSubscribers();
    method public boolean hasSubscribers();
    method public boolean isClosed();
    method public boolean isSubscribed(java.util.concurrent.Flow.Subscriber<? super T>);
    method public int offer(T, java.util.function.BiPredicate<java.util.concurrent.Flow.Subscriber<? super T>,? super T>);
    method public int offer(T, long, java.util.concurrent.TimeUnit, java.util.function.BiPredicate<java.util.concurrent.Flow.Subscriber<? super T>,? super T>);
    method public int submit(T);
    method public void subscribe(java.util.concurrent.Flow.Subscriber<? super T>);
  }

  public class SynchronousQueue<E> extends java.util.AbstractQueue<E> implements java.util.concurrent.BlockingQueue<E> java.io.Serializable {
    ctor public SynchronousQueue();
    ctor public SynchronousQueue(boolean);
    method public int drainTo(java.util.Collection<? super E>);
    method public int drainTo(java.util.Collection<? super E>, int);
    method public java.util.Iterator<E> iterator();
    method public boolean offer(E, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public boolean offer(E);
    method public E peek();
    method public E poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public E poll();
    method public void put(E) throws java.lang.InterruptedException;
    method public int remainingCapacity();
    method public int size();
    method public java.util.Spliterator<E> spliterator();
    method public E take() throws java.lang.InterruptedException;
  }

  public interface ThreadFactory {
    method public Thread newThread(Runnable);
  }

  public class ThreadLocalRandom extends java.util.Random {
    method public static java.util.concurrent.ThreadLocalRandom current();
    method public double nextDouble(double);
    method public double nextDouble(double, double);
    method public float nextFloat(float);
    method public float nextFloat(float, float);
    method public int nextInt(int, int);
    method public long nextLong(long);
    method public long nextLong(long, long);
  }

  public class ThreadPoolExecutor extends java.util.concurrent.AbstractExecutorService {
    ctor public ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue<java.lang.Runnable>);
    ctor public ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue<java.lang.Runnable>, java.util.concurrent.ThreadFactory);
    ctor public ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue<java.lang.Runnable>, java.util.concurrent.RejectedExecutionHandler);
    ctor public ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue<java.lang.Runnable>, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler);
    method protected void afterExecute(Runnable, Throwable);
    method public void allowCoreThreadTimeOut(boolean);
    method public boolean allowsCoreThreadTimeOut();
    method public boolean awaitTermination(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method protected void beforeExecute(Thread, Runnable);
    method public void execute(Runnable);
    method @Deprecated protected void finalize();
    method public int getActiveCount();
    method public long getCompletedTaskCount();
    method public int getCorePoolSize();
    method public long getKeepAliveTime(java.util.concurrent.TimeUnit);
    method public int getLargestPoolSize();
    method public int getMaximumPoolSize();
    method public int getPoolSize();
    method public java.util.concurrent.BlockingQueue<java.lang.Runnable> getQueue();
    method public java.util.concurrent.RejectedExecutionHandler getRejectedExecutionHandler();
    method public long getTaskCount();
    method public java.util.concurrent.ThreadFactory getThreadFactory();
    method public boolean isShutdown();
    method public boolean isTerminated();
    method public boolean isTerminating();
    method public int prestartAllCoreThreads();
    method public boolean prestartCoreThread();
    method public void purge();
    method public boolean remove(Runnable);
    method public void setCorePoolSize(int);
    method public void setKeepAliveTime(long, java.util.concurrent.TimeUnit);
    method public void setMaximumPoolSize(int);
    method public void setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler);
    method public void setThreadFactory(java.util.concurrent.ThreadFactory);
    method public void shutdown();
    method public java.util.List<java.lang.Runnable> shutdownNow();
    method protected void terminated();
  }

  public static class ThreadPoolExecutor.AbortPolicy implements java.util.concurrent.RejectedExecutionHandler {
    ctor public ThreadPoolExecutor.AbortPolicy();
    method public void rejectedExecution(Runnable, java.util.concurrent.ThreadPoolExecutor);
  }

  public static class ThreadPoolExecutor.CallerRunsPolicy implements java.util.concurrent.RejectedExecutionHandler {
    ctor public ThreadPoolExecutor.CallerRunsPolicy();
    method public void rejectedExecution(Runnable, java.util.concurrent.ThreadPoolExecutor);
  }

  public static class ThreadPoolExecutor.DiscardOldestPolicy implements java.util.concurrent.RejectedExecutionHandler {
    ctor public ThreadPoolExecutor.DiscardOldestPolicy();
    method public void rejectedExecution(Runnable, java.util.concurrent.ThreadPoolExecutor);
  }

  public static class ThreadPoolExecutor.DiscardPolicy implements java.util.concurrent.RejectedExecutionHandler {
    ctor public ThreadPoolExecutor.DiscardPolicy();
    method public void rejectedExecution(Runnable, java.util.concurrent.ThreadPoolExecutor);
  }

  public enum TimeUnit {
    method public long convert(long, java.util.concurrent.TimeUnit);
    method public long convert(java.time.Duration);
    method public static java.util.concurrent.TimeUnit of(java.time.temporal.ChronoUnit);
    method public void sleep(long) throws java.lang.InterruptedException;
    method public void timedJoin(Thread, long) throws java.lang.InterruptedException;
    method public void timedWait(Object, long) throws java.lang.InterruptedException;
    method public java.time.temporal.ChronoUnit toChronoUnit();
    method public long toDays(long);
    method public long toHours(long);
    method public long toMicros(long);
    method public long toMillis(long);
    method public long toMinutes(long);
    method public long toNanos(long);
    method public long toSeconds(long);
    enum_constant public static final java.util.concurrent.TimeUnit DAYS;
    enum_constant public static final java.util.concurrent.TimeUnit HOURS;
    enum_constant public static final java.util.concurrent.TimeUnit MICROSECONDS;
    enum_constant public static final java.util.concurrent.TimeUnit MILLISECONDS;
    enum_constant public static final java.util.concurrent.TimeUnit MINUTES;
    enum_constant public static final java.util.concurrent.TimeUnit NANOSECONDS;
    enum_constant public static final java.util.concurrent.TimeUnit SECONDS;
  }

  public class TimeoutException extends java.lang.Exception {
    ctor public TimeoutException();
    ctor public TimeoutException(String);
  }

  public interface TransferQueue<E> extends java.util.concurrent.BlockingQueue<E> {
    method public int getWaitingConsumerCount();
    method public boolean hasWaitingConsumer();
    method public void transfer(E) throws java.lang.InterruptedException;
    method public boolean tryTransfer(E);
    method public boolean tryTransfer(E, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
  }

}

package java.util.concurrent.atomic {

  public class AtomicBoolean implements java.io.Serializable {
    ctor public AtomicBoolean(boolean);
    ctor public AtomicBoolean();
    method public final boolean compareAndExchange(boolean, boolean);
    method public final boolean compareAndExchangeAcquire(boolean, boolean);
    method public final boolean compareAndExchangeRelease(boolean, boolean);
    method public final boolean compareAndSet(boolean, boolean);
    method public final boolean get();
    method public final boolean getAcquire();
    method public final boolean getAndSet(boolean);
    method public final boolean getOpaque();
    method public final boolean getPlain();
    method public final void lazySet(boolean);
    method public final void set(boolean);
    method public final void setOpaque(boolean);
    method public final void setPlain(boolean);
    method public final void setRelease(boolean);
    method @Deprecated public boolean weakCompareAndSet(boolean, boolean);
    method public final boolean weakCompareAndSetAcquire(boolean, boolean);
    method public boolean weakCompareAndSetPlain(boolean, boolean);
    method public final boolean weakCompareAndSetRelease(boolean, boolean);
    method public final boolean weakCompareAndSetVolatile(boolean, boolean);
  }

  public class AtomicInteger extends java.lang.Number implements java.io.Serializable {
    ctor public AtomicInteger(int);
    ctor public AtomicInteger();
    method public final int accumulateAndGet(int, java.util.function.IntBinaryOperator);
    method public final int addAndGet(int);
    method public final int compareAndExchange(int, int);
    method public final int compareAndExchangeAcquire(int, int);
    method public final int compareAndExchangeRelease(int, int);
    method public final boolean compareAndSet(int, int);
    method public final int decrementAndGet();
    method public double doubleValue();
    method public float floatValue();
    method public final int get();
    method public final int getAcquire();
    method public final int getAndAccumulate(int, java.util.function.IntBinaryOperator);
    method public final int getAndAdd(int);
    method public final int getAndDecrement();
    method public final int getAndIncrement();
    method public final int getAndSet(int);
    method public final int getAndUpdate(java.util.function.IntUnaryOperator);
    method public final int getOpaque();
    method public final int getPlain();
    method public final int incrementAndGet();
    method public int intValue();
    method public final void lazySet(int);
    method public long longValue();
    method public final void set(int);
    method public final void setOpaque(int);
    method public final void setPlain(int);
    method public final void setRelease(int);
    method public final int updateAndGet(java.util.function.IntUnaryOperator);
    method @Deprecated public final boolean weakCompareAndSet(int, int);
    method public final boolean weakCompareAndSetAcquire(int, int);
    method public final boolean weakCompareAndSetPlain(int, int);
    method public final boolean weakCompareAndSetRelease(int, int);
    method public final boolean weakCompareAndSetVolatile(int, int);
  }

  public class AtomicIntegerArray implements java.io.Serializable {
    ctor public AtomicIntegerArray(int);
    ctor public AtomicIntegerArray(int[]);
    method public final int accumulateAndGet(int, int, java.util.function.IntBinaryOperator);
    method public final int addAndGet(int, int);
    method public final int compareAndExchange(int, int, int);
    method public final int compareAndExchangeAcquire(int, int, int);
    method public final int compareAndExchangeRelease(int, int, int);
    method public final boolean compareAndSet(int, int, int);
    method public final int decrementAndGet(int);
    method public final int get(int);
    method public final int getAcquire(int);
    method public final int getAndAccumulate(int, int, java.util.function.IntBinaryOperator);
    method public final int getAndAdd(int, int);
    method public final int getAndDecrement(int);
    method public final int getAndIncrement(int);
    method public final int getAndSet(int, int);
    method public final int getAndUpdate(int, java.util.function.IntUnaryOperator);
    method public final int getOpaque(int);
    method public final int getPlain(int);
    method public final int incrementAndGet(int);
    method public final void lazySet(int, int);
    method public final int length();
    method public final void set(int, int);
    method public final void setOpaque(int, int);
    method public final void setPlain(int, int);
    method public final void setRelease(int, int);
    method public final int updateAndGet(int, java.util.function.IntUnaryOperator);
    method @Deprecated public final boolean weakCompareAndSet(int, int, int);
    method public final boolean weakCompareAndSetAcquire(int, int, int);
    method public final boolean weakCompareAndSetPlain(int, int, int);
    method public final boolean weakCompareAndSetRelease(int, int, int);
    method public final boolean weakCompareAndSetVolatile(int, int, int);
  }

  public abstract class AtomicIntegerFieldUpdater<T> {
    ctor protected AtomicIntegerFieldUpdater();
    method public final int accumulateAndGet(T, int, java.util.function.IntBinaryOperator);
    method public int addAndGet(T, int);
    method public abstract boolean compareAndSet(T, int, int);
    method public int decrementAndGet(T);
    method public abstract int get(T);
    method public final int getAndAccumulate(T, int, java.util.function.IntBinaryOperator);
    method public int getAndAdd(T, int);
    method public int getAndDecrement(T);
    method public int getAndIncrement(T);
    method public int getAndSet(T, int);
    method public final int getAndUpdate(T, java.util.function.IntUnaryOperator);
    method public int incrementAndGet(T);
    method public abstract void lazySet(T, int);
    method public static <U> java.util.concurrent.atomic.AtomicIntegerFieldUpdater<U> newUpdater(Class<U>, String);
    method public abstract void set(T, int);
    method public final int updateAndGet(T, java.util.function.IntUnaryOperator);
    method public abstract boolean weakCompareAndSet(T, int, int);
  }

  public class AtomicLong extends java.lang.Number implements java.io.Serializable {
    ctor public AtomicLong(long);
    ctor public AtomicLong();
    method public final long accumulateAndGet(long, java.util.function.LongBinaryOperator);
    method public final long addAndGet(long);
    method public final long compareAndExchange(long, long);
    method public final long compareAndExchangeAcquire(long, long);
    method public final long compareAndExchangeRelease(long, long);
    method public final boolean compareAndSet(long, long);
    method public final long decrementAndGet();
    method public double doubleValue();
    method public float floatValue();
    method public final long get();
    method public final long getAcquire();
    method public final long getAndAccumulate(long, java.util.function.LongBinaryOperator);
    method public final long getAndAdd(long);
    method public final long getAndDecrement();
    method public final long getAndIncrement();
    method public final long getAndSet(long);
    method public final long getAndUpdate(java.util.function.LongUnaryOperator);
    method public final long getOpaque();
    method public final long getPlain();
    method public final long incrementAndGet();
    method public int intValue();
    method public final void lazySet(long);
    method public long longValue();
    method public final void set(long);
    method public final void setOpaque(long);
    method public final void setPlain(long);
    method public final void setRelease(long);
    method public final long updateAndGet(java.util.function.LongUnaryOperator);
    method @Deprecated public final boolean weakCompareAndSet(long, long);
    method public final boolean weakCompareAndSetAcquire(long, long);
    method public final boolean weakCompareAndSetPlain(long, long);
    method public final boolean weakCompareAndSetRelease(long, long);
    method public final boolean weakCompareAndSetVolatile(long, long);
  }

  public class AtomicLongArray implements java.io.Serializable {
    ctor public AtomicLongArray(int);
    ctor public AtomicLongArray(long[]);
    method public final long accumulateAndGet(int, long, java.util.function.LongBinaryOperator);
    method public long addAndGet(int, long);
    method public final long compareAndExchange(int, long, long);
    method public final long compareAndExchangeAcquire(int, long, long);
    method public final long compareAndExchangeRelease(int, long, long);
    method public final boolean compareAndSet(int, long, long);
    method public final long decrementAndGet(int);
    method public final long get(int);
    method public final long getAcquire(int);
    method public final long getAndAccumulate(int, long, java.util.function.LongBinaryOperator);
    method public final long getAndAdd(int, long);
    method public final long getAndDecrement(int);
    method public final long getAndIncrement(int);
    method public final long getAndSet(int, long);
    method public final long getAndUpdate(int, java.util.function.LongUnaryOperator);
    method public final long getOpaque(int);
    method public final long getPlain(int);
    method public final long incrementAndGet(int);
    method public final void lazySet(int, long);
    method public final int length();
    method public final void set(int, long);
    method public final void setOpaque(int, long);
    method public final void setPlain(int, long);
    method public final void setRelease(int, long);
    method public final long updateAndGet(int, java.util.function.LongUnaryOperator);
    method @Deprecated public final boolean weakCompareAndSet(int, long, long);
    method public final boolean weakCompareAndSetAcquire(int, long, long);
    method public final boolean weakCompareAndSetPlain(int, long, long);
    method public final boolean weakCompareAndSetRelease(int, long, long);
    method public final boolean weakCompareAndSetVolatile(int, long, long);
  }

  public abstract class AtomicLongFieldUpdater<T> {
    ctor protected AtomicLongFieldUpdater();
    method public final long accumulateAndGet(T, long, java.util.function.LongBinaryOperator);
    method public long addAndGet(T, long);
    method public abstract boolean compareAndSet(T, long, long);
    method public long decrementAndGet(T);
    method public abstract long get(T);
    method public final long getAndAccumulate(T, long, java.util.function.LongBinaryOperator);
    method public long getAndAdd(T, long);
    method public long getAndDecrement(T);
    method public long getAndIncrement(T);
    method public long getAndSet(T, long);
    method public final long getAndUpdate(T, java.util.function.LongUnaryOperator);
    method public long incrementAndGet(T);
    method public abstract void lazySet(T, long);
    method public static <U> java.util.concurrent.atomic.AtomicLongFieldUpdater<U> newUpdater(Class<U>, String);
    method public abstract void set(T, long);
    method public final long updateAndGet(T, java.util.function.LongUnaryOperator);
    method public abstract boolean weakCompareAndSet(T, long, long);
  }

  public class AtomicMarkableReference<V> {
    ctor public AtomicMarkableReference(V, boolean);
    method public boolean attemptMark(V, boolean);
    method public boolean compareAndSet(V, V, boolean, boolean);
    method public V get(boolean[]);
    method public V getReference();
    method public boolean isMarked();
    method public void set(V, boolean);
    method public boolean weakCompareAndSet(V, V, boolean, boolean);
  }

  public class AtomicReference<V> implements java.io.Serializable {
    ctor public AtomicReference(V);
    ctor public AtomicReference();
    method public final V accumulateAndGet(V, java.util.function.BinaryOperator<V>);
    method public final V compareAndExchange(V, V);
    method public final V compareAndExchangeAcquire(V, V);
    method public final V compareAndExchangeRelease(V, V);
    method public final boolean compareAndSet(V, V);
    method public final V get();
    method public final V getAcquire();
    method public final V getAndAccumulate(V, java.util.function.BinaryOperator<V>);
    method public final V getAndSet(V);
    method public final V getAndUpdate(java.util.function.UnaryOperator<V>);
    method public final V getOpaque();
    method public final V getPlain();
    method public final void lazySet(V);
    method public final void set(V);
    method public final void setOpaque(V);
    method public final void setPlain(V);
    method public final void setRelease(V);
    method public final V updateAndGet(java.util.function.UnaryOperator<V>);
    method @Deprecated public final boolean weakCompareAndSet(V, V);
    method public final boolean weakCompareAndSetAcquire(V, V);
    method public final boolean weakCompareAndSetPlain(V, V);
    method public final boolean weakCompareAndSetRelease(V, V);
    method public final boolean weakCompareAndSetVolatile(V, V);
  }

  public class AtomicReferenceArray<E> implements java.io.Serializable {
    ctor public AtomicReferenceArray(int);
    ctor public AtomicReferenceArray(E[]);
    method public final E accumulateAndGet(int, E, java.util.function.BinaryOperator<E>);
    method public final E compareAndExchange(int, E, E);
    method public final E compareAndExchangeAcquire(int, E, E);
    method public final E compareAndExchangeRelease(int, E, E);
    method public final boolean compareAndSet(int, E, E);
    method public final E get(int);
    method public final E getAcquire(int);
    method public final E getAndAccumulate(int, E, java.util.function.BinaryOperator<E>);
    method public final E getAndSet(int, E);
    method public final E getAndUpdate(int, java.util.function.UnaryOperator<E>);
    method public final E getOpaque(int);
    method public final E getPlain(int);
    method public final void lazySet(int, E);
    method public final int length();
    method public final void set(int, E);
    method public final void setOpaque(int, E);
    method public final void setPlain(int, E);
    method public final void setRelease(int, E);
    method public final E updateAndGet(int, java.util.function.UnaryOperator<E>);
    method @Deprecated public final boolean weakCompareAndSet(int, E, E);
    method public final boolean weakCompareAndSetAcquire(int, E, E);
    method public final boolean weakCompareAndSetPlain(int, E, E);
    method public final boolean weakCompareAndSetRelease(int, E, E);
    method public final boolean weakCompareAndSetVolatile(int, E, E);
  }

  public abstract class AtomicReferenceFieldUpdater<T, V> {
    ctor protected AtomicReferenceFieldUpdater();
    method public final V accumulateAndGet(T, V, java.util.function.BinaryOperator<V>);
    method public abstract boolean compareAndSet(T, V, V);
    method public abstract V get(T);
    method public final V getAndAccumulate(T, V, java.util.function.BinaryOperator<V>);
    method public V getAndSet(T, V);
    method public final V getAndUpdate(T, java.util.function.UnaryOperator<V>);
    method public abstract void lazySet(T, V);
    method public static <U, W> java.util.concurrent.atomic.AtomicReferenceFieldUpdater<U,W> newUpdater(Class<U>, Class<W>, String);
    method public abstract void set(T, V);
    method public final V updateAndGet(T, java.util.function.UnaryOperator<V>);
    method public abstract boolean weakCompareAndSet(T, V, V);
  }

  public class AtomicStampedReference<V> {
    ctor public AtomicStampedReference(V, int);
    method public boolean attemptStamp(V, int);
    method public boolean compareAndSet(V, V, int, int);
    method public V get(int[]);
    method public V getReference();
    method public int getStamp();
    method public void set(V, int);
    method public boolean weakCompareAndSet(V, V, int, int);
  }

  public class DoubleAccumulator extends java.lang.Number implements java.io.Serializable {
    ctor public DoubleAccumulator(java.util.function.DoubleBinaryOperator, double);
    method public void accumulate(double);
    method public double doubleValue();
    method public float floatValue();
    method public double get();
    method public double getThenReset();
    method public int intValue();
    method public long longValue();
    method public void reset();
  }

  public class DoubleAdder extends java.lang.Number implements java.io.Serializable {
    ctor public DoubleAdder();
    method public void add(double);
    method public double doubleValue();
    method public float floatValue();
    method public int intValue();
    method public long longValue();
    method public void reset();
    method public double sum();
    method public double sumThenReset();
  }

  public class LongAccumulator extends java.lang.Number implements java.io.Serializable {
    ctor public LongAccumulator(java.util.function.LongBinaryOperator, long);
    method public void accumulate(long);
    method public double doubleValue();
    method public float floatValue();
    method public long get();
    method public long getThenReset();
    method public int intValue();
    method public long longValue();
    method public void reset();
  }

  public class LongAdder extends java.lang.Number implements java.io.Serializable {
    ctor public LongAdder();
    method public void add(long);
    method public void decrement();
    method public double doubleValue();
    method public float floatValue();
    method public void increment();
    method public int intValue();
    method public long longValue();
    method public void reset();
    method public long sum();
    method public long sumThenReset();
  }

}

package java.util.concurrent.locks {

  public abstract class AbstractOwnableSynchronizer implements java.io.Serializable {
    ctor protected AbstractOwnableSynchronizer();
    method protected final Thread getExclusiveOwnerThread();
    method protected final void setExclusiveOwnerThread(Thread);
  }

  public abstract class AbstractQueuedLongSynchronizer extends java.util.concurrent.locks.AbstractOwnableSynchronizer implements java.io.Serializable {
    ctor protected AbstractQueuedLongSynchronizer();
    method public final void acquire(long);
    method public final void acquireInterruptibly(long) throws java.lang.InterruptedException;
    method public final void acquireShared(long);
    method public final void acquireSharedInterruptibly(long) throws java.lang.InterruptedException;
    method protected final boolean compareAndSetState(long, long);
    method public final java.util.Collection<java.lang.Thread> getExclusiveQueuedThreads();
    method public final Thread getFirstQueuedThread();
    method public final int getQueueLength();
    method public final java.util.Collection<java.lang.Thread> getQueuedThreads();
    method public final java.util.Collection<java.lang.Thread> getSharedQueuedThreads();
    method protected final long getState();
    method public final int getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject);
    method public final java.util.Collection<java.lang.Thread> getWaitingThreads(java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject);
    method public final boolean hasContended();
    method public final boolean hasQueuedPredecessors();
    method public final boolean hasQueuedThreads();
    method public final boolean hasWaiters(java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject);
    method protected boolean isHeldExclusively();
    method public final boolean isQueued(Thread);
    method public final boolean owns(java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject);
    method public final boolean release(long);
    method public final boolean releaseShared(long);
    method protected final void setState(long);
    method protected boolean tryAcquire(long);
    method public final boolean tryAcquireNanos(long, long) throws java.lang.InterruptedException;
    method protected long tryAcquireShared(long);
    method public final boolean tryAcquireSharedNanos(long, long) throws java.lang.InterruptedException;
    method protected boolean tryRelease(long);
    method protected boolean tryReleaseShared(long);
  }

  public class AbstractQueuedLongSynchronizer.ConditionObject implements java.util.concurrent.locks.Condition java.io.Serializable {
    ctor public AbstractQueuedLongSynchronizer.ConditionObject();
    method public final void await() throws java.lang.InterruptedException;
    method public final boolean await(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public final long awaitNanos(long) throws java.lang.InterruptedException;
    method public final void awaitUninterruptibly();
    method public final boolean awaitUntil(java.util.Date) throws java.lang.InterruptedException;
    method protected final int getWaitQueueLength();
    method protected final java.util.Collection<java.lang.Thread> getWaitingThreads();
    method protected final boolean hasWaiters();
    method public final void signal();
    method public final void signalAll();
  }

  public abstract class AbstractQueuedSynchronizer extends java.util.concurrent.locks.AbstractOwnableSynchronizer implements java.io.Serializable {
    ctor protected AbstractQueuedSynchronizer();
    method public final void acquire(int);
    method public final void acquireInterruptibly(int) throws java.lang.InterruptedException;
    method public final void acquireShared(int);
    method public final void acquireSharedInterruptibly(int) throws java.lang.InterruptedException;
    method protected final boolean compareAndSetState(int, int);
    method public final java.util.Collection<java.lang.Thread> getExclusiveQueuedThreads();
    method public final Thread getFirstQueuedThread();
    method public final int getQueueLength();
    method public final java.util.Collection<java.lang.Thread> getQueuedThreads();
    method public final java.util.Collection<java.lang.Thread> getSharedQueuedThreads();
    method protected final int getState();
    method public final int getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject);
    method public final java.util.Collection<java.lang.Thread> getWaitingThreads(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject);
    method public final boolean hasContended();
    method public final boolean hasQueuedPredecessors();
    method public final boolean hasQueuedThreads();
    method public final boolean hasWaiters(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject);
    method protected boolean isHeldExclusively();
    method public final boolean isQueued(Thread);
    method public final boolean owns(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject);
    method public final boolean release(int);
    method public final boolean releaseShared(int);
    method protected final void setState(int);
    method protected boolean tryAcquire(int);
    method public final boolean tryAcquireNanos(int, long) throws java.lang.InterruptedException;
    method protected int tryAcquireShared(int);
    method public final boolean tryAcquireSharedNanos(int, long) throws java.lang.InterruptedException;
    method protected boolean tryRelease(int);
    method protected boolean tryReleaseShared(int);
  }

  public class AbstractQueuedSynchronizer.ConditionObject implements java.util.concurrent.locks.Condition java.io.Serializable {
    ctor public AbstractQueuedSynchronizer.ConditionObject();
    method public final void await() throws java.lang.InterruptedException;
    method public final boolean await(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public final long awaitNanos(long) throws java.lang.InterruptedException;
    method public final void awaitUninterruptibly();
    method public final boolean awaitUntil(java.util.Date) throws java.lang.InterruptedException;
    method protected final int getWaitQueueLength();
    method protected final java.util.Collection<java.lang.Thread> getWaitingThreads();
    method protected final boolean hasWaiters();
    method public final void signal();
    method public final void signalAll();
  }

  public interface Condition {
    method public void await() throws java.lang.InterruptedException;
    method public boolean await(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public long awaitNanos(long) throws java.lang.InterruptedException;
    method public void awaitUninterruptibly();
    method public boolean awaitUntil(java.util.Date) throws java.lang.InterruptedException;
    method public void signal();
    method public void signalAll();
  }

  public interface Lock {
    method public void lock();
    method public void lockInterruptibly() throws java.lang.InterruptedException;
    method public java.util.concurrent.locks.Condition newCondition();
    method public boolean tryLock();
    method public boolean tryLock(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public void unlock();
  }

  public class LockSupport {
    method public static Object getBlocker(Thread);
    method public static void park(Object);
    method public static void park();
    method public static void parkNanos(Object, long);
    method public static void parkNanos(long);
    method public static void parkUntil(Object, long);
    method public static void parkUntil(long);
    method public static void setCurrentBlocker(Object);
    method public static void unpark(Thread);
  }

  public interface ReadWriteLock {
    method public java.util.concurrent.locks.Lock readLock();
    method public java.util.concurrent.locks.Lock writeLock();
  }

  public class ReentrantLock implements java.util.concurrent.locks.Lock java.io.Serializable {
    ctor public ReentrantLock();
    ctor public ReentrantLock(boolean);
    method public int getHoldCount();
    method protected Thread getOwner();
    method public final int getQueueLength();
    method protected java.util.Collection<java.lang.Thread> getQueuedThreads();
    method public int getWaitQueueLength(java.util.concurrent.locks.Condition);
    method protected java.util.Collection<java.lang.Thread> getWaitingThreads(java.util.concurrent.locks.Condition);
    method public final boolean hasQueuedThread(Thread);
    method public final boolean hasQueuedThreads();
    method public boolean hasWaiters(java.util.concurrent.locks.Condition);
    method public final boolean isFair();
    method public boolean isHeldByCurrentThread();
    method public boolean isLocked();
    method public void lock();
    method public void lockInterruptibly() throws java.lang.InterruptedException;
    method public java.util.concurrent.locks.Condition newCondition();
    method public boolean tryLock();
    method public boolean tryLock(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public void unlock();
  }

  public class ReentrantReadWriteLock implements java.util.concurrent.locks.ReadWriteLock java.io.Serializable {
    ctor public ReentrantReadWriteLock();
    ctor public ReentrantReadWriteLock(boolean);
    method protected Thread getOwner();
    method public final int getQueueLength();
    method protected java.util.Collection<java.lang.Thread> getQueuedReaderThreads();
    method protected java.util.Collection<java.lang.Thread> getQueuedThreads();
    method protected java.util.Collection<java.lang.Thread> getQueuedWriterThreads();
    method public int getReadHoldCount();
    method public int getReadLockCount();
    method public int getWaitQueueLength(java.util.concurrent.locks.Condition);
    method protected java.util.Collection<java.lang.Thread> getWaitingThreads(java.util.concurrent.locks.Condition);
    method public int getWriteHoldCount();
    method public final boolean hasQueuedThread(Thread);
    method public final boolean hasQueuedThreads();
    method public boolean hasWaiters(java.util.concurrent.locks.Condition);
    method public final boolean isFair();
    method public boolean isWriteLocked();
    method public boolean isWriteLockedByCurrentThread();
    method public java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock readLock();
    method public java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock writeLock();
  }

  public static class ReentrantReadWriteLock.ReadLock implements java.util.concurrent.locks.Lock java.io.Serializable {
    ctor protected ReentrantReadWriteLock.ReadLock(java.util.concurrent.locks.ReentrantReadWriteLock);
    method public void lock();
    method public void lockInterruptibly() throws java.lang.InterruptedException;
    method public java.util.concurrent.locks.Condition newCondition();
    method public boolean tryLock();
    method public boolean tryLock(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public void unlock();
  }

  public static class ReentrantReadWriteLock.WriteLock implements java.util.concurrent.locks.Lock java.io.Serializable {
    ctor protected ReentrantReadWriteLock.WriteLock(java.util.concurrent.locks.ReentrantReadWriteLock);
    method public int getHoldCount();
    method public boolean isHeldByCurrentThread();
    method public void lock();
    method public void lockInterruptibly() throws java.lang.InterruptedException;
    method public java.util.concurrent.locks.Condition newCondition();
    method public boolean tryLock();
    method public boolean tryLock(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public void unlock();
  }

  public class StampedLock implements java.io.Serializable {
    ctor public StampedLock();
    method public java.util.concurrent.locks.Lock asReadLock();
    method public java.util.concurrent.locks.ReadWriteLock asReadWriteLock();
    method public java.util.concurrent.locks.Lock asWriteLock();
    method public int getReadLockCount();
    method public static boolean isLockStamp(long);
    method public static boolean isOptimisticReadStamp(long);
    method public static boolean isReadLockStamp(long);
    method public boolean isReadLocked();
    method public static boolean isWriteLockStamp(long);
    method public boolean isWriteLocked();
    method public long readLock();
    method public long readLockInterruptibly() throws java.lang.InterruptedException;
    method public long tryConvertToOptimisticRead(long);
    method public long tryConvertToReadLock(long);
    method public long tryConvertToWriteLock(long);
    method public long tryOptimisticRead();
    method public long tryReadLock();
    method public long tryReadLock(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public boolean tryUnlockRead();
    method public boolean tryUnlockWrite();
    method public long tryWriteLock();
    method public long tryWriteLock(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
    method public void unlock(long);
    method public void unlockRead(long);
    method public void unlockWrite(long);
    method public boolean validate(long);
    method public long writeLock();
    method public long writeLockInterruptibly() throws java.lang.InterruptedException;
  }

}

package java.util.function {

  @java.lang.FunctionalInterface public interface BiConsumer<T, U> {
    method public void accept(T, U);
    method public default java.util.function.BiConsumer<T,U> andThen(java.util.function.BiConsumer<? super T,? super U>);
  }

  @java.lang.FunctionalInterface public interface BiFunction<T, U, R> {
    method public default <V> java.util.function.BiFunction<T,U,V> andThen(java.util.function.Function<? super R,? extends V>);
    method public R apply(T, U);
  }

  @java.lang.FunctionalInterface public interface BiPredicate<T, U> {
    method public default java.util.function.BiPredicate<T,U> and(java.util.function.BiPredicate<? super T,? super U>);
    method public default java.util.function.BiPredicate<T,U> negate();
    method public default java.util.function.BiPredicate<T,U> or(java.util.function.BiPredicate<? super T,? super U>);
    method public boolean test(T, U);
  }

  @java.lang.FunctionalInterface public interface BinaryOperator<T> extends java.util.function.BiFunction<T,T,T> {
    method public static <T> java.util.function.BinaryOperator<T> maxBy(java.util.Comparator<? super T>);
    method public static <T> java.util.function.BinaryOperator<T> minBy(java.util.Comparator<? super T>);
  }

  @java.lang.FunctionalInterface public interface BooleanSupplier {
    method public boolean getAsBoolean();
  }

  @java.lang.FunctionalInterface public interface Consumer<T> {
    method public void accept(T);
    method public default java.util.function.Consumer<T> andThen(java.util.function.Consumer<? super T>);
  }

  @java.lang.FunctionalInterface public interface DoubleBinaryOperator {
    method public double applyAsDouble(double, double);
  }

  @java.lang.FunctionalInterface public interface DoubleConsumer {
    method public void accept(double);
    method public default java.util.function.DoubleConsumer andThen(java.util.function.DoubleConsumer);
  }

  @java.lang.FunctionalInterface public interface DoubleFunction<R> {
    method public R apply(double);
  }

  @java.lang.FunctionalInterface public interface DoublePredicate {
    method public default java.util.function.DoublePredicate and(java.util.function.DoublePredicate);
    method public default java.util.function.DoublePredicate negate();
    method public default java.util.function.DoublePredicate or(java.util.function.DoublePredicate);
    method public boolean test(double);
  }

  @java.lang.FunctionalInterface public interface DoubleSupplier {
    method public double getAsDouble();
  }

  @java.lang.FunctionalInterface public interface DoubleToIntFunction {
    method public int applyAsInt(double);
  }

  @java.lang.FunctionalInterface public interface DoubleToLongFunction {
    method public long applyAsLong(double);
  }

  @java.lang.FunctionalInterface public interface DoubleUnaryOperator {
    method public default java.util.function.DoubleUnaryOperator andThen(java.util.function.DoubleUnaryOperator);
    method public double applyAsDouble(double);
    method public default java.util.function.DoubleUnaryOperator compose(java.util.function.DoubleUnaryOperator);
    method public static java.util.function.DoubleUnaryOperator identity();
  }

  @java.lang.FunctionalInterface public interface Function<T, R> {
    method public default <V> java.util.function.Function<T,V> andThen(java.util.function.Function<? super R,? extends V>);
    method public R apply(T);
    method public default <V> java.util.function.Function<V,R> compose(java.util.function.Function<? super V,? extends T>);
    method public static <T> java.util.function.Function<T,T> identity();
  }

  @java.lang.FunctionalInterface public interface IntBinaryOperator {
    method public int applyAsInt(int, int);
  }

  @java.lang.FunctionalInterface public interface IntConsumer {
    method public void accept(int);
    method public default java.util.function.IntConsumer andThen(java.util.function.IntConsumer);
  }

  @java.lang.FunctionalInterface public interface IntFunction<R> {
    method public R apply(int);
  }

  @java.lang.FunctionalInterface public interface IntPredicate {
    method public default java.util.function.IntPredicate and(java.util.function.IntPredicate);
    method public default java.util.function.IntPredicate negate();
    method public default java.util.function.IntPredicate or(java.util.function.IntPredicate);
    method public boolean test(int);
  }

  @java.lang.FunctionalInterface public interface IntSupplier {
    method public int getAsInt();
  }

  @java.lang.FunctionalInterface public interface IntToDoubleFunction {
    method public double applyAsDouble(int);
  }

  @java.lang.FunctionalInterface public interface IntToLongFunction {
    method public long applyAsLong(int);
  }

  @java.lang.FunctionalInterface public interface IntUnaryOperator {
    method public default java.util.function.IntUnaryOperator andThen(java.util.function.IntUnaryOperator);
    method public int applyAsInt(int);
    method public default java.util.function.IntUnaryOperator compose(java.util.function.IntUnaryOperator);
    method public static java.util.function.IntUnaryOperator identity();
  }

  @java.lang.FunctionalInterface public interface LongBinaryOperator {
    method public long applyAsLong(long, long);
  }

  @java.lang.FunctionalInterface public interface LongConsumer {
    method public void accept(long);
    method public default java.util.function.LongConsumer andThen(java.util.function.LongConsumer);
  }

  @java.lang.FunctionalInterface public interface LongFunction<R> {
    method public R apply(long);
  }

  @java.lang.FunctionalInterface public interface LongPredicate {
    method public default java.util.function.LongPredicate and(java.util.function.LongPredicate);
    method public default java.util.function.LongPredicate negate();
    method public default java.util.function.LongPredicate or(java.util.function.LongPredicate);
    method public boolean test(long);
  }

  @java.lang.FunctionalInterface public interface LongSupplier {
    method public long getAsLong();
  }

  @java.lang.FunctionalInterface public interface LongToDoubleFunction {
    method public double applyAsDouble(long);
  }

  @java.lang.FunctionalInterface public interface LongToIntFunction {
    method public int applyAsInt(long);
  }

  @java.lang.FunctionalInterface public interface LongUnaryOperator {
    method public default java.util.function.LongUnaryOperator andThen(java.util.function.LongUnaryOperator);
    method public long applyAsLong(long);
    method public default java.util.function.LongUnaryOperator compose(java.util.function.LongUnaryOperator);
    method public static java.util.function.LongUnaryOperator identity();
  }

  @java.lang.FunctionalInterface public interface ObjDoubleConsumer<T> {
    method public void accept(T, double);
  }

  @java.lang.FunctionalInterface public interface ObjIntConsumer<T> {
    method public void accept(T, int);
  }

  @java.lang.FunctionalInterface public interface ObjLongConsumer<T> {
    method public void accept(T, long);
  }

  @java.lang.FunctionalInterface public interface Predicate<T> {
    method public default java.util.function.Predicate<T> and(java.util.function.Predicate<? super T>);
    method public static <T> java.util.function.Predicate<T> isEqual(Object);
    method public default java.util.function.Predicate<T> negate();
    method public static <T> java.util.function.Predicate<T> not(java.util.function.Predicate<? super T>);
    method public default java.util.function.Predicate<T> or(java.util.function.Predicate<? super T>);
    method public boolean test(T);
  }

  @java.lang.FunctionalInterface public interface Supplier<T> {
    method public T get();
  }

  @java.lang.FunctionalInterface public interface ToDoubleBiFunction<T, U> {
    method public double applyAsDouble(T, U);
  }

  @java.lang.FunctionalInterface public interface ToDoubleFunction<T> {
    method public double applyAsDouble(T);
  }

  @java.lang.FunctionalInterface public interface ToIntBiFunction<T, U> {
    method public int applyAsInt(T, U);
  }

  @java.lang.FunctionalInterface public interface ToIntFunction<T> {
    method public int applyAsInt(T);
  }

  @java.lang.FunctionalInterface public interface ToLongBiFunction<T, U> {
    method public long applyAsLong(T, U);
  }

  @java.lang.FunctionalInterface public interface ToLongFunction<T> {
    method public long applyAsLong(T);
  }

  @java.lang.FunctionalInterface public interface UnaryOperator<T> extends java.util.function.Function<T,T> {
    method public static <T> java.util.function.UnaryOperator<T> identity();
  }

}

package java.util.jar {

  public class Attributes implements java.lang.Cloneable java.util.Map<java.lang.Object,java.lang.Object> {
    ctor public Attributes();
    ctor public Attributes(int);
    ctor public Attributes(java.util.jar.Attributes);
    method public void clear();
    method public Object clone();
    method public boolean containsKey(Object);
    method public boolean containsValue(Object);
    method public java.util.Set<java.util.Map.Entry<java.lang.Object,java.lang.Object>> entrySet();
    method public boolean equals(Object);
    method public Object get(Object);
    method public String getValue(String);
    method public String getValue(java.util.jar.Attributes.Name);
    method public int hashCode();
    method public boolean isEmpty();
    method public java.util.Set<java.lang.Object> keySet();
    method public Object put(Object, Object);
    method public void putAll(java.util.Map<?,?>);
    method public String putValue(String, String);
    method public Object remove(Object);
    method public int size();
    method public java.util.Collection<java.lang.Object> values();
    field protected java.util.Map<java.lang.Object,java.lang.Object> map;
  }

  public static class Attributes.Name {
    ctor public Attributes.Name(String);
    field public static final java.util.jar.Attributes.Name CLASS_PATH;
    field public static final java.util.jar.Attributes.Name CONTENT_TYPE;
    field @Deprecated public static final java.util.jar.Attributes.Name EXTENSION_INSTALLATION;
    field public static final java.util.jar.Attributes.Name EXTENSION_LIST;
    field public static final java.util.jar.Attributes.Name EXTENSION_NAME;
    field public static final java.util.jar.Attributes.Name IMPLEMENTATION_TITLE;
    field @Deprecated public static final java.util.jar.Attributes.Name IMPLEMENTATION_URL;
    field public static final java.util.jar.Attributes.Name IMPLEMENTATION_VENDOR;
    field @Deprecated public static final java.util.jar.Attributes.Name IMPLEMENTATION_VENDOR_ID;
    field public static final java.util.jar.Attributes.Name IMPLEMENTATION_VERSION;
    field public static final java.util.jar.Attributes.Name MAIN_CLASS;
    field public static final java.util.jar.Attributes.Name MANIFEST_VERSION;
    field public static final java.util.jar.Attributes.Name SEALED;
    field public static final java.util.jar.Attributes.Name SIGNATURE_VERSION;
    field public static final java.util.jar.Attributes.Name SPECIFICATION_TITLE;
    field public static final java.util.jar.Attributes.Name SPECIFICATION_VENDOR;
    field public static final java.util.jar.Attributes.Name SPECIFICATION_VERSION;
  }

  public class JarEntry extends java.util.zip.ZipEntry {
    ctor public JarEntry(String);
    ctor public JarEntry(java.util.zip.ZipEntry);
    ctor public JarEntry(java.util.jar.JarEntry);
    method public java.util.jar.Attributes getAttributes() throws java.io.IOException;
    method public java.security.cert.Certificate[] getCertificates();
    method public java.security.CodeSigner[] getCodeSigners();
    method public String getRealName();
    field public static final int CENATT = 36; // 0x24
    field public static final int CENATX = 38; // 0x26
    field public static final int CENCOM = 32; // 0x20
    field public static final int CENCRC = 16; // 0x10
    field public static final int CENDSK = 34; // 0x22
    field public static final int CENEXT = 30; // 0x1e
    field public static final int CENFLG = 8; // 0x8
    field public static final int CENHDR = 46; // 0x2e
    field public static final int CENHOW = 10; // 0xa
    field public static final int CENLEN = 24; // 0x18
    field public static final int CENNAM = 28; // 0x1c
    field public static final int CENOFF = 42; // 0x2a
    field public static final long CENSIG = 33639248L; // 0x2014b50L
    field public static final int CENSIZ = 20; // 0x14
    field public static final int CENTIM = 12; // 0xc
    field public static final int CENVEM = 4; // 0x4
    field public static final int CENVER = 6; // 0x6
    field public static final int ENDCOM = 20; // 0x14
    field public static final int ENDHDR = 22; // 0x16
    field public static final int ENDOFF = 16; // 0x10
    field public static final long ENDSIG = 101010256L; // 0x6054b50L
    field public static final int ENDSIZ = 12; // 0xc
    field public static final int ENDSUB = 8; // 0x8
    field public static final int ENDTOT = 10; // 0xa
    field public static final int EXTCRC = 4; // 0x4
    field public static final int EXTHDR = 16; // 0x10
    field public static final int EXTLEN = 12; // 0xc
    field public static final long EXTSIG = 134695760L; // 0x8074b50L
    field public static final int EXTSIZ = 8; // 0x8
    field public static final int LOCCRC = 14; // 0xe
    field public static final int LOCEXT = 28; // 0x1c
    field public static final int LOCFLG = 6; // 0x6
    field public static final int LOCHDR = 30; // 0x1e
    field public static final int LOCHOW = 8; // 0x8
    field public static final int LOCLEN = 22; // 0x16
    field public static final int LOCNAM = 26; // 0x1a
    field public static final long LOCSIG = 67324752L; // 0x4034b50L
    field public static final int LOCSIZ = 18; // 0x12
    field public static final int LOCTIM = 10; // 0xa
    field public static final int LOCVER = 4; // 0x4
  }

  public class JarException extends java.util.zip.ZipException {
    ctor public JarException();
    ctor public JarException(String);
  }

  public class JarFile extends java.util.zip.ZipFile {
    ctor public JarFile(String) throws java.io.IOException;
    ctor public JarFile(String, boolean) throws java.io.IOException;
    ctor public JarFile(java.io.File) throws java.io.IOException;
    ctor public JarFile(java.io.File, boolean) throws java.io.IOException;
    ctor public JarFile(java.io.File, boolean, int) throws java.io.IOException;
    method public java.util.Enumeration<java.util.jar.JarEntry> entries();
    method public java.util.jar.JarEntry getJarEntry(String);
    method public java.util.jar.Manifest getManifest() throws java.io.IOException;
    method public java.util.stream.Stream<java.util.jar.JarEntry> stream();
    field public static final int CENATT = 36; // 0x24
    field public static final int CENATX = 38; // 0x26
    field public static final int CENCOM = 32; // 0x20
    field public static final int CENCRC = 16; // 0x10
    field public static final int CENDSK = 34; // 0x22
    field public static final int CENEXT = 30; // 0x1e
    field public static final int CENFLG = 8; // 0x8
    field public static final int CENHDR = 46; // 0x2e
    field public static final int CENHOW = 10; // 0xa
    field public static final int CENLEN = 24; // 0x18
    field public static final int CENNAM = 28; // 0x1c
    field public static final int CENOFF = 42; // 0x2a
    field public static final long CENSIG = 33639248L; // 0x2014b50L
    field public static final int CENSIZ = 20; // 0x14
    field public static final int CENTIM = 12; // 0xc
    field public static final int CENVEM = 4; // 0x4
    field public static final int CENVER = 6; // 0x6
    field public static final int ENDCOM = 20; // 0x14
    field public static final int ENDHDR = 22; // 0x16
    field public static final int ENDOFF = 16; // 0x10
    field public static final long ENDSIG = 101010256L; // 0x6054b50L
    field public static final int ENDSIZ = 12; // 0xc
    field public static final int ENDSUB = 8; // 0x8
    field public static final int ENDTOT = 10; // 0xa
    field public static final int EXTCRC = 4; // 0x4
    field public static final int EXTHDR = 16; // 0x10
    field public static final int EXTLEN = 12; // 0xc
    field public static final long EXTSIG = 134695760L; // 0x8074b50L
    field public static final int EXTSIZ = 8; // 0x8
    field public static final int LOCCRC = 14; // 0xe
    field public static final int LOCEXT = 28; // 0x1c
    field public static final int LOCFLG = 6; // 0x6
    field public static final int LOCHDR = 30; // 0x1e
    field public static final int LOCHOW = 8; // 0x8
    field public static final int LOCLEN = 22; // 0x16
    field public static final int LOCNAM = 26; // 0x1a
    field public static final long LOCSIG = 67324752L; // 0x4034b50L
    field public static final int LOCSIZ = 18; // 0x12
    field public static final int LOCTIM = 10; // 0xa
    field public static final int LOCVER = 4; // 0x4
    field public static final String MANIFEST_NAME = "META-INF/MANIFEST.MF";
  }

  public class JarInputStream extends java.util.zip.ZipInputStream {
    ctor public JarInputStream(java.io.InputStream) throws java.io.IOException;
    ctor public JarInputStream(java.io.InputStream, boolean) throws java.io.IOException;
    method public java.util.jar.Manifest getManifest();
    method public java.util.jar.JarEntry getNextJarEntry() throws java.io.IOException;
    field public static final int CENATT = 36; // 0x24
    field public static final int CENATX = 38; // 0x26
    field public static final int CENCOM = 32; // 0x20
    field public static final int CENCRC = 16; // 0x10
    field public static final int CENDSK = 34; // 0x22
    field public static final int CENEXT = 30; // 0x1e
    field public static final int CENFLG = 8; // 0x8
    field public static final int CENHDR = 46; // 0x2e
    field public static final int CENHOW = 10; // 0xa
    field public static final int CENLEN = 24; // 0x18
    field public static final int CENNAM = 28; // 0x1c
    field public static final int CENOFF = 42; // 0x2a
    field public static final long CENSIG = 33639248L; // 0x2014b50L
    field public static final int CENSIZ = 20; // 0x14
    field public static final int CENTIM = 12; // 0xc
    field public static final int CENVEM = 4; // 0x4
    field public static final int CENVER = 6; // 0x6
    field public static final int ENDCOM = 20; // 0x14
    field public static final int ENDHDR = 22; // 0x16
    field public static final int ENDOFF = 16; // 0x10
    field public static final long ENDSIG = 101010256L; // 0x6054b50L
    field public static final int ENDSIZ = 12; // 0xc
    field public static final int ENDSUB = 8; // 0x8
    field public static final int ENDTOT = 10; // 0xa
    field public static final int EXTCRC = 4; // 0x4
    field public static final int EXTHDR = 16; // 0x10
    field public static final int EXTLEN = 12; // 0xc
    field public static final long EXTSIG = 134695760L; // 0x8074b50L
    field public static final int EXTSIZ = 8; // 0x8
    field public static final int LOCCRC = 14; // 0xe
    field public static final int LOCEXT = 28; // 0x1c
    field public static final int LOCFLG = 6; // 0x6
    field public static final int LOCHDR = 30; // 0x1e
    field public static final int LOCHOW = 8; // 0x8
    field public static final int LOCLEN = 22; // 0x16
    field public static final int LOCNAM = 26; // 0x1a
    field public static final long LOCSIG = 67324752L; // 0x4034b50L
    field public static final int LOCSIZ = 18; // 0x12
    field public static final int LOCTIM = 10; // 0xa
    field public static final int LOCVER = 4; // 0x4
  }

  public class JarOutputStream extends java.util.zip.ZipOutputStream {
    ctor public JarOutputStream(java.io.OutputStream, java.util.jar.Manifest) throws java.io.IOException;
    ctor public JarOutputStream(java.io.OutputStream) throws java.io.IOException;
    field public static final int CENATT = 36; // 0x24
    field public static final int CENATX = 38; // 0x26
    field public static final int CENCOM = 32; // 0x20
    field public static final int CENCRC = 16; // 0x10
    field public static final int CENDSK = 34; // 0x22
    field public static final int CENEXT = 30; // 0x1e
    field public static final int CENFLG = 8; // 0x8
    field public static final int CENHDR = 46; // 0x2e
    field public static final int CENHOW = 10; // 0xa
    field public static final int CENLEN = 24; // 0x18
    field public static final int CENNAM = 28; // 0x1c
    field public static final int CENOFF = 42; // 0x2a
    field public static final long CENSIG = 33639248L; // 0x2014b50L
    field public static final int CENSIZ = 20; // 0x14
    field public static final int CENTIM = 12; // 0xc
    field public static final int CENVEM = 4; // 0x4
    field public static final int CENVER = 6; // 0x6
    field public static final int ENDCOM = 20; // 0x14
    field public static final int ENDHDR = 22; // 0x16
    field public static final int ENDOFF = 16; // 0x10
    field public static final long ENDSIG = 101010256L; // 0x6054b50L
    field public static final int ENDSIZ = 12; // 0xc
    field public static final int ENDSUB = 8; // 0x8
    field public static final int ENDTOT = 10; // 0xa
    field public static final int EXTCRC = 4; // 0x4
    field public static final int EXTHDR = 16; // 0x10
    field public static final int EXTLEN = 12; // 0xc
    field public static final long EXTSIG = 134695760L; // 0x8074b50L
    field public static final int EXTSIZ = 8; // 0x8
    field public static final int LOCCRC = 14; // 0xe
    field public static final int LOCEXT = 28; // 0x1c
    field public static final int LOCFLG = 6; // 0x6
    field public static final int LOCHDR = 30; // 0x1e
    field public static final int LOCHOW = 8; // 0x8
    field public static final int LOCLEN = 22; // 0x16
    field public static final int LOCNAM = 26; // 0x1a
    field public static final long LOCSIG = 67324752L; // 0x4034b50L
    field public static final int LOCSIZ = 18; // 0x12
    field public static final int LOCTIM = 10; // 0xa
    field public static final int LOCVER = 4; // 0x4
  }

  public class Manifest implements java.lang.Cloneable {
    ctor public Manifest();
    ctor public Manifest(java.io.InputStream) throws java.io.IOException;
    ctor public Manifest(java.util.jar.Manifest);
    method public void clear();
    method public Object clone();
    method public java.util.jar.Attributes getAttributes(String);
    method public java.util.Map<java.lang.String,java.util.jar.Attributes> getEntries();
    method public java.util.jar.Attributes getMainAttributes();
    method public void read(java.io.InputStream) throws java.io.IOException;
    method public void write(java.io.OutputStream) throws java.io.IOException;
  }

  public abstract class Pack200 {
    method public static java.util.jar.Pack200.Packer newPacker();
    method public static java.util.jar.Pack200.Unpacker newUnpacker();
  }

  public static interface Pack200.Packer {
    method @Deprecated public default void addPropertyChangeListener(java.beans.PropertyChangeListener);
    method public void pack(java.util.jar.JarFile, java.io.OutputStream) throws java.io.IOException;
    method public void pack(java.util.jar.JarInputStream, java.io.OutputStream) throws java.io.IOException;
    method public java.util.SortedMap<java.lang.String,java.lang.String> properties();
    method @Deprecated public default void removePropertyChangeListener(java.beans.PropertyChangeListener);
    field public static final String CLASS_ATTRIBUTE_PFX = "pack.class.attribute.";
    field public static final String CODE_ATTRIBUTE_PFX = "pack.code.attribute.";
    field public static final String DEFLATE_HINT = "pack.deflate.hint";
    field public static final String EFFORT = "pack.effort";
    field public static final String ERROR = "error";
    field public static final String FALSE = "false";
    field public static final String FIELD_ATTRIBUTE_PFX = "pack.field.attribute.";
    field public static final String KEEP = "keep";
    field public static final String KEEP_FILE_ORDER = "pack.keep.file.order";
    field public static final String LATEST = "latest";
    field public static final String METHOD_ATTRIBUTE_PFX = "pack.method.attribute.";
    field public static final String MODIFICATION_TIME = "pack.modification.time";
    field public static final String PASS = "pass";
    field public static final String PASS_FILE_PFX = "pack.pass.file.";
    field public static final String PROGRESS = "pack.progress";
    field public static final String SEGMENT_LIMIT = "pack.segment.limit";
    field public static final String STRIP = "strip";
    field public static final String TRUE = "true";
    field public static final String UNKNOWN_ATTRIBUTE = "pack.unknown.attribute";
  }

  public static interface Pack200.Unpacker {
    method @Deprecated public default void addPropertyChangeListener(java.beans.PropertyChangeListener);
    method public java.util.SortedMap<java.lang.String,java.lang.String> properties();
    method @Deprecated public default void removePropertyChangeListener(java.beans.PropertyChangeListener);
    method public void unpack(java.io.InputStream, java.util.jar.JarOutputStream) throws java.io.IOException;
    method public void unpack(java.io.File, java.util.jar.JarOutputStream) throws java.io.IOException;
    field public static final String DEFLATE_HINT = "unpack.deflate.hint";
    field public static final String FALSE = "false";
    field public static final String KEEP = "keep";
    field public static final String PROGRESS = "unpack.progress";
    field public static final String TRUE = "true";
  }

}

package java.util.logging {

  public class ConsoleHandler extends java.util.logging.StreamHandler {
    ctor public ConsoleHandler();
    method public void close();
  }

  public class ErrorManager {
    ctor public ErrorManager();
    method public void error(String, Exception, int);
    field public static final int CLOSE_FAILURE = 3; // 0x3
    field public static final int FLUSH_FAILURE = 2; // 0x2
    field public static final int FORMAT_FAILURE = 5; // 0x5
    field public static final int GENERIC_FAILURE = 0; // 0x0
    field public static final int OPEN_FAILURE = 4; // 0x4
    field public static final int WRITE_FAILURE = 1; // 0x1
  }

  public class FileHandler extends java.util.logging.StreamHandler {
    ctor public FileHandler() throws java.io.IOException, java.lang.SecurityException;
    ctor public FileHandler(String) throws java.io.IOException, java.lang.SecurityException;
    ctor public FileHandler(String, boolean) throws java.io.IOException, java.lang.SecurityException;
    ctor public FileHandler(String, int, int) throws java.io.IOException, java.lang.SecurityException;
    ctor public FileHandler(String, int, int, boolean) throws java.io.IOException, java.lang.SecurityException;
  }

  @java.lang.FunctionalInterface public interface Filter {
    method public boolean isLoggable(java.util.logging.LogRecord);
  }

  public abstract class Formatter {
    ctor protected Formatter();
    method public abstract String format(java.util.logging.LogRecord);
    method public String formatMessage(java.util.logging.LogRecord);
    method public String getHead(java.util.logging.Handler);
    method public String getTail(java.util.logging.Handler);
  }

  public abstract class Handler {
    ctor protected Handler();
    method public abstract void close() throws java.lang.SecurityException;
    method public abstract void flush();
    method public String getEncoding();
    method public java.util.logging.ErrorManager getErrorManager();
    method public java.util.logging.Filter getFilter();
    method public java.util.logging.Formatter getFormatter();
    method public java.util.logging.Level getLevel();
    method public boolean isLoggable(java.util.logging.LogRecord);
    method public abstract void publish(java.util.logging.LogRecord);
    method protected void reportError(String, Exception, int);
    method public void setEncoding(String) throws java.lang.SecurityException, java.io.UnsupportedEncodingException;
    method public void setErrorManager(java.util.logging.ErrorManager);
    method public void setFilter(java.util.logging.Filter) throws java.lang.SecurityException;
    method public void setFormatter(java.util.logging.Formatter) throws java.lang.SecurityException;
    method public void setLevel(java.util.logging.Level) throws java.lang.SecurityException;
  }

  public class Level implements java.io.Serializable {
    ctor protected Level(@NonNull String, int);
    ctor protected Level(@NonNull String, int, @Nullable String);
    method @NonNull public String getLocalizedName();
    method @NonNull public String getName();
    method @Nullable public String getResourceBundleName();
    method public final int intValue();
    method @NonNull public static java.util.logging.Level parse(@NonNull String) throws java.lang.IllegalArgumentException;
    method @NonNull public final String toString();
    field @NonNull public static final java.util.logging.Level ALL;
    field @NonNull public static final java.util.logging.Level CONFIG;
    field @NonNull public static final java.util.logging.Level FINE;
    field @NonNull public static final java.util.logging.Level FINER;
    field @NonNull public static final java.util.logging.Level FINEST;
    field @NonNull public static final java.util.logging.Level INFO;
    field @NonNull public static final java.util.logging.Level OFF;
    field @NonNull public static final java.util.logging.Level SEVERE;
    field @NonNull public static final java.util.logging.Level WARNING;
  }

  public class LogManager {
    ctor protected LogManager();
    method public boolean addLogger(java.util.logging.Logger);
    method @Deprecated public void addPropertyChangeListener(java.beans.PropertyChangeListener) throws java.lang.SecurityException;
    method public void checkAccess() throws java.lang.SecurityException;
    method public static java.util.logging.LogManager getLogManager();
    method public java.util.logging.Logger getLogger(String);
    method public java.util.Enumeration<java.lang.String> getLoggerNames();
    method public static java.util.logging.LoggingMXBean getLoggingMXBean();
    method public String getProperty(String);
    method public void readConfiguration() throws java.io.IOException, java.lang.SecurityException;
    method public void readConfiguration(java.io.InputStream) throws java.io.IOException, java.lang.SecurityException;
    method @Deprecated public void removePropertyChangeListener(java.beans.PropertyChangeListener) throws java.lang.SecurityException;
    method public void reset() throws java.lang.SecurityException;
    field public static final String LOGGING_MXBEAN_NAME = "java.util.logging:type=Logging";
  }

  public class LogRecord implements java.io.Serializable {
    ctor public LogRecord(java.util.logging.Level, String);
    method public java.util.logging.Level getLevel();
    method public String getLoggerName();
    method public String getMessage();
    method public long getMillis();
    method public Object[] getParameters();
    method public java.util.ResourceBundle getResourceBundle();
    method public String getResourceBundleName();
    method public long getSequenceNumber();
    method public String getSourceClassName();
    method public String getSourceMethodName();
    method public int getThreadID();
    method public Throwable getThrown();
    method public void setLevel(java.util.logging.Level);
    method public void setLoggerName(String);
    method public void setMessage(String);
    method public void setMillis(long);
    method public void setParameters(Object[]);
    method public void setResourceBundle(java.util.ResourceBundle);
    method public void setResourceBundleName(String);
    method public void setSequenceNumber(long);
    method public void setSourceClassName(String);
    method public void setSourceMethodName(String);
    method public void setThreadID(int);
    method public void setThrown(Throwable);
  }

  public class Logger {
    ctor protected Logger(@Nullable String, @Nullable String);
    method public void addHandler(@NonNull java.util.logging.Handler) throws java.lang.SecurityException;
    method public void config(@Nullable String);
    method public void config(@NonNull java.util.function.Supplier<java.lang.String>);
    method public void entering(@Nullable String, @Nullable String);
    method public void entering(@Nullable String, @Nullable String, @Nullable Object);
    method public void entering(@Nullable String, @Nullable String, @Nullable Object[]);
    method public void exiting(@Nullable String, @Nullable String);
    method public void exiting(@Nullable String, @Nullable String, @Nullable Object);
    method public void fine(@Nullable String);
    method public void fine(@NonNull java.util.function.Supplier<java.lang.String>);
    method public void finer(@Nullable String);
    method public void finer(@NonNull java.util.function.Supplier<java.lang.String>);
    method public void finest(@Nullable String);
    method public void finest(@NonNull java.util.function.Supplier<java.lang.String>);
    method @NonNull public static java.util.logging.Logger getAnonymousLogger();
    method @NonNull public static java.util.logging.Logger getAnonymousLogger(@Nullable String);
    method @Nullable public java.util.logging.Filter getFilter();
    method @NonNull public static final java.util.logging.Logger getGlobal();
    method @NonNull public java.util.logging.Handler[] getHandlers();
    method @Nullable public java.util.logging.Level getLevel();
    method @NonNull public static java.util.logging.Logger getLogger(@NonNull String);
    method @NonNull public static java.util.logging.Logger getLogger(@NonNull String, @Nullable String);
    method @Nullable public String getName();
    method @Nullable public java.util.logging.Logger getParent();
    method @Nullable public java.util.ResourceBundle getResourceBundle();
    method @Nullable public String getResourceBundleName();
    method public boolean getUseParentHandlers();
    method public void info(@Nullable String);
    method public void info(@NonNull java.util.function.Supplier<java.lang.String>);
    method public boolean isLoggable(@NonNull java.util.logging.Level);
    method public void log(@NonNull java.util.logging.LogRecord);
    method public void log(@NonNull java.util.logging.Level, @Nullable String);
    method public void log(@NonNull java.util.logging.Level, @NonNull java.util.function.Supplier<java.lang.String>);
    method public void log(@NonNull java.util.logging.Level, @Nullable String, @Nullable Object);
    method public void log(@NonNull java.util.logging.Level, @Nullable String, @Nullable Object[]);
    method public void log(@NonNull java.util.logging.Level, @Nullable String, @Nullable Throwable);
    method public void log(@NonNull java.util.logging.Level, @Nullable Throwable, @NonNull java.util.function.Supplier<java.lang.String>);
    method public void logp(@NonNull java.util.logging.Level, @Nullable String, @Nullable String, @Nullable String);
    method public void logp(@NonNull java.util.logging.Level, @Nullable String, @Nullable String, @NonNull java.util.function.Supplier<java.lang.String>);
    method public void logp(@NonNull java.util.logging.Level, @Nullable String, @Nullable String, @Nullable String, @Nullable Object);
    method public void logp(@NonNull java.util.logging.Level, @Nullable String, @Nullable String, @Nullable String, @Nullable Object[]);
    method public void logp(@NonNull java.util.logging.Level, @Nullable String, @Nullable String, @Nullable String, @Nullable Throwable);
    method public void logp(@NonNull java.util.logging.Level, @Nullable String, @Nullable String, @Nullable Throwable, @NonNull java.util.function.Supplier<java.lang.String>);
    method @Deprecated public void logrb(@NonNull java.util.logging.Level, @Nullable String, @Nullable String, @Nullable String, @Nullable String);
    method @Deprecated public void logrb(@NonNull java.util.logging.Level, @Nullable String, @Nullable String, @Nullable String, @Nullable String, @Nullable Object);
    method @Deprecated public void logrb(@NonNull java.util.logging.Level, @Nullable String, @Nullable String, @Nullable String, @Nullable String, @Nullable Object[]);
    method public void logrb(@NonNull java.util.logging.Level, @Nullable String, @Nullable String, @Nullable java.util.ResourceBundle, @Nullable String, @Nullable java.lang.Object...);
    method @Deprecated public void logrb(@NonNull java.util.logging.Level, @Nullable String, @Nullable String, @Nullable String, @Nullable String, @Nullable Throwable);
    method public void logrb(@NonNull java.util.logging.Level, @Nullable String, @Nullable String, @Nullable java.util.ResourceBundle, @Nullable String, @Nullable Throwable);
    method public void removeHandler(@Nullable java.util.logging.Handler) throws java.lang.SecurityException;
    method public void setFilter(@Nullable java.util.logging.Filter) throws java.lang.SecurityException;
    method public void setLevel(@Nullable java.util.logging.Level) throws java.lang.SecurityException;
    method public void setParent(@NonNull java.util.logging.Logger);
    method public void setResourceBundle(@NonNull java.util.ResourceBundle);
    method public void setUseParentHandlers(boolean);
    method public void severe(@Nullable String);
    method public void severe(@NonNull java.util.function.Supplier<java.lang.String>);
    method public void throwing(@Nullable String, @Nullable String, @Nullable Throwable);
    method public void warning(@Nullable String);
    method public void warning(@NonNull java.util.function.Supplier<java.lang.String>);
    field @NonNull public static final String GLOBAL_LOGGER_NAME = "global";
    field @Deprecated @NonNull public static final java.util.logging.Logger global;
  }

  public interface LoggingMXBean {
    method public String getLoggerLevel(String);
    method public java.util.List<java.lang.String> getLoggerNames();
    method public String getParentLoggerName(String);
    method public void setLoggerLevel(String, String);
  }

  public final class LoggingPermission extends java.security.BasicPermission {
    ctor public LoggingPermission(String, String) throws java.lang.IllegalArgumentException;
  }

  public class MemoryHandler extends java.util.logging.Handler {
    ctor public MemoryHandler();
    ctor public MemoryHandler(java.util.logging.Handler, int, java.util.logging.Level);
    method public void close() throws java.lang.SecurityException;
    method public void flush();
    method public java.util.logging.Level getPushLevel();
    method public void publish(java.util.logging.LogRecord);
    method public void push();
    method public void setPushLevel(java.util.logging.Level) throws java.lang.SecurityException;
  }

  public class SimpleFormatter extends java.util.logging.Formatter {
    ctor public SimpleFormatter();
    method public String format(java.util.logging.LogRecord);
  }

  public class SocketHandler extends java.util.logging.StreamHandler {
    ctor public SocketHandler() throws java.io.IOException;
    ctor public SocketHandler(String, int) throws java.io.IOException;
  }

  public class StreamHandler extends java.util.logging.Handler {
    ctor public StreamHandler();
    ctor public StreamHandler(java.io.OutputStream, java.util.logging.Formatter);
    method public void close() throws java.lang.SecurityException;
    method public void flush();
    method public void publish(java.util.logging.LogRecord);
    method protected void setOutputStream(java.io.OutputStream) throws java.lang.SecurityException;
  }

  public class XMLFormatter extends java.util.logging.Formatter {
    ctor public XMLFormatter();
    method public String format(java.util.logging.LogRecord);
  }

}

package java.util.prefs {

  public abstract class AbstractPreferences extends java.util.prefs.Preferences {
    ctor protected AbstractPreferences(java.util.prefs.AbstractPreferences, String);
    method public String absolutePath();
    method public void addNodeChangeListener(java.util.prefs.NodeChangeListener);
    method public void addPreferenceChangeListener(java.util.prefs.PreferenceChangeListener);
    method protected final java.util.prefs.AbstractPreferences[] cachedChildren();
    method protected abstract java.util.prefs.AbstractPreferences childSpi(String);
    method public String[] childrenNames() throws java.util.prefs.BackingStoreException;
    method protected abstract String[] childrenNamesSpi() throws java.util.prefs.BackingStoreException;
    method public void clear() throws java.util.prefs.BackingStoreException;
    method public void exportNode(java.io.OutputStream) throws java.util.prefs.BackingStoreException, java.io.IOException;
    method public void exportSubtree(java.io.OutputStream) throws java.util.prefs.BackingStoreException, java.io.IOException;
    method public void flush() throws java.util.prefs.BackingStoreException;
    method protected abstract void flushSpi() throws java.util.prefs.BackingStoreException;
    method public String get(String, String);
    method public boolean getBoolean(String, boolean);
    method public byte[] getByteArray(String, byte[]);
    method protected java.util.prefs.AbstractPreferences getChild(String) throws java.util.prefs.BackingStoreException;
    method public double getDouble(String, double);
    method public float getFloat(String, float);
    method public int getInt(String, int);
    method public long getLong(String, long);
    method protected abstract String getSpi(String);
    method protected boolean isRemoved();
    method public boolean isUserNode();
    method public String[] keys() throws java.util.prefs.BackingStoreException;
    method protected abstract String[] keysSpi() throws java.util.prefs.BackingStoreException;
    method public String name();
    method public java.util.prefs.Preferences node(String);
    method public boolean nodeExists(String) throws java.util.prefs.BackingStoreException;
    method public java.util.prefs.Preferences parent();
    method public void put(String, String);
    method public void putBoolean(String, boolean);
    method public void putByteArray(String, byte[]);
    method public void putDouble(String, double);
    method public void putFloat(String, float);
    method public void putInt(String, int);
    method public void putLong(String, long);
    method protected abstract void putSpi(String, String);
    method public void remove(String);
    method public void removeNode() throws java.util.prefs.BackingStoreException;
    method public void removeNodeChangeListener(java.util.prefs.NodeChangeListener);
    method protected abstract void removeNodeSpi() throws java.util.prefs.BackingStoreException;
    method public void removePreferenceChangeListener(java.util.prefs.PreferenceChangeListener);
    method protected abstract void removeSpi(String);
    method public void sync() throws java.util.prefs.BackingStoreException;
    method protected abstract void syncSpi() throws java.util.prefs.BackingStoreException;
    method public String toString();
    field protected final Object lock;
    field protected boolean newNode;
  }

  public class BackingStoreException extends java.lang.Exception {
    ctor public BackingStoreException(String);
    ctor public BackingStoreException(Throwable);
  }

  public class InvalidPreferencesFormatException extends java.lang.Exception {
    ctor public InvalidPreferencesFormatException(Throwable);
    ctor public InvalidPreferencesFormatException(String);
    ctor public InvalidPreferencesFormatException(String, Throwable);
  }

  public class NodeChangeEvent extends java.util.EventObject {
    ctor public NodeChangeEvent(java.util.prefs.Preferences, java.util.prefs.Preferences);
    method public java.util.prefs.Preferences getChild();
    method public java.util.prefs.Preferences getParent();
  }

  public interface NodeChangeListener extends java.util.EventListener {
    method public void childAdded(java.util.prefs.NodeChangeEvent);
    method public void childRemoved(java.util.prefs.NodeChangeEvent);
  }

  public class PreferenceChangeEvent extends java.util.EventObject {
    ctor public PreferenceChangeEvent(java.util.prefs.Preferences, String, String);
    method public String getKey();
    method public String getNewValue();
    method public java.util.prefs.Preferences getNode();
  }

  @java.lang.FunctionalInterface public interface PreferenceChangeListener extends java.util.EventListener {
    method public void preferenceChange(java.util.prefs.PreferenceChangeEvent);
  }

  public abstract class Preferences {
    ctor protected Preferences();
    method public abstract String absolutePath();
    method public abstract void addNodeChangeListener(java.util.prefs.NodeChangeListener);
    method public abstract void addPreferenceChangeListener(java.util.prefs.PreferenceChangeListener);
    method public abstract String[] childrenNames() throws java.util.prefs.BackingStoreException;
    method public abstract void clear() throws java.util.prefs.BackingStoreException;
    method public abstract void exportNode(java.io.OutputStream) throws java.util.prefs.BackingStoreException, java.io.IOException;
    method public abstract void exportSubtree(java.io.OutputStream) throws java.util.prefs.BackingStoreException, java.io.IOException;
    method public abstract void flush() throws java.util.prefs.BackingStoreException;
    method public abstract String get(String, String);
    method public abstract boolean getBoolean(String, boolean);
    method public abstract byte[] getByteArray(String, byte[]);
    method public abstract double getDouble(String, double);
    method public abstract float getFloat(String, float);
    method public abstract int getInt(String, int);
    method public abstract long getLong(String, long);
    method public static void importPreferences(java.io.InputStream) throws java.io.IOException, java.util.prefs.InvalidPreferencesFormatException;
    method public abstract boolean isUserNode();
    method public abstract String[] keys() throws java.util.prefs.BackingStoreException;
    method public abstract String name();
    method public abstract java.util.prefs.Preferences node(String);
    method public abstract boolean nodeExists(String) throws java.util.prefs.BackingStoreException;
    method public abstract java.util.prefs.Preferences parent();
    method public abstract void put(String, String);
    method public abstract void putBoolean(String, boolean);
    method public abstract void putByteArray(String, byte[]);
    method public abstract void putDouble(String, double);
    method public abstract void putFloat(String, float);
    method public abstract void putInt(String, int);
    method public abstract void putLong(String, long);
    method public abstract void remove(String);
    method public abstract void removeNode() throws java.util.prefs.BackingStoreException;
    method public abstract void removeNodeChangeListener(java.util.prefs.NodeChangeListener);
    method public abstract void removePreferenceChangeListener(java.util.prefs.PreferenceChangeListener);
    method public abstract void sync() throws java.util.prefs.BackingStoreException;
    method public static java.util.prefs.Preferences systemNodeForPackage(Class<?>);
    method public static java.util.prefs.Preferences systemRoot();
    method public abstract String toString();
    method public static java.util.prefs.Preferences userNodeForPackage(Class<?>);
    method public static java.util.prefs.Preferences userRoot();
    field public static final int MAX_KEY_LENGTH = 80; // 0x50
    field public static final int MAX_NAME_LENGTH = 80; // 0x50
    field public static final int MAX_VALUE_LENGTH = 8192; // 0x2000
  }

  public interface PreferencesFactory {
    method public java.util.prefs.Preferences systemRoot();
    method public java.util.prefs.Preferences userRoot();
  }

}

package java.util.random {

  @FlaggedApi("com.android.libcore.v_apis") public interface RandomGenerator {
    method public default java.util.stream.DoubleStream doubles();
    method public default java.util.stream.DoubleStream doubles(double, double);
    method public default java.util.stream.DoubleStream doubles(long);
    method public default java.util.stream.DoubleStream doubles(long, double, double);
    method public static java.util.random.RandomGenerator getDefault();
    method public default java.util.stream.IntStream ints();
    method public default java.util.stream.IntStream ints(int, int);
    method public default java.util.stream.IntStream ints(long);
    method public default java.util.stream.IntStream ints(long, int, int);
    method public default boolean isDeprecated();
    method public default java.util.stream.LongStream longs();
    method public default java.util.stream.LongStream longs(long, long);
    method public default java.util.stream.LongStream longs(long);
    method public default java.util.stream.LongStream longs(long, long, long);
    method public default boolean nextBoolean();
    method public default void nextBytes(byte[]);
    method public default double nextDouble();
    method public default double nextDouble(double);
    method public default double nextDouble(double, double);
    method public default double nextExponential();
    method public default float nextFloat();
    method public default float nextFloat(float);
    method public default float nextFloat(float, float);
    method public default double nextGaussian();
    method public default double nextGaussian(double, double);
    method public default int nextInt();
    method public default int nextInt(int);
    method public default int nextInt(int, int);
    method public long nextLong();
    method public default long nextLong(long);
    method public default long nextLong(long, long);
    method public static java.util.random.RandomGenerator of(String);
  }

  @FlaggedApi("com.android.libcore.v_apis") public static interface RandomGenerator.ArbitrarilyJumpableGenerator extends java.util.random.RandomGenerator.LeapableGenerator {
    method public java.util.random.RandomGenerator.ArbitrarilyJumpableGenerator copy();
    method public default java.util.random.RandomGenerator.ArbitrarilyJumpableGenerator copyAndJump(double);
    method public void jump(double);
    method public default void jump();
    method public void jumpPowerOfTwo(int);
    method public default java.util.stream.Stream<java.util.random.RandomGenerator.ArbitrarilyJumpableGenerator> jumps(double);
    method public default java.util.stream.Stream<java.util.random.RandomGenerator.ArbitrarilyJumpableGenerator> jumps(long, double);
    method public default void leap();
    method public static java.util.random.RandomGenerator.ArbitrarilyJumpableGenerator of(String);
  }

  @FlaggedApi("com.android.libcore.v_apis") public static interface RandomGenerator.JumpableGenerator extends java.util.random.RandomGenerator.StreamableGenerator {
    method public java.util.random.RandomGenerator.JumpableGenerator copy();
    method public default java.util.random.RandomGenerator copyAndJump();
    method public void jump();
    method public double jumpDistance();
    method public default java.util.stream.Stream<java.util.random.RandomGenerator> jumps();
    method public default java.util.stream.Stream<java.util.random.RandomGenerator> jumps(long);
    method public static java.util.random.RandomGenerator.JumpableGenerator of(String);
    method public default java.util.stream.Stream<java.util.random.RandomGenerator> rngs();
  }

  @FlaggedApi("com.android.libcore.v_apis") public static interface RandomGenerator.LeapableGenerator extends java.util.random.RandomGenerator.JumpableGenerator {
    method public java.util.random.RandomGenerator.LeapableGenerator copy();
    method public default java.util.random.RandomGenerator.JumpableGenerator copyAndLeap();
    method public void leap();
    method public double leapDistance();
    method public default java.util.stream.Stream<java.util.random.RandomGenerator.JumpableGenerator> leaps();
    method public default java.util.stream.Stream<java.util.random.RandomGenerator.JumpableGenerator> leaps(long);
    method public static java.util.random.RandomGenerator.LeapableGenerator of(String);
  }

  @FlaggedApi("com.android.libcore.v_apis") public static interface RandomGenerator.SplittableGenerator extends java.util.random.RandomGenerator.StreamableGenerator {
    method public static java.util.random.RandomGenerator.SplittableGenerator of(String);
    method public default java.util.stream.Stream<java.util.random.RandomGenerator> rngs();
    method public java.util.random.RandomGenerator.SplittableGenerator split();
    method public java.util.random.RandomGenerator.SplittableGenerator split(java.util.random.RandomGenerator.SplittableGenerator);
    method public default java.util.stream.Stream<java.util.random.RandomGenerator.SplittableGenerator> splits();
    method public java.util.stream.Stream<java.util.random.RandomGenerator.SplittableGenerator> splits(long);
    method public java.util.stream.Stream<java.util.random.RandomGenerator.SplittableGenerator> splits(java.util.random.RandomGenerator.SplittableGenerator);
    method public java.util.stream.Stream<java.util.random.RandomGenerator.SplittableGenerator> splits(long, java.util.random.RandomGenerator.SplittableGenerator);
  }

  @FlaggedApi("com.android.libcore.v_apis") public static interface RandomGenerator.StreamableGenerator extends java.util.random.RandomGenerator {
    method public static java.util.random.RandomGenerator.StreamableGenerator of(String);
    method public java.util.stream.Stream<java.util.random.RandomGenerator> rngs();
    method public default java.util.stream.Stream<java.util.random.RandomGenerator> rngs(long);
  }

  @FlaggedApi("com.android.libcore.v_apis") public final class RandomGeneratorFactory<T extends java.util.random.RandomGenerator> {
    method public static java.util.stream.Stream<java.util.random.RandomGeneratorFactory<java.util.random.RandomGenerator>> all();
    method public T create();
    method public T create(long);
    method public T create(byte[]);
    method public int equidistribution();
    method public static java.util.random.RandomGeneratorFactory<java.util.random.RandomGenerator> getDefault();
    method public String group();
    method public boolean isArbitrarilyJumpable();
    method public boolean isDeprecated();
    method public boolean isHardware();
    method public boolean isJumpable();
    method public boolean isLeapable();
    method public boolean isSplittable();
    method public boolean isStatistical();
    method public boolean isStochastic();
    method public boolean isStreamable();
    method public String name();
    method public static <T extends java.util.random.RandomGenerator> java.util.random.RandomGeneratorFactory<T> of(String);
    method public java.math.BigInteger period();
    method public int stateBits();
  }

}

package java.util.regex {

  public interface MatchResult {
    method public int end();
    method public int end(int);
    method public String group();
    method public String group(int);
    method public int groupCount();
    method public int start();
    method public int start(int);
  }

  public final class Matcher implements java.util.regex.MatchResult {
    method @NonNull public java.util.regex.Matcher appendReplacement(@NonNull StringBuffer, @NonNull String);
    method @NonNull public java.util.regex.Matcher appendReplacement(@NonNull StringBuilder, @NonNull String);
    method @NonNull public StringBuffer appendTail(@NonNull StringBuffer);
    method @NonNull public StringBuilder appendTail(@NonNull StringBuilder);
    method public int end();
    method public int end(int);
    method public int end(@NonNull String);
    method public boolean find();
    method public boolean find(int);
    method @NonNull public String group();
    method @Nullable public String group(int);
    method @Nullable public String group(@NonNull String);
    method public int groupCount();
    method public boolean hasAnchoringBounds();
    method public boolean hasTransparentBounds();
    method public boolean hitEnd();
    method public boolean lookingAt();
    method public boolean matches();
    method @NonNull public java.util.regex.Pattern pattern();
    method @NonNull public static String quoteReplacement(@NonNull String);
    method @NonNull public java.util.regex.Matcher region(int, int);
    method public int regionEnd();
    method public int regionStart();
    method @NonNull public String replaceAll(@NonNull String);
    method @NonNull public String replaceAll(@NonNull java.util.function.Function<java.util.regex.MatchResult,java.lang.String>);
    method @NonNull public String replaceFirst(@NonNull String);
    method @NonNull public String replaceFirst(@NonNull java.util.function.Function<java.util.regex.MatchResult,java.lang.String>);
    method public boolean requireEnd();
    method @NonNull public java.util.regex.Matcher reset();
    method @NonNull public java.util.regex.Matcher reset(@NonNull CharSequence);
    method @NonNull public java.util.stream.Stream<java.util.regex.MatchResult> results();
    method public int start();
    method public int start(int);
    method public int start(@NonNull String);
    method @NonNull public java.util.regex.MatchResult toMatchResult();
    method @NonNull public java.util.regex.Matcher useAnchoringBounds(boolean);
    method @NonNull public java.util.regex.Matcher usePattern(@NonNull java.util.regex.Pattern);
    method @NonNull public java.util.regex.Matcher useTransparentBounds(boolean);
  }

  public final class Pattern implements java.io.Serializable {
    method @NonNull public java.util.function.Predicate<java.lang.String> asMatchPredicate();
    method @NonNull public java.util.function.Predicate<java.lang.String> asPredicate();
    method @NonNull public static java.util.regex.Pattern compile(@NonNull String);
    method @NonNull public static java.util.regex.Pattern compile(@NonNull String, int);
    method public int flags();
    method @NonNull public java.util.regex.Matcher matcher(@NonNull CharSequence);
    method public static boolean matches(@NonNull String, @NonNull CharSequence);
    method @NonNull public String pattern();
    method @NonNull public static String quote(@NonNull String);
    method @NonNull public String[] split(@NonNull CharSequence, int);
    method @NonNull public String[] split(@NonNull CharSequence);
    method @NonNull public java.util.stream.Stream<java.lang.String> splitAsStream(@NonNull CharSequence);
    field public static final int CANON_EQ = 128; // 0x80
    field public static final int CASE_INSENSITIVE = 2; // 0x2
    field public static final int COMMENTS = 4; // 0x4
    field public static final int DOTALL = 32; // 0x20
    field public static final int LITERAL = 16; // 0x10
    field public static final int MULTILINE = 8; // 0x8
    field public static final int UNICODE_CASE = 64; // 0x40
    field public static final int UNICODE_CHARACTER_CLASS = 256; // 0x100
    field public static final int UNIX_LINES = 1; // 0x1
  }

  public class PatternSyntaxException extends java.lang.IllegalArgumentException {
    ctor public PatternSyntaxException(String, String, int);
    method public String getDescription();
    method public int getIndex();
    method public String getPattern();
  }

}

package java.util.stream {

  public interface BaseStream<T, S extends java.util.stream.BaseStream<T, S>> extends java.lang.AutoCloseable {
    method public void close();
    method public boolean isParallel();
    method public java.util.Iterator<T> iterator();
    method public S onClose(Runnable);
    method public S parallel();
    method public S sequential();
    method public java.util.Spliterator<T> spliterator();
    method public S unordered();
  }

  public interface Collector<T, A, R> {
    method public java.util.function.BiConsumer<A,T> accumulator();
    method public java.util.Set<java.util.stream.Collector.Characteristics> characteristics();
    method public java.util.function.BinaryOperator<A> combiner();
    method public java.util.function.Function<A,R> finisher();
    method public static <T, R> java.util.stream.Collector<T,R,R> of(java.util.function.Supplier<R>, java.util.function.BiConsumer<R,T>, java.util.function.BinaryOperator<R>, java.util.stream.Collector.Characteristics...);
    method public static <T, A, R> java.util.stream.Collector<T,A,R> of(java.util.function.Supplier<A>, java.util.function.BiConsumer<A,T>, java.util.function.BinaryOperator<A>, java.util.function.Function<A,R>, java.util.stream.Collector.Characteristics...);
    method public java.util.function.Supplier<A> supplier();
  }

  public enum Collector.Characteristics {
    enum_constant public static final java.util.stream.Collector.Characteristics CONCURRENT;
    enum_constant public static final java.util.stream.Collector.Characteristics IDENTITY_FINISH;
    enum_constant public static final java.util.stream.Collector.Characteristics UNORDERED;
  }

  public final class Collectors {
    method public static <T> java.util.stream.Collector<T,?,java.lang.Double> averagingDouble(java.util.function.ToDoubleFunction<? super T>);
    method public static <T> java.util.stream.Collector<T,?,java.lang.Double> averagingInt(java.util.function.ToIntFunction<? super T>);
    method public static <T> java.util.stream.Collector<T,?,java.lang.Double> averagingLong(java.util.function.ToLongFunction<? super T>);
    method public static <T, A, R, RR> java.util.stream.Collector<T,A,RR> collectingAndThen(java.util.stream.Collector<T,A,R>, java.util.function.Function<R,RR>);
    method public static <T> java.util.stream.Collector<T,?,java.lang.Long> counting();
    method public static <T, A, R> java.util.stream.Collector<T,?,R> filtering(java.util.function.Predicate<? super T>, java.util.stream.Collector<? super T,A,R>);
    method public static <T, U, A, R> java.util.stream.Collector<T,?,R> flatMapping(java.util.function.Function<? super T,? extends java.util.stream.Stream<? extends U>>, java.util.stream.Collector<? super U,A,R>);
    method public static <T, K> java.util.stream.Collector<T,?,java.util.Map<K,java.util.List<T>>> groupingBy(java.util.function.Function<? super T,? extends K>);
    method public static <T, K, A, D> java.util.stream.Collector<T,?,java.util.Map<K,D>> groupingBy(java.util.function.Function<? super T,? extends K>, java.util.stream.Collector<? super T,A,D>);
    method public static <T, K, D, A, M extends java.util.Map<K, D>> java.util.stream.Collector<T,?,M> groupingBy(java.util.function.Function<? super T,? extends K>, java.util.function.Supplier<M>, java.util.stream.Collector<? super T,A,D>);
    method public static <T, K> java.util.stream.Collector<T,?,java.util.concurrent.ConcurrentMap<K,java.util.List<T>>> groupingByConcurrent(java.util.function.Function<? super T,? extends K>);
    method public static <T, K, A, D> java.util.stream.Collector<T,?,java.util.concurrent.ConcurrentMap<K,D>> groupingByConcurrent(java.util.function.Function<? super T,? extends K>, java.util.stream.Collector<? super T,A,D>);
    method public static <T, K, A, D, M extends java.util.concurrent.ConcurrentMap<K, D>> java.util.stream.Collector<T,?,M> groupingByConcurrent(java.util.function.Function<? super T,? extends K>, java.util.function.Supplier<M>, java.util.stream.Collector<? super T,A,D>);
    method public static java.util.stream.Collector<java.lang.CharSequence,?,java.lang.String> joining();
    method public static java.util.stream.Collector<java.lang.CharSequence,?,java.lang.String> joining(CharSequence);
    method public static java.util.stream.Collector<java.lang.CharSequence,?,java.lang.String> joining(CharSequence, CharSequence, CharSequence);
    method public static <T, U, A, R> java.util.stream.Collector<T,?,R> mapping(java.util.function.Function<? super T,? extends U>, java.util.stream.Collector<? super U,A,R>);
    method public static <T> java.util.stream.Collector<T,?,java.util.Optional<T>> maxBy(java.util.Comparator<? super T>);
    method public static <T> java.util.stream.Collector<T,?,java.util.Optional<T>> minBy(java.util.Comparator<? super T>);
    method public static <T> java.util.stream.Collector<T,?,java.util.Map<java.lang.Boolean,java.util.List<T>>> partitioningBy(java.util.function.Predicate<? super T>);
    method public static <T, D, A> java.util.stream.Collector<T,?,java.util.Map<java.lang.Boolean,D>> partitioningBy(java.util.function.Predicate<? super T>, java.util.stream.Collector<? super T,A,D>);
    method public static <T> java.util.stream.Collector<T,?,T> reducing(T, java.util.function.BinaryOperator<T>);
    method public static <T> java.util.stream.Collector<T,?,java.util.Optional<T>> reducing(java.util.function.BinaryOperator<T>);
    method public static <T, U> java.util.stream.Collector<T,?,U> reducing(U, java.util.function.Function<? super T,? extends U>, java.util.function.BinaryOperator<U>);
    method public static <T> java.util.stream.Collector<T,?,java.util.DoubleSummaryStatistics> summarizingDouble(java.util.function.ToDoubleFunction<? super T>);
    method public static <T> java.util.stream.Collector<T,?,java.util.IntSummaryStatistics> summarizingInt(java.util.function.ToIntFunction<? super T>);
    method public static <T> java.util.stream.Collector<T,?,java.util.LongSummaryStatistics> summarizingLong(java.util.function.ToLongFunction<? super T>);
    method public static <T> java.util.stream.Collector<T,?,java.lang.Double> summingDouble(java.util.function.ToDoubleFunction<? super T>);
    method public static <T> java.util.stream.Collector<T,?,java.lang.Integer> summingInt(java.util.function.ToIntFunction<? super T>);
    method public static <T> java.util.stream.Collector<T,?,java.lang.Long> summingLong(java.util.function.ToLongFunction<? super T>);
    method @FlaggedApi("com.android.libcore.v_apis") public static <T, R1, R2, R> java.util.stream.Collector<T,?,R> teeing(java.util.stream.Collector<? super T,?,R1>, java.util.stream.Collector<? super T,?,R2>, java.util.function.BiFunction<? super R1,? super R2,R>);
    method public static <T, C extends java.util.Collection<T>> java.util.stream.Collector<T,?,C> toCollection(java.util.function.Supplier<C>);
    method public static <T, K, U> java.util.stream.Collector<T,?,java.util.concurrent.ConcurrentMap<K,U>> toConcurrentMap(java.util.function.Function<? super T,? extends K>, java.util.function.Function<? super T,? extends U>);
    method public static <T, K, U> java.util.stream.Collector<T,?,java.util.concurrent.ConcurrentMap<K,U>> toConcurrentMap(java.util.function.Function<? super T,? extends K>, java.util.function.Function<? super T,? extends U>, java.util.function.BinaryOperator<U>);
    method public static <T, K, U, M extends java.util.concurrent.ConcurrentMap<K, U>> java.util.stream.Collector<T,?,M> toConcurrentMap(java.util.function.Function<? super T,? extends K>, java.util.function.Function<? super T,? extends U>, java.util.function.BinaryOperator<U>, java.util.function.Supplier<M>);
    method public static <T> java.util.stream.Collector<T,?,java.util.List<T>> toList();
    method public static <T, K, U> java.util.stream.Collector<T,?,java.util.Map<K,U>> toMap(java.util.function.Function<? super T,? extends K>, java.util.function.Function<? super T,? extends U>);
    method public static <T, K, U> java.util.stream.Collector<T,?,java.util.Map<K,U>> toMap(java.util.function.Function<? super T,? extends K>, java.util.function.Function<? super T,? extends U>, java.util.function.BinaryOperator<U>);
    method public static <T, K, U, M extends java.util.Map<K, U>> java.util.stream.Collector<T,?,M> toMap(java.util.function.Function<? super T,? extends K>, java.util.function.Function<? super T,? extends U>, java.util.function.BinaryOperator<U>, java.util.function.Supplier<M>);
    method public static <T> java.util.stream.Collector<T,?,java.util.Set<T>> toSet();
    method public static <T> java.util.stream.Collector<T,?,java.util.List<T>> toUnmodifiableList();
    method public static <T, K, U> java.util.stream.Collector<T,?,java.util.Map<K,U>> toUnmodifiableMap(java.util.function.Function<? super T,? extends K>, java.util.function.Function<? super T,? extends U>);
    method public static <T, K, U> java.util.stream.Collector<T,?,java.util.Map<K,U>> toUnmodifiableMap(java.util.function.Function<? super T,? extends K>, java.util.function.Function<? super T,? extends U>, java.util.function.BinaryOperator<U>);
    method public static <T> java.util.stream.Collector<T,?,java.util.Set<T>> toUnmodifiableSet();
  }

  public interface DoubleStream extends java.util.stream.BaseStream<java.lang.Double,java.util.stream.DoubleStream> {
    method public boolean allMatch(java.util.function.DoublePredicate);
    method public boolean anyMatch(java.util.function.DoublePredicate);
    method public java.util.OptionalDouble average();
    method public java.util.stream.Stream<java.lang.Double> boxed();
    method public static java.util.stream.DoubleStream.Builder builder();
    method public <R> R collect(java.util.function.Supplier<R>, java.util.function.ObjDoubleConsumer<R>, java.util.function.BiConsumer<R,R>);
    method public static java.util.stream.DoubleStream concat(java.util.stream.DoubleStream, java.util.stream.DoubleStream);
    method public long count();
    method public java.util.stream.DoubleStream distinct();
    method @FlaggedApi("com.android.libcore.v_apis") public default java.util.stream.DoubleStream dropWhile(java.util.function.DoublePredicate);
    method public static java.util.stream.DoubleStream empty();
    method public java.util.stream.DoubleStream filter(java.util.function.DoublePredicate);
    method public java.util.OptionalDouble findAny();
    method public java.util.OptionalDouble findFirst();
    method public java.util.stream.DoubleStream flatMap(java.util.function.DoubleFunction<? extends java.util.stream.DoubleStream>);
    method public void forEach(java.util.function.DoubleConsumer);
    method public void forEachOrdered(java.util.function.DoubleConsumer);
    method public static java.util.stream.DoubleStream generate(java.util.function.DoubleSupplier);
    method public static java.util.stream.DoubleStream iterate(double, java.util.function.DoubleUnaryOperator);
    method @FlaggedApi("com.android.libcore.v_apis") public static java.util.stream.DoubleStream iterate(double, java.util.function.DoublePredicate, java.util.function.DoubleUnaryOperator);
    method public java.util.PrimitiveIterator.OfDouble iterator();
    method public java.util.stream.DoubleStream limit(long);
    method public java.util.stream.DoubleStream map(java.util.function.DoubleUnaryOperator);
    method @FlaggedApi("com.android.libcore.v_apis") public default java.util.stream.DoubleStream mapMulti(java.util.stream.DoubleStream.DoubleMapMultiConsumer);
    method public java.util.stream.IntStream mapToInt(java.util.function.DoubleToIntFunction);
    method public java.util.stream.LongStream mapToLong(java.util.function.DoubleToLongFunction);
    method public <U> java.util.stream.Stream<U> mapToObj(java.util.function.DoubleFunction<? extends U>);
    method public java.util.OptionalDouble max();
    method public java.util.OptionalDouble min();
    method public boolean noneMatch(java.util.function.DoublePredicate);
    method public static java.util.stream.DoubleStream of(double);
    method public static java.util.stream.DoubleStream of(double...);
    method public java.util.stream.DoubleStream parallel();
    method public java.util.stream.DoubleStream peek(java.util.function.DoubleConsumer);
    method public double reduce(double, java.util.function.DoubleBinaryOperator);
    method public java.util.OptionalDouble reduce(java.util.function.DoubleBinaryOperator);
    method public java.util.stream.DoubleStream sequential();
    method public java.util.stream.DoubleStream skip(long);
    method public java.util.stream.DoubleStream sorted();
    method public java.util.Spliterator.OfDouble spliterator();
    method public double sum();
    method public java.util.DoubleSummaryStatistics summaryStatistics();
    method @FlaggedApi("com.android.libcore.v_apis") public default java.util.stream.DoubleStream takeWhile(java.util.function.DoublePredicate);
    method public double[] toArray();
  }

  public static interface DoubleStream.Builder extends java.util.function.DoubleConsumer {
    method public default java.util.stream.DoubleStream.Builder add(double);
    method public java.util.stream.DoubleStream build();
  }

  @FlaggedApi("com.android.libcore.v_apis") @java.lang.FunctionalInterface public static interface DoubleStream.DoubleMapMultiConsumer {
    method public void accept(double, java.util.function.DoubleConsumer);
  }

  public interface IntStream extends java.util.stream.BaseStream<java.lang.Integer,java.util.stream.IntStream> {
    method public boolean allMatch(java.util.function.IntPredicate);
    method public boolean anyMatch(java.util.function.IntPredicate);
    method public java.util.stream.DoubleStream asDoubleStream();
    method public java.util.stream.LongStream asLongStream();
    method public java.util.OptionalDouble average();
    method public java.util.stream.Stream<java.lang.Integer> boxed();
    method public static java.util.stream.IntStream.Builder builder();
    method public <R> R collect(java.util.function.Supplier<R>, java.util.function.ObjIntConsumer<R>, java.util.function.BiConsumer<R,R>);
    method public static java.util.stream.IntStream concat(java.util.stream.IntStream, java.util.stream.IntStream);
    method public long count();
    method public java.util.stream.IntStream distinct();
    method @FlaggedApi("com.android.libcore.v_apis") public default java.util.stream.IntStream dropWhile(java.util.function.IntPredicate);
    method public static java.util.stream.IntStream empty();
    method public java.util.stream.IntStream filter(java.util.function.IntPredicate);
    method public java.util.OptionalInt findAny();
    method public java.util.OptionalInt findFirst();
    method public java.util.stream.IntStream flatMap(java.util.function.IntFunction<? extends java.util.stream.IntStream>);
    method public void forEach(java.util.function.IntConsumer);
    method public void forEachOrdered(java.util.function.IntConsumer);
    method public static java.util.stream.IntStream generate(java.util.function.IntSupplier);
    method public static java.util.stream.IntStream iterate(int, java.util.function.IntUnaryOperator);
    method @FlaggedApi("com.android.libcore.v_apis") public static java.util.stream.IntStream iterate(int, java.util.function.IntPredicate, java.util.function.IntUnaryOperator);
    method public java.util.PrimitiveIterator.OfInt iterator();
    method public java.util.stream.IntStream limit(long);
    method public java.util.stream.IntStream map(java.util.function.IntUnaryOperator);
    method @FlaggedApi("com.android.libcore.v_apis") public default java.util.stream.IntStream mapMulti(java.util.stream.IntStream.IntMapMultiConsumer);
    method public java.util.stream.DoubleStream mapToDouble(java.util.function.IntToDoubleFunction);
    method public java.util.stream.LongStream mapToLong(java.util.function.IntToLongFunction);
    method public <U> java.util.stream.Stream<U> mapToObj(java.util.function.IntFunction<? extends U>);
    method public java.util.OptionalInt max();
    method public java.util.OptionalInt min();
    method public boolean noneMatch(java.util.function.IntPredicate);
    method public static java.util.stream.IntStream of(int);
    method public static java.util.stream.IntStream of(int...);
    method public java.util.stream.IntStream parallel();
    method public java.util.stream.IntStream peek(java.util.function.IntConsumer);
    method public static java.util.stream.IntStream range(int, int);
    method public static java.util.stream.IntStream rangeClosed(int, int);
    method public int reduce(int, java.util.function.IntBinaryOperator);
    method public java.util.OptionalInt reduce(java.util.function.IntBinaryOperator);
    method public java.util.stream.IntStream sequential();
    method public java.util.stream.IntStream skip(long);
    method public java.util.stream.IntStream sorted();
    method public java.util.Spliterator.OfInt spliterator();
    method public int sum();
    method public java.util.IntSummaryStatistics summaryStatistics();
    method @FlaggedApi("com.android.libcore.v_apis") public default java.util.stream.IntStream takeWhile(java.util.function.IntPredicate);
    method public int[] toArray();
  }

  public static interface IntStream.Builder extends java.util.function.IntConsumer {
    method public default java.util.stream.IntStream.Builder add(int);
    method public java.util.stream.IntStream build();
  }

  @FlaggedApi("com.android.libcore.v_apis") @java.lang.FunctionalInterface public static interface IntStream.IntMapMultiConsumer {
    method public void accept(int, java.util.function.IntConsumer);
  }

  public interface LongStream extends java.util.stream.BaseStream<java.lang.Long,java.util.stream.LongStream> {
    method public boolean allMatch(java.util.function.LongPredicate);
    method public boolean anyMatch(java.util.function.LongPredicate);
    method public java.util.stream.DoubleStream asDoubleStream();
    method public java.util.OptionalDouble average();
    method public java.util.stream.Stream<java.lang.Long> boxed();
    method public static java.util.stream.LongStream.Builder builder();
    method public <R> R collect(java.util.function.Supplier<R>, java.util.function.ObjLongConsumer<R>, java.util.function.BiConsumer<R,R>);
    method public static java.util.stream.LongStream concat(java.util.stream.LongStream, java.util.stream.LongStream);
    method public long count();
    method public java.util.stream.LongStream distinct();
    method @FlaggedApi("com.android.libcore.v_apis") public default java.util.stream.LongStream dropWhile(java.util.function.LongPredicate);
    method public static java.util.stream.LongStream empty();
    method public java.util.stream.LongStream filter(java.util.function.LongPredicate);
    method public java.util.OptionalLong findAny();
    method public java.util.OptionalLong findFirst();
    method public java.util.stream.LongStream flatMap(java.util.function.LongFunction<? extends java.util.stream.LongStream>);
    method public void forEach(java.util.function.LongConsumer);
    method public void forEachOrdered(java.util.function.LongConsumer);
    method public static java.util.stream.LongStream generate(java.util.function.LongSupplier);
    method public static java.util.stream.LongStream iterate(long, java.util.function.LongUnaryOperator);
    method @FlaggedApi("com.android.libcore.v_apis") public static java.util.stream.LongStream iterate(long, java.util.function.LongPredicate, java.util.function.LongUnaryOperator);
    method public java.util.PrimitiveIterator.OfLong iterator();
    method public java.util.stream.LongStream limit(long);
    method public java.util.stream.LongStream map(java.util.function.LongUnaryOperator);
    method @FlaggedApi("com.android.libcore.v_apis") public default java.util.stream.LongStream mapMulti(java.util.stream.LongStream.LongMapMultiConsumer);
    method public java.util.stream.DoubleStream mapToDouble(java.util.function.LongToDoubleFunction);
    method public java.util.stream.IntStream mapToInt(java.util.function.LongToIntFunction);
    method public <U> java.util.stream.Stream<U> mapToObj(java.util.function.LongFunction<? extends U>);
    method public java.util.OptionalLong max();
    method public java.util.OptionalLong min();
    method public boolean noneMatch(java.util.function.LongPredicate);
    method public static java.util.stream.LongStream of(long);
    method public static java.util.stream.LongStream of(long...);
    method public java.util.stream.LongStream parallel();
    method public java.util.stream.LongStream peek(java.util.function.LongConsumer);
    method public static java.util.stream.LongStream range(long, long);
    method public static java.util.stream.LongStream rangeClosed(long, long);
    method public long reduce(long, java.util.function.LongBinaryOperator);
    method public java.util.OptionalLong reduce(java.util.function.LongBinaryOperator);
    method public java.util.stream.LongStream sequential();
    method public java.util.stream.LongStream skip(long);
    method public java.util.stream.LongStream sorted();
    method public java.util.Spliterator.OfLong spliterator();
    method public long sum();
    method public java.util.LongSummaryStatistics summaryStatistics();
    method @FlaggedApi("com.android.libcore.v_apis") public default java.util.stream.LongStream takeWhile(java.util.function.LongPredicate);
    method public long[] toArray();
  }

  public static interface LongStream.Builder extends java.util.function.LongConsumer {
    method public default java.util.stream.LongStream.Builder add(long);
    method public java.util.stream.LongStream build();
  }

  @FlaggedApi("com.android.libcore.v_apis") @java.lang.FunctionalInterface public static interface LongStream.LongMapMultiConsumer {
    method public void accept(long, java.util.function.LongConsumer);
  }

  public interface Stream<T> extends java.util.stream.BaseStream<T,java.util.stream.Stream<T>> {
    method public boolean allMatch(java.util.function.Predicate<? super T>);
    method public boolean anyMatch(java.util.function.Predicate<? super T>);
    method public static <T> java.util.stream.Stream.Builder<T> builder();
    method public <R> R collect(java.util.function.Supplier<R>, java.util.function.BiConsumer<R,? super T>, java.util.function.BiConsumer<R,R>);
    method public <R, A> R collect(java.util.stream.Collector<? super T,A,R>);
    method public static <T> java.util.stream.Stream<T> concat(java.util.stream.Stream<? extends T>, java.util.stream.Stream<? extends T>);
    method public long count();
    method public java.util.stream.Stream<T> distinct();
    method public default java.util.stream.Stream<T> dropWhile(java.util.function.Predicate<? super T>);
    method public static <T> java.util.stream.Stream<T> empty();
    method public java.util.stream.Stream<T> filter(java.util.function.Predicate<? super T>);
    method public java.util.Optional<T> findAny();
    method public java.util.Optional<T> findFirst();
    method public <R> java.util.stream.Stream<R> flatMap(java.util.function.Function<? super T,? extends java.util.stream.Stream<? extends R>>);
    method public java.util.stream.DoubleStream flatMapToDouble(java.util.function.Function<? super T,? extends java.util.stream.DoubleStream>);
    method public java.util.stream.IntStream flatMapToInt(java.util.function.Function<? super T,? extends java.util.stream.IntStream>);
    method public java.util.stream.LongStream flatMapToLong(java.util.function.Function<? super T,? extends java.util.stream.LongStream>);
    method public void forEach(java.util.function.Consumer<? super T>);
    method public void forEachOrdered(java.util.function.Consumer<? super T>);
    method public static <T> java.util.stream.Stream<T> generate(java.util.function.Supplier<? extends T>);
    method public static <T> java.util.stream.Stream<T> iterate(T, java.util.function.UnaryOperator<T>);
    method public static <T> java.util.stream.Stream<T> iterate(T, java.util.function.Predicate<? super T>, java.util.function.UnaryOperator<T>);
    method public java.util.stream.Stream<T> limit(long);
    method public <R> java.util.stream.Stream<R> map(java.util.function.Function<? super T,? extends R>);
    method public default <R> java.util.stream.Stream<R> mapMulti(java.util.function.BiConsumer<? super T,? super java.util.function.Consumer<R>>);
    method public default java.util.stream.DoubleStream mapMultiToDouble(java.util.function.BiConsumer<? super T,? super java.util.function.DoubleConsumer>);
    method public default java.util.stream.IntStream mapMultiToInt(java.util.function.BiConsumer<? super T,? super java.util.function.IntConsumer>);
    method public default java.util.stream.LongStream mapMultiToLong(java.util.function.BiConsumer<? super T,? super java.util.function.LongConsumer>);
    method public java.util.stream.DoubleStream mapToDouble(java.util.function.ToDoubleFunction<? super T>);
    method public java.util.stream.IntStream mapToInt(java.util.function.ToIntFunction<? super T>);
    method public java.util.stream.LongStream mapToLong(java.util.function.ToLongFunction<? super T>);
    method public java.util.Optional<T> max(java.util.Comparator<? super T>);
    method public java.util.Optional<T> min(java.util.Comparator<? super T>);
    method public boolean noneMatch(java.util.function.Predicate<? super T>);
    method public static <T> java.util.stream.Stream<T> of(T);
    method @java.lang.SafeVarargs public static <T> java.util.stream.Stream<T> of(T...);
    method public static <T> java.util.stream.Stream<T> ofNullable(T);
    method public java.util.stream.Stream<T> peek(java.util.function.Consumer<? super T>);
    method public T reduce(T, java.util.function.BinaryOperator<T>);
    method public java.util.Optional<T> reduce(java.util.function.BinaryOperator<T>);
    method public <U> U reduce(U, java.util.function.BiFunction<U,? super T,U>, java.util.function.BinaryOperator<U>);
    method public java.util.stream.Stream<T> skip(long);
    method public java.util.stream.Stream<T> sorted();
    method public java.util.stream.Stream<T> sorted(java.util.Comparator<? super T>);
    method public default java.util.stream.Stream<T> takeWhile(java.util.function.Predicate<? super T>);
    method public Object[] toArray();
    method public <A> A[] toArray(java.util.function.IntFunction<A[]>);
    method public default java.util.List<T> toList();
  }

  public static interface Stream.Builder<T> extends java.util.function.Consumer<T> {
    method public default java.util.stream.Stream.Builder<T> add(T);
    method public java.util.stream.Stream<T> build();
  }

  public final class StreamSupport {
    method public static java.util.stream.DoubleStream doubleStream(java.util.Spliterator.OfDouble, boolean);
    method public static java.util.stream.DoubleStream doubleStream(java.util.function.Supplier<? extends java.util.Spliterator.OfDouble>, int, boolean);
    method public static java.util.stream.IntStream intStream(java.util.Spliterator.OfInt, boolean);
    method public static java.util.stream.IntStream intStream(java.util.function.Supplier<? extends java.util.Spliterator.OfInt>, int, boolean);
    method public static java.util.stream.LongStream longStream(java.util.Spliterator.OfLong, boolean);
    method public static java.util.stream.LongStream longStream(java.util.function.Supplier<? extends java.util.Spliterator.OfLong>, int, boolean);
    method public static <T> java.util.stream.Stream<T> stream(java.util.Spliterator<T>, boolean);
    method public static <T> java.util.stream.Stream<T> stream(java.util.function.Supplier<? extends java.util.Spliterator<T>>, int, boolean);
  }

}

package java.util.zip {

  public class Adler32 implements java.util.zip.Checksum {
    ctor public Adler32();
    method public long getValue();
    method public void reset();
    method public void update(int);
    method public void update(byte[], int, int);
    method public void update(byte[]);
    method public void update(java.nio.ByteBuffer);
  }

  public class CRC32 implements java.util.zip.Checksum {
    ctor public CRC32();
    method public long getValue();
    method public void reset();
    method public void update(int);
    method public void update(byte[], int, int);
    method public void update(byte[]);
    method public void update(java.nio.ByteBuffer);
  }

  public final class CRC32C implements java.util.zip.Checksum {
    ctor public CRC32C();
    method public long getValue();
    method public void reset();
    method public void update(int);
    method public void update(byte[], int, int);
    method public void update(java.nio.ByteBuffer);
  }

  public class CheckedInputStream extends java.io.FilterInputStream {
    ctor public CheckedInputStream(java.io.InputStream, java.util.zip.Checksum);
    method public java.util.zip.Checksum getChecksum();
  }

  public class CheckedOutputStream extends java.io.FilterOutputStream {
    ctor public CheckedOutputStream(java.io.OutputStream, java.util.zip.Checksum);
    method public java.util.zip.Checksum getChecksum();
  }

  public interface Checksum {
    method public long getValue();
    method public void reset();
    method public void update(int);
    method public default void update(byte[]);
    method public void update(byte[], int, int);
    method public default void update(java.nio.ByteBuffer);
  }

  public class DataFormatException extends java.lang.Exception {
    ctor public DataFormatException();
    ctor public DataFormatException(String);
  }

  public class Deflater {
    ctor public Deflater(int, boolean);
    ctor public Deflater(int);
    ctor public Deflater();
    method public int deflate(byte[], int, int);
    method public int deflate(byte[]);
    method public int deflate(byte[], int, int, int);
    method public void end();
    method protected void finalize();
    method public void finish();
    method public boolean finished();
    method public int getAdler();
    method public long getBytesRead();
    method public long getBytesWritten();
    method public int getTotalIn();
    method public int getTotalOut();
    method public boolean needsInput();
    method public void reset();
    method public void setDictionary(byte[], int, int);
    method public void setDictionary(byte[]);
    method public void setInput(byte[], int, int);
    method public void setInput(byte[]);
    method public void setLevel(int);
    method public void setStrategy(int);
    field public static final int BEST_COMPRESSION = 9; // 0x9
    field public static final int BEST_SPEED = 1; // 0x1
    field public static final int DEFAULT_COMPRESSION = -1; // 0xffffffff
    field public static final int DEFAULT_STRATEGY = 0; // 0x0
    field public static final int DEFLATED = 8; // 0x8
    field public static final int FILTERED = 1; // 0x1
    field public static final int FULL_FLUSH = 3; // 0x3
    field public static final int HUFFMAN_ONLY = 2; // 0x2
    field public static final int NO_COMPRESSION = 0; // 0x0
    field public static final int NO_FLUSH = 0; // 0x0
    field public static final int SYNC_FLUSH = 2; // 0x2
  }

  public class DeflaterInputStream extends java.io.FilterInputStream {
    ctor public DeflaterInputStream(java.io.InputStream);
    ctor public DeflaterInputStream(java.io.InputStream, java.util.zip.Deflater);
    ctor public DeflaterInputStream(java.io.InputStream, java.util.zip.Deflater, int);
    field protected final byte[] buf;
    field protected final java.util.zip.Deflater def;
  }

  public class DeflaterOutputStream extends java.io.FilterOutputStream {
    ctor public DeflaterOutputStream(java.io.OutputStream, java.util.zip.Deflater, int, boolean);
    ctor public DeflaterOutputStream(java.io.OutputStream, java.util.zip.Deflater, int);
    ctor public DeflaterOutputStream(java.io.OutputStream, java.util.zip.Deflater, boolean);
    ctor public DeflaterOutputStream(java.io.OutputStream, java.util.zip.Deflater);
    ctor public DeflaterOutputStream(java.io.OutputStream, boolean);
    ctor public DeflaterOutputStream(java.io.OutputStream);
    method protected void deflate() throws java.io.IOException;
    method public void finish() throws java.io.IOException;
    field protected byte[] buf;
    field protected java.util.zip.Deflater def;
  }

  public class GZIPInputStream extends java.util.zip.InflaterInputStream {
    ctor public GZIPInputStream(java.io.InputStream, int) throws java.io.IOException;
    ctor public GZIPInputStream(java.io.InputStream) throws java.io.IOException;
    field public static final int GZIP_MAGIC = 35615; // 0x8b1f
    field protected java.util.zip.CRC32 crc;
    field protected boolean eos;
  }

  public class GZIPOutputStream extends java.util.zip.DeflaterOutputStream {
    ctor public GZIPOutputStream(java.io.OutputStream, int) throws java.io.IOException;
    ctor public GZIPOutputStream(java.io.OutputStream, int, boolean) throws java.io.IOException;
    ctor public GZIPOutputStream(java.io.OutputStream) throws java.io.IOException;
    ctor public GZIPOutputStream(java.io.OutputStream, boolean) throws java.io.IOException;
    field protected java.util.zip.CRC32 crc;
  }

  public class Inflater {
    ctor public Inflater(boolean);
    ctor public Inflater();
    method public void end();
    method protected void finalize();
    method public boolean finished();
    method public int getAdler();
    method public long getBytesRead();
    method public long getBytesWritten();
    method public int getRemaining();
    method public int getTotalIn();
    method public int getTotalOut();
    method public int inflate(byte[], int, int) throws java.util.zip.DataFormatException;
    method public int inflate(byte[]) throws java.util.zip.DataFormatException;
    method public boolean needsDictionary();
    method public boolean needsInput();
    method public void reset();
    method public void setDictionary(byte[], int, int);
    method public void setDictionary(byte[]);
    method public void setInput(byte[], int, int);
    method public void setInput(byte[]);
  }

  public class InflaterInputStream extends java.io.FilterInputStream {
    ctor public InflaterInputStream(java.io.InputStream, java.util.zip.Inflater, int);
    ctor public InflaterInputStream(java.io.InputStream, java.util.zip.Inflater);
    ctor public InflaterInputStream(java.io.InputStream);
    method protected void fill() throws java.io.IOException;
    field protected byte[] buf;
    field @Deprecated protected boolean closed;
    field protected java.util.zip.Inflater inf;
    field protected int len;
  }

  public class InflaterOutputStream extends java.io.FilterOutputStream {
    ctor public InflaterOutputStream(java.io.OutputStream);
    ctor public InflaterOutputStream(java.io.OutputStream, java.util.zip.Inflater);
    ctor public InflaterOutputStream(java.io.OutputStream, java.util.zip.Inflater, int);
    method public void finish() throws java.io.IOException;
    field protected final byte[] buf;
    field protected final java.util.zip.Inflater inf;
  }

  public class ZipEntry implements java.lang.Cloneable {
    ctor public ZipEntry(String);
    ctor public ZipEntry(java.util.zip.ZipEntry);
    method public Object clone();
    method public String getComment();
    method public long getCompressedSize();
    method public long getCrc();
    method public java.nio.file.attribute.FileTime getCreationTime();
    method public byte[] getExtra();
    method public java.nio.file.attribute.FileTime getLastAccessTime();
    method public java.nio.file.attribute.FileTime getLastModifiedTime();
    method public int getMethod();
    method public String getName();
    method public long getSize();
    method public long getTime();
    method @FlaggedApi("com.android.libcore.v_apis") public java.time.LocalDateTime getTimeLocal();
    method public boolean isDirectory();
    method public void setComment(String);
    method public void setCompressedSize(long);
    method public void setCrc(long);
    method public java.util.zip.ZipEntry setCreationTime(java.nio.file.attribute.FileTime);
    method public void setExtra(byte[]);
    method public java.util.zip.ZipEntry setLastAccessTime(java.nio.file.attribute.FileTime);
    method public java.util.zip.ZipEntry setLastModifiedTime(java.nio.file.attribute.FileTime);
    method public void setMethod(int);
    method public void setSize(long);
    method public void setTime(long);
    method @FlaggedApi("com.android.libcore.v_apis") public void setTimeLocal(java.time.LocalDateTime);
    field public static final int CENATT = 36; // 0x24
    field public static final int CENATX = 38; // 0x26
    field public static final int CENCOM = 32; // 0x20
    field public static final int CENCRC = 16; // 0x10
    field public static final int CENDSK = 34; // 0x22
    field public static final int CENEXT = 30; // 0x1e
    field public static final int CENFLG = 8; // 0x8
    field public static final int CENHDR = 46; // 0x2e
    field public static final int CENHOW = 10; // 0xa
    field public static final int CENLEN = 24; // 0x18
    field public static final int CENNAM = 28; // 0x1c
    field public static final int CENOFF = 42; // 0x2a
    field public static final long CENSIG = 33639248L; // 0x2014b50L
    field public static final int CENSIZ = 20; // 0x14
    field public static final int CENTIM = 12; // 0xc
    field public static final int CENVEM = 4; // 0x4
    field public static final int CENVER = 6; // 0x6
    field public static final int DEFLATED = 8; // 0x8
    field public static final int ENDCOM = 20; // 0x14
    field public static final int ENDHDR = 22; // 0x16
    field public static final int ENDOFF = 16; // 0x10
    field public static final long ENDSIG = 101010256L; // 0x6054b50L
    field public static final int ENDSIZ = 12; // 0xc
    field public static final int ENDSUB = 8; // 0x8
    field public static final int ENDTOT = 10; // 0xa
    field public static final int EXTCRC = 4; // 0x4
    field public static final int EXTHDR = 16; // 0x10
    field public static final int EXTLEN = 12; // 0xc
    field public static final long EXTSIG = 134695760L; // 0x8074b50L
    field public static final int EXTSIZ = 8; // 0x8
    field public static final int LOCCRC = 14; // 0xe
    field public static final int LOCEXT = 28; // 0x1c
    field public static final int LOCFLG = 6; // 0x6
    field public static final int LOCHDR = 30; // 0x1e
    field public static final int LOCHOW = 8; // 0x8
    field public static final int LOCLEN = 22; // 0x16
    field public static final int LOCNAM = 26; // 0x1a
    field public static final long LOCSIG = 67324752L; // 0x4034b50L
    field public static final int LOCSIZ = 18; // 0x12
    field public static final int LOCTIM = 10; // 0xa
    field public static final int LOCVER = 4; // 0x4
    field public static final int STORED = 0; // 0x0
  }

  public class ZipError extends java.lang.InternalError {
    ctor public ZipError(String);
  }

  public class ZipException extends java.io.IOException {
    ctor public ZipException();
    ctor public ZipException(String);
  }

  public class ZipFile implements java.io.Closeable {
    ctor public ZipFile(String) throws java.io.IOException;
    ctor public ZipFile(java.io.File, int) throws java.io.IOException;
    ctor public ZipFile(java.io.File) throws java.io.IOException, java.util.zip.ZipException;
    ctor public ZipFile(java.io.File, int, java.nio.charset.Charset) throws java.io.IOException;
    ctor public ZipFile(String, java.nio.charset.Charset) throws java.io.IOException;
    ctor public ZipFile(java.io.File, java.nio.charset.Charset) throws java.io.IOException;
    method public void close() throws java.io.IOException;
    method public java.util.Enumeration<? extends java.util.zip.ZipEntry> entries();
    method protected void finalize() throws java.io.IOException;
    method public String getComment();
    method public java.util.zip.ZipEntry getEntry(String);
    method public java.io.InputStream getInputStream(java.util.zip.ZipEntry) throws java.io.IOException;
    method public String getName();
    method public int size();
    method public java.util.stream.Stream<? extends java.util.zip.ZipEntry> stream();
    field public static final int CENATT = 36; // 0x24
    field public static final int CENATX = 38; // 0x26
    field public static final int CENCOM = 32; // 0x20
    field public static final int CENCRC = 16; // 0x10
    field public static final int CENDSK = 34; // 0x22
    field public static final int CENEXT = 30; // 0x1e
    field public static final int CENFLG = 8; // 0x8
    field public static final int CENHDR = 46; // 0x2e
    field public static final int CENHOW = 10; // 0xa
    field public static final int CENLEN = 24; // 0x18
    field public static final int CENNAM = 28; // 0x1c
    field public static final int CENOFF = 42; // 0x2a
    field public static final long CENSIG = 33639248L; // 0x2014b50L
    field public static final int CENSIZ = 20; // 0x14
    field public static final int CENTIM = 12; // 0xc
    field public static final int CENVEM = 4; // 0x4
    field public static final int CENVER = 6; // 0x6
    field public static final int ENDCOM = 20; // 0x14
    field public static final int ENDHDR = 22; // 0x16
    field public static final int ENDOFF = 16; // 0x10
    field public static final long ENDSIG = 101010256L; // 0x6054b50L
    field public static final int ENDSIZ = 12; // 0xc
    field public static final int ENDSUB = 8; // 0x8
    field public static final int ENDTOT = 10; // 0xa
    field public static final int EXTCRC = 4; // 0x4
    field public static final int EXTHDR = 16; // 0x10
    field public static final int EXTLEN = 12; // 0xc
    field public static final long EXTSIG = 134695760L; // 0x8074b50L
    field public static final int EXTSIZ = 8; // 0x8
    field public static final int LOCCRC = 14; // 0xe
    field public static final int LOCEXT = 28; // 0x1c
    field public static final int LOCFLG = 6; // 0x6
    field public static final int LOCHDR = 30; // 0x1e
    field public static final int LOCHOW = 8; // 0x8
    field public static final int LOCLEN = 22; // 0x16
    field public static final int LOCNAM = 26; // 0x1a
    field public static final long LOCSIG = 67324752L; // 0x4034b50L
    field public static final int LOCSIZ = 18; // 0x12
    field public static final int LOCTIM = 10; // 0xa
    field public static final int LOCVER = 4; // 0x4
    field public static final int OPEN_DELETE = 4; // 0x4
    field public static final int OPEN_READ = 1; // 0x1
  }

  public class ZipInputStream extends java.util.zip.InflaterInputStream {
    ctor public ZipInputStream(java.io.InputStream);
    ctor public ZipInputStream(java.io.InputStream, java.nio.charset.Charset);
    method public void closeEntry() throws java.io.IOException;
    method protected java.util.zip.ZipEntry createZipEntry(String);
    method public java.util.zip.ZipEntry getNextEntry() throws java.io.IOException;
    field public static final int CENATT = 36; // 0x24
    field public static final int CENATX = 38; // 0x26
    field public static final int CENCOM = 32; // 0x20
    field public static final int CENCRC = 16; // 0x10
    field public static final int CENDSK = 34; // 0x22
    field public static final int CENEXT = 30; // 0x1e
    field public static final int CENFLG = 8; // 0x8
    field public static final int CENHDR = 46; // 0x2e
    field public static final int CENHOW = 10; // 0xa
    field public static final int CENLEN = 24; // 0x18
    field public static final int CENNAM = 28; // 0x1c
    field public static final int CENOFF = 42; // 0x2a
    field public static final long CENSIG = 33639248L; // 0x2014b50L
    field public static final int CENSIZ = 20; // 0x14
    field public static final int CENTIM = 12; // 0xc
    field public static final int CENVEM = 4; // 0x4
    field public static final int CENVER = 6; // 0x6
    field public static final int ENDCOM = 20; // 0x14
    field public static final int ENDHDR = 22; // 0x16
    field public static final int ENDOFF = 16; // 0x10
    field public static final long ENDSIG = 101010256L; // 0x6054b50L
    field public static final int ENDSIZ = 12; // 0xc
    field public static final int ENDSUB = 8; // 0x8
    field public static final int ENDTOT = 10; // 0xa
    field public static final int EXTCRC = 4; // 0x4
    field public static final int EXTHDR = 16; // 0x10
    field public static final int EXTLEN = 12; // 0xc
    field public static final long EXTSIG = 134695760L; // 0x8074b50L
    field public static final int EXTSIZ = 8; // 0x8
    field public static final int LOCCRC = 14; // 0xe
    field public static final int LOCEXT = 28; // 0x1c
    field public static final int LOCFLG = 6; // 0x6
    field public static final int LOCHDR = 30; // 0x1e
    field public static final int LOCHOW = 8; // 0x8
    field public static final int LOCLEN = 22; // 0x16
    field public static final int LOCNAM = 26; // 0x1a
    field public static final long LOCSIG = 67324752L; // 0x4034b50L
    field public static final int LOCSIZ = 18; // 0x12
    field public static final int LOCTIM = 10; // 0xa
    field public static final int LOCVER = 4; // 0x4
  }

  public class ZipOutputStream extends java.util.zip.DeflaterOutputStream {
    ctor public ZipOutputStream(java.io.OutputStream);
    ctor public ZipOutputStream(java.io.OutputStream, java.nio.charset.Charset);
    method public void closeEntry() throws java.io.IOException;
    method public void putNextEntry(java.util.zip.ZipEntry) throws java.io.IOException;
    method public void setComment(String);
    method public void setLevel(int);
    method public void setMethod(int);
    field public static final int CENATT = 36; // 0x24
    field public static final int CENATX = 38; // 0x26
    field public static final int CENCOM = 32; // 0x20
    field public static final int CENCRC = 16; // 0x10
    field public static final int CENDSK = 34; // 0x22
    field public static final int CENEXT = 30; // 0x1e
    field public static final int CENFLG = 8; // 0x8
    field public static final int CENHDR = 46; // 0x2e
    field public static final int CENHOW = 10; // 0xa
    field public static final int CENLEN = 24; // 0x18
    field public static final int CENNAM = 28; // 0x1c
    field public static final int CENOFF = 42; // 0x2a
    field public static final long CENSIG = 33639248L; // 0x2014b50L
    field public static final int CENSIZ = 20; // 0x14
    field public static final int CENTIM = 12; // 0xc
    field public static final int CENVEM = 4; // 0x4
    field public static final int CENVER = 6; // 0x6
    field public static final int DEFLATED = 8; // 0x8
    field public static final int ENDCOM = 20; // 0x14
    field public static final int ENDHDR = 22; // 0x16
    field public static final int ENDOFF = 16; // 0x10
    field public static final long ENDSIG = 101010256L; // 0x6054b50L
    field public static final int ENDSIZ = 12; // 0xc
    field public static final int ENDSUB = 8; // 0x8
    field public static final int ENDTOT = 10; // 0xa
    field public static final int EXTCRC = 4; // 0x4
    field public static final int EXTHDR = 16; // 0x10
    field public static final int EXTLEN = 12; // 0xc
    field public static final long EXTSIG = 134695760L; // 0x8074b50L
    field public static final int EXTSIZ = 8; // 0x8
    field public static final int LOCCRC = 14; // 0xe
    field public static final int LOCEXT = 28; // 0x1c
    field public static final int LOCFLG = 6; // 0x6
    field public static final int LOCHDR = 30; // 0x1e
    field public static final int LOCHOW = 8; // 0x8
    field public static final int LOCLEN = 22; // 0x16
    field public static final int LOCNAM = 26; // 0x1a
    field public static final long LOCSIG = 67324752L; // 0x4034b50L
    field public static final int LOCSIZ = 18; // 0x12
    field public static final int LOCTIM = 10; // 0xa
    field public static final int LOCVER = 4; // 0x4
    field public static final int STORED = 0; // 0x0
  }

}

package javax.annotation.processing {

  @java.lang.annotation.Documented @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) @java.lang.annotation.Target({java.lang.annotation.ElementType.PACKAGE, java.lang.annotation.ElementType.TYPE, java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.CONSTRUCTOR, java.lang.annotation.ElementType.FIELD, java.lang.annotation.ElementType.LOCAL_VARIABLE, java.lang.annotation.ElementType.PARAMETER}) public @interface Generated {
    method public abstract String comments() default "";
    method public abstract String date() default "";
    method public abstract String[] value();
  }

}

package javax.crypto {

  public class AEADBadTagException extends javax.crypto.BadPaddingException {
    ctor public AEADBadTagException();
    ctor public AEADBadTagException(String);
  }

  public class BadPaddingException extends java.security.GeneralSecurityException {
    ctor public BadPaddingException();
    ctor public BadPaddingException(String);
  }

  public class Cipher {
    ctor protected Cipher(javax.crypto.CipherSpi, java.security.Provider, String);
    method public final byte[] doFinal() throws javax.crypto.BadPaddingException, javax.crypto.IllegalBlockSizeException;
    method public final int doFinal(byte[], int) throws javax.crypto.BadPaddingException, javax.crypto.IllegalBlockSizeException, javax.crypto.ShortBufferException;
    method public final byte[] doFinal(byte[]) throws javax.crypto.BadPaddingException, javax.crypto.IllegalBlockSizeException;
    method public final byte[] doFinal(byte[], int, int) throws javax.crypto.BadPaddingException, javax.crypto.IllegalBlockSizeException;
    method public final int doFinal(byte[], int, int, byte[]) throws javax.crypto.BadPaddingException, javax.crypto.IllegalBlockSizeException, javax.crypto.ShortBufferException;
    method public final int doFinal(byte[], int, int, byte[], int) throws javax.crypto.BadPaddingException, javax.crypto.IllegalBlockSizeException, javax.crypto.ShortBufferException;
    method public final int doFinal(java.nio.ByteBuffer, java.nio.ByteBuffer) throws javax.crypto.BadPaddingException, javax.crypto.IllegalBlockSizeException, javax.crypto.ShortBufferException;
    method public final String getAlgorithm();
    method public final int getBlockSize();
    method public final javax.crypto.ExemptionMechanism getExemptionMechanism();
    method public final byte[] getIV();
    method public static final javax.crypto.Cipher getInstance(String) throws java.security.NoSuchAlgorithmException, javax.crypto.NoSuchPaddingException;
    method public static final javax.crypto.Cipher getInstance(String, String) throws java.security.NoSuchAlgorithmException, javax.crypto.NoSuchPaddingException, java.security.NoSuchProviderException;
    method public static final javax.crypto.Cipher getInstance(String, java.security.Provider) throws java.security.NoSuchAlgorithmException, javax.crypto.NoSuchPaddingException;
    method public static final int getMaxAllowedKeyLength(String) throws java.security.NoSuchAlgorithmException;
    method public static final java.security.spec.AlgorithmParameterSpec getMaxAllowedParameterSpec(String) throws java.security.NoSuchAlgorithmException;
    method public final int getOutputSize(int);
    method public final java.security.AlgorithmParameters getParameters();
    method public final java.security.Provider getProvider();
    method public final void init(int, java.security.Key) throws java.security.InvalidKeyException;
    method public final void init(int, java.security.Key, java.security.SecureRandom) throws java.security.InvalidKeyException;
    method public final void init(int, java.security.Key, java.security.spec.AlgorithmParameterSpec) throws java.security.InvalidAlgorithmParameterException, java.security.InvalidKeyException;
    method public final void init(int, java.security.Key, java.security.spec.AlgorithmParameterSpec, java.security.SecureRandom) throws java.security.InvalidAlgorithmParameterException, java.security.InvalidKeyException;
    method public final void init(int, java.security.Key, java.security.AlgorithmParameters) throws java.security.InvalidAlgorithmParameterException, java.security.InvalidKeyException;
    method public final void init(int, java.security.Key, java.security.AlgorithmParameters, java.security.SecureRandom) throws java.security.InvalidAlgorithmParameterException, java.security.InvalidKeyException;
    method public final void init(int, java.security.cert.Certificate) throws java.security.InvalidKeyException;
    method public final void init(int, java.security.cert.Certificate, java.security.SecureRandom) throws java.security.InvalidKeyException;
    method public final java.security.Key unwrap(byte[], String, int) throws java.security.InvalidKeyException, java.security.NoSuchAlgorithmException;
    method public final byte[] update(byte[]);
    method public final byte[] update(byte[], int, int);
    method public final int update(byte[], int, int, byte[]) throws javax.crypto.ShortBufferException;
    method public final int update(byte[], int, int, byte[], int) throws javax.crypto.ShortBufferException;
    method public final int update(java.nio.ByteBuffer, java.nio.ByteBuffer) throws javax.crypto.ShortBufferException;
    method public final void updateAAD(byte[]);
    method public final void updateAAD(byte[], int, int);
    method public final void updateAAD(java.nio.ByteBuffer);
    method public final byte[] wrap(java.security.Key) throws javax.crypto.IllegalBlockSizeException, java.security.InvalidKeyException;
    field public static final int DECRYPT_MODE = 2; // 0x2
    field public static final int ENCRYPT_MODE = 1; // 0x1
    field public static final int PRIVATE_KEY = 2; // 0x2
    field public static final int PUBLIC_KEY = 1; // 0x1
    field public static final int SECRET_KEY = 3; // 0x3
    field public static final int UNWRAP_MODE = 4; // 0x4
    field public static final int WRAP_MODE = 3; // 0x3
  }

  public class CipherInputStream extends java.io.FilterInputStream {
    ctor public CipherInputStream(java.io.InputStream, javax.crypto.Cipher);
    ctor protected CipherInputStream(java.io.InputStream);
  }

  public class CipherOutputStream extends java.io.FilterOutputStream {
    ctor public CipherOutputStream(java.io.OutputStream, javax.crypto.Cipher);
    ctor protected CipherOutputStream(java.io.OutputStream);
  }

  public abstract class CipherSpi {
    ctor public CipherSpi();
    method protected abstract byte[] engineDoFinal(byte[], int, int) throws javax.crypto.BadPaddingException, javax.crypto.IllegalBlockSizeException;
    method protected abstract int engineDoFinal(byte[], int, int, byte[], int) throws javax.crypto.BadPaddingException, javax.crypto.IllegalBlockSizeException, javax.crypto.ShortBufferException;
    method protected int engineDoFinal(java.nio.ByteBuffer, java.nio.ByteBuffer) throws javax.crypto.BadPaddingException, javax.crypto.IllegalBlockSizeException, javax.crypto.ShortBufferException;
    method protected abstract int engineGetBlockSize();
    method protected abstract byte[] engineGetIV();
    method protected int engineGetKeySize(java.security.Key) throws java.security.InvalidKeyException;
    method protected abstract int engineGetOutputSize(int);
    method protected abstract java.security.AlgorithmParameters engineGetParameters();
    method protected abstract void engineInit(int, java.security.Key, java.security.SecureRandom) throws java.security.InvalidKeyException;
    method protected abstract void engineInit(int, java.security.Key, java.security.spec.AlgorithmParameterSpec, java.security.SecureRandom) throws java.security.InvalidAlgorithmParameterException, java.security.InvalidKeyException;
    method protected abstract void engineInit(int, java.security.Key, java.security.AlgorithmParameters, java.security.SecureRandom) throws java.security.InvalidAlgorithmParameterException, java.security.InvalidKeyException;
    method protected abstract void engineSetMode(String) throws java.security.NoSuchAlgorithmException;
    method protected abstract void engineSetPadding(String) throws javax.crypto.NoSuchPaddingException;
    method protected java.security.Key engineUnwrap(byte[], String, int) throws java.security.InvalidKeyException, java.security.NoSuchAlgorithmException;
    method protected abstract byte[] engineUpdate(byte[], int, int);
    method protected abstract int engineUpdate(byte[], int, int, byte[], int) throws javax.crypto.ShortBufferException;
    method protected int engineUpdate(java.nio.ByteBuffer, java.nio.ByteBuffer) throws javax.crypto.ShortBufferException;
    method protected void engineUpdateAAD(byte[], int, int);
    method protected void engineUpdateAAD(java.nio.ByteBuffer);
    method protected byte[] engineWrap(java.security.Key) throws javax.crypto.IllegalBlockSizeException, java.security.InvalidKeyException;
  }

  public class EncryptedPrivateKeyInfo {
    ctor public EncryptedPrivateKeyInfo(byte[]) throws java.io.IOException;
    ctor public EncryptedPrivateKeyInfo(String, byte[]) throws java.security.NoSuchAlgorithmException;
    ctor public EncryptedPrivateKeyInfo(java.security.AlgorithmParameters, byte[]) throws java.security.NoSuchAlgorithmException;
    method public String getAlgName();
    method public java.security.AlgorithmParameters getAlgParameters();
    method public byte[] getEncoded() throws java.io.IOException;
    method public byte[] getEncryptedData();
    method public java.security.spec.PKCS8EncodedKeySpec getKeySpec(javax.crypto.Cipher) throws java.security.spec.InvalidKeySpecException;
    method public java.security.spec.PKCS8EncodedKeySpec getKeySpec(java.security.Key) throws java.security.InvalidKeyException, java.security.NoSuchAlgorithmException;
    method public java.security.spec.PKCS8EncodedKeySpec getKeySpec(java.security.Key, String) throws java.security.InvalidKeyException, java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public java.security.spec.PKCS8EncodedKeySpec getKeySpec(java.security.Key, java.security.Provider) throws java.security.InvalidKeyException, java.security.NoSuchAlgorithmException;
  }

  public class ExemptionMechanism {
    ctor protected ExemptionMechanism(javax.crypto.ExemptionMechanismSpi, java.security.Provider, String);
    method public final byte[] genExemptionBlob() throws javax.crypto.ExemptionMechanismException, java.lang.IllegalStateException;
    method public final int genExemptionBlob(byte[]) throws javax.crypto.ExemptionMechanismException, java.lang.IllegalStateException, javax.crypto.ShortBufferException;
    method public final int genExemptionBlob(byte[], int) throws javax.crypto.ExemptionMechanismException, java.lang.IllegalStateException, javax.crypto.ShortBufferException;
    method public static final javax.crypto.ExemptionMechanism getInstance(String) throws java.security.NoSuchAlgorithmException;
    method public static final javax.crypto.ExemptionMechanism getInstance(String, String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public static final javax.crypto.ExemptionMechanism getInstance(String, java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method public final String getName();
    method public final int getOutputSize(int) throws java.lang.IllegalStateException;
    method public final java.security.Provider getProvider();
    method public final void init(java.security.Key) throws javax.crypto.ExemptionMechanismException, java.security.InvalidKeyException;
    method public final void init(java.security.Key, java.security.spec.AlgorithmParameterSpec) throws javax.crypto.ExemptionMechanismException, java.security.InvalidAlgorithmParameterException, java.security.InvalidKeyException;
    method public final void init(java.security.Key, java.security.AlgorithmParameters) throws javax.crypto.ExemptionMechanismException, java.security.InvalidAlgorithmParameterException, java.security.InvalidKeyException;
    method public final boolean isCryptoAllowed(java.security.Key) throws javax.crypto.ExemptionMechanismException;
  }

  public class ExemptionMechanismException extends java.security.GeneralSecurityException {
    ctor public ExemptionMechanismException();
    ctor public ExemptionMechanismException(String);
  }

  public abstract class ExemptionMechanismSpi {
    ctor public ExemptionMechanismSpi();
    method protected abstract byte[] engineGenExemptionBlob() throws javax.crypto.ExemptionMechanismException;
    method protected abstract int engineGenExemptionBlob(byte[], int) throws javax.crypto.ExemptionMechanismException, javax.crypto.ShortBufferException;
    method protected abstract int engineGetOutputSize(int);
    method protected abstract void engineInit(java.security.Key) throws javax.crypto.ExemptionMechanismException, java.security.InvalidKeyException;
    method protected abstract void engineInit(java.security.Key, java.security.spec.AlgorithmParameterSpec) throws javax.crypto.ExemptionMechanismException, java.security.InvalidAlgorithmParameterException, java.security.InvalidKeyException;
    method protected abstract void engineInit(java.security.Key, java.security.AlgorithmParameters) throws javax.crypto.ExemptionMechanismException, java.security.InvalidAlgorithmParameterException, java.security.InvalidKeyException;
  }

  public class IllegalBlockSizeException extends java.security.GeneralSecurityException {
    ctor public IllegalBlockSizeException();
    ctor public IllegalBlockSizeException(String);
  }

  public class KeyAgreement {
    ctor protected KeyAgreement(javax.crypto.KeyAgreementSpi, java.security.Provider, String);
    method public final java.security.Key doPhase(java.security.Key, boolean) throws java.lang.IllegalStateException, java.security.InvalidKeyException;
    method public final byte[] generateSecret() throws java.lang.IllegalStateException;
    method public final int generateSecret(byte[], int) throws java.lang.IllegalStateException, javax.crypto.ShortBufferException;
    method public final javax.crypto.SecretKey generateSecret(String) throws java.lang.IllegalStateException, java.security.InvalidKeyException, java.security.NoSuchAlgorithmException;
    method public final String getAlgorithm();
    method public static final javax.crypto.KeyAgreement getInstance(String) throws java.security.NoSuchAlgorithmException;
    method public static final javax.crypto.KeyAgreement getInstance(String, String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public static final javax.crypto.KeyAgreement getInstance(String, java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method public final java.security.Provider getProvider();
    method public final void init(java.security.Key) throws java.security.InvalidKeyException;
    method public final void init(java.security.Key, java.security.SecureRandom) throws java.security.InvalidKeyException;
    method public final void init(java.security.Key, java.security.spec.AlgorithmParameterSpec) throws java.security.InvalidAlgorithmParameterException, java.security.InvalidKeyException;
    method public final void init(java.security.Key, java.security.spec.AlgorithmParameterSpec, java.security.SecureRandom) throws java.security.InvalidAlgorithmParameterException, java.security.InvalidKeyException;
  }

  public abstract class KeyAgreementSpi {
    ctor public KeyAgreementSpi();
    method protected abstract java.security.Key engineDoPhase(java.security.Key, boolean) throws java.lang.IllegalStateException, java.security.InvalidKeyException;
    method protected abstract byte[] engineGenerateSecret() throws java.lang.IllegalStateException;
    method protected abstract int engineGenerateSecret(byte[], int) throws java.lang.IllegalStateException, javax.crypto.ShortBufferException;
    method protected abstract javax.crypto.SecretKey engineGenerateSecret(String) throws java.lang.IllegalStateException, java.security.InvalidKeyException, java.security.NoSuchAlgorithmException;
    method protected abstract void engineInit(java.security.Key, java.security.SecureRandom) throws java.security.InvalidKeyException;
    method protected abstract void engineInit(java.security.Key, java.security.spec.AlgorithmParameterSpec, java.security.SecureRandom) throws java.security.InvalidAlgorithmParameterException, java.security.InvalidKeyException;
  }

  public class KeyGenerator {
    ctor protected KeyGenerator(javax.crypto.KeyGeneratorSpi, java.security.Provider, String);
    method public final javax.crypto.SecretKey generateKey();
    method public final String getAlgorithm();
    method public static final javax.crypto.KeyGenerator getInstance(String) throws java.security.NoSuchAlgorithmException;
    method public static final javax.crypto.KeyGenerator getInstance(String, String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public static final javax.crypto.KeyGenerator getInstance(String, java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method public final java.security.Provider getProvider();
    method public final void init(java.security.SecureRandom);
    method public final void init(java.security.spec.AlgorithmParameterSpec) throws java.security.InvalidAlgorithmParameterException;
    method public final void init(java.security.spec.AlgorithmParameterSpec, java.security.SecureRandom) throws java.security.InvalidAlgorithmParameterException;
    method public final void init(int);
    method public final void init(int, java.security.SecureRandom);
  }

  public abstract class KeyGeneratorSpi {
    ctor public KeyGeneratorSpi();
    method protected abstract javax.crypto.SecretKey engineGenerateKey();
    method protected abstract void engineInit(java.security.SecureRandom);
    method protected abstract void engineInit(java.security.spec.AlgorithmParameterSpec, java.security.SecureRandom) throws java.security.InvalidAlgorithmParameterException;
    method protected abstract void engineInit(int, java.security.SecureRandom);
  }

  public class Mac implements java.lang.Cloneable {
    ctor protected Mac(javax.crypto.MacSpi, java.security.Provider, String);
    method public final Object clone() throws java.lang.CloneNotSupportedException;
    method public final byte[] doFinal() throws java.lang.IllegalStateException;
    method public final void doFinal(byte[], int) throws java.lang.IllegalStateException, javax.crypto.ShortBufferException;
    method public final byte[] doFinal(byte[]) throws java.lang.IllegalStateException;
    method public final String getAlgorithm();
    method public static final javax.crypto.Mac getInstance(String) throws java.security.NoSuchAlgorithmException;
    method public static final javax.crypto.Mac getInstance(String, String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public static final javax.crypto.Mac getInstance(String, java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method public final int getMacLength();
    method public final java.security.Provider getProvider();
    method public final void init(java.security.Key) throws java.security.InvalidKeyException;
    method public final void init(java.security.Key, java.security.spec.AlgorithmParameterSpec) throws java.security.InvalidAlgorithmParameterException, java.security.InvalidKeyException;
    method public final void reset();
    method public final void update(byte) throws java.lang.IllegalStateException;
    method public final void update(byte[]) throws java.lang.IllegalStateException;
    method public final void update(byte[], int, int) throws java.lang.IllegalStateException;
    method public final void update(java.nio.ByteBuffer);
  }

  public abstract class MacSpi {
    ctor public MacSpi();
    method public Object clone() throws java.lang.CloneNotSupportedException;
    method protected abstract byte[] engineDoFinal();
    method protected abstract int engineGetMacLength();
    method protected abstract void engineInit(java.security.Key, java.security.spec.AlgorithmParameterSpec) throws java.security.InvalidAlgorithmParameterException, java.security.InvalidKeyException;
    method protected abstract void engineReset();
    method protected abstract void engineUpdate(byte);
    method protected abstract void engineUpdate(byte[], int, int);
    method protected void engineUpdate(java.nio.ByteBuffer);
  }

  public class NoSuchPaddingException extends java.security.GeneralSecurityException {
    ctor public NoSuchPaddingException();
    ctor public NoSuchPaddingException(String);
  }

  public class NullCipher extends javax.crypto.Cipher {
    ctor public NullCipher();
  }

  public class SealedObject implements java.io.Serializable {
    ctor public SealedObject(java.io.Serializable, javax.crypto.Cipher) throws java.io.IOException, javax.crypto.IllegalBlockSizeException;
    ctor protected SealedObject(javax.crypto.SealedObject);
    method public final String getAlgorithm();
    method public final Object getObject(java.security.Key) throws java.lang.ClassNotFoundException, java.io.IOException, java.security.InvalidKeyException, java.security.NoSuchAlgorithmException;
    method public final Object getObject(javax.crypto.Cipher) throws javax.crypto.BadPaddingException, java.lang.ClassNotFoundException, java.io.IOException, javax.crypto.IllegalBlockSizeException;
    method public final Object getObject(java.security.Key, String) throws java.lang.ClassNotFoundException, java.io.IOException, java.security.InvalidKeyException, java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    field protected byte[] encodedParams;
  }

  public interface SecretKey extends java.security.Key javax.security.auth.Destroyable {
    field public static final long serialVersionUID = -4795878709595146952L; // 0xbd719db928b8f538L
  }

  public class SecretKeyFactory {
    ctor protected SecretKeyFactory(javax.crypto.SecretKeyFactorySpi, java.security.Provider, String);
    method public final javax.crypto.SecretKey generateSecret(java.security.spec.KeySpec) throws java.security.spec.InvalidKeySpecException;
    method public final String getAlgorithm();
    method public static final javax.crypto.SecretKeyFactory getInstance(String) throws java.security.NoSuchAlgorithmException;
    method public static final javax.crypto.SecretKeyFactory getInstance(String, String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public static final javax.crypto.SecretKeyFactory getInstance(String, java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method public final java.security.spec.KeySpec getKeySpec(javax.crypto.SecretKey, Class<?>) throws java.security.spec.InvalidKeySpecException;
    method public final java.security.Provider getProvider();
    method public final javax.crypto.SecretKey translateKey(javax.crypto.SecretKey) throws java.security.InvalidKeyException;
  }

  public abstract class SecretKeyFactorySpi {
    ctor public SecretKeyFactorySpi();
    method protected abstract javax.crypto.SecretKey engineGenerateSecret(java.security.spec.KeySpec) throws java.security.spec.InvalidKeySpecException;
    method protected abstract java.security.spec.KeySpec engineGetKeySpec(javax.crypto.SecretKey, Class<?>) throws java.security.spec.InvalidKeySpecException;
    method protected abstract javax.crypto.SecretKey engineTranslateKey(javax.crypto.SecretKey) throws java.security.InvalidKeyException;
  }

  public class ShortBufferException extends java.security.GeneralSecurityException {
    ctor public ShortBufferException();
    ctor public ShortBufferException(String);
  }

}

package javax.crypto.interfaces {

  public interface DHKey {
    method public javax.crypto.spec.DHParameterSpec getParams();
  }

  public interface DHPrivateKey extends javax.crypto.interfaces.DHKey java.security.PrivateKey {
    method public java.math.BigInteger getX();
    field public static final long serialVersionUID = 2211791113380396553L; // 0x1eb1dc4c8e677e09L
  }

  public interface DHPublicKey extends javax.crypto.interfaces.DHKey java.security.PublicKey {
    method public java.math.BigInteger getY();
    field public static final long serialVersionUID = -6628103563352519193L; // 0xa4043eed23df4de7L
  }

  public interface PBEKey extends javax.crypto.SecretKey {
    method public int getIterationCount();
    method public char[] getPassword();
    method public byte[] getSalt();
    field public static final long serialVersionUID = -1430015993304333921L; // 0xec279007d7f7c19fL
  }

}

package javax.crypto.spec {

  @FlaggedApi("com.android.libcore.v_apis") public final class ChaCha20ParameterSpec implements java.security.spec.AlgorithmParameterSpec {
    ctor public ChaCha20ParameterSpec(byte[], int);
    method public int getCounter();
    method public byte[] getNonce();
  }

  public class DESKeySpec implements java.security.spec.KeySpec {
    ctor public DESKeySpec(byte[]) throws java.security.InvalidKeyException;
    ctor public DESKeySpec(byte[], int) throws java.security.InvalidKeyException;
    method public byte[] getKey();
    method public static boolean isParityAdjusted(byte[], int) throws java.security.InvalidKeyException;
    method public static boolean isWeak(byte[], int) throws java.security.InvalidKeyException;
    field public static final int DES_KEY_LEN = 8; // 0x8
  }

  public class DESedeKeySpec implements java.security.spec.KeySpec {
    ctor public DESedeKeySpec(byte[]) throws java.security.InvalidKeyException;
    ctor public DESedeKeySpec(byte[], int) throws java.security.InvalidKeyException;
    method public byte[] getKey();
    method public static boolean isParityAdjusted(byte[], int) throws java.security.InvalidKeyException;
    field public static final int DES_EDE_KEY_LEN = 24; // 0x18
  }

  public class DHGenParameterSpec implements java.security.spec.AlgorithmParameterSpec {
    ctor public DHGenParameterSpec(int, int);
    method public int getExponentSize();
    method public int getPrimeSize();
  }

  public class DHParameterSpec implements java.security.spec.AlgorithmParameterSpec {
    ctor public DHParameterSpec(java.math.BigInteger, java.math.BigInteger);
    ctor public DHParameterSpec(java.math.BigInteger, java.math.BigInteger, int);
    method public java.math.BigInteger getG();
    method public int getL();
    method public java.math.BigInteger getP();
  }

  public class DHPrivateKeySpec implements java.security.spec.KeySpec {
    ctor public DHPrivateKeySpec(java.math.BigInteger, java.math.BigInteger, java.math.BigInteger);
    method public java.math.BigInteger getG();
    method public java.math.BigInteger getP();
    method public java.math.BigInteger getX();
  }

  public class DHPublicKeySpec implements java.security.spec.KeySpec {
    ctor public DHPublicKeySpec(java.math.BigInteger, java.math.BigInteger, java.math.BigInteger);
    method public java.math.BigInteger getG();
    method public java.math.BigInteger getP();
    method public java.math.BigInteger getY();
  }

  public class GCMParameterSpec implements java.security.spec.AlgorithmParameterSpec {
    ctor public GCMParameterSpec(int, byte[]);
    ctor public GCMParameterSpec(int, byte[], int, int);
    method public byte[] getIV();
    method public int getTLen();
  }

  public class IvParameterSpec implements java.security.spec.AlgorithmParameterSpec {
    ctor public IvParameterSpec(byte[]);
    ctor public IvParameterSpec(byte[], int, int);
    method public byte[] getIV();
  }

  public class OAEPParameterSpec implements java.security.spec.AlgorithmParameterSpec {
    ctor public OAEPParameterSpec(String, String, java.security.spec.AlgorithmParameterSpec, javax.crypto.spec.PSource);
    method public String getDigestAlgorithm();
    method public String getMGFAlgorithm();
    method public java.security.spec.AlgorithmParameterSpec getMGFParameters();
    method public javax.crypto.spec.PSource getPSource();
    field public static final javax.crypto.spec.OAEPParameterSpec DEFAULT;
  }

  public class PBEKeySpec implements java.security.spec.KeySpec {
    ctor public PBEKeySpec(char[]);
    ctor public PBEKeySpec(char[], byte[], int, int);
    ctor public PBEKeySpec(char[], byte[], int);
    method public final void clearPassword();
    method public final int getIterationCount();
    method public final int getKeyLength();
    method public final char[] getPassword();
    method public final byte[] getSalt();
  }

  public class PBEParameterSpec implements java.security.spec.AlgorithmParameterSpec {
    ctor public PBEParameterSpec(byte[], int);
    ctor public PBEParameterSpec(byte[], int, java.security.spec.AlgorithmParameterSpec);
    method public int getIterationCount();
    method public java.security.spec.AlgorithmParameterSpec getParameterSpec();
    method public byte[] getSalt();
  }

  public class PSource {
    ctor protected PSource(String);
    method public String getAlgorithm();
  }

  public static final class PSource.PSpecified extends javax.crypto.spec.PSource {
    ctor public PSource.PSpecified(byte[]);
    method public byte[] getValue();
    field public static final javax.crypto.spec.PSource.PSpecified DEFAULT;
  }

  public class RC2ParameterSpec implements java.security.spec.AlgorithmParameterSpec {
    ctor public RC2ParameterSpec(int);
    ctor public RC2ParameterSpec(int, byte[]);
    ctor public RC2ParameterSpec(int, byte[], int);
    method public int getEffectiveKeyBits();
    method public byte[] getIV();
  }

  public class RC5ParameterSpec implements java.security.spec.AlgorithmParameterSpec {
    ctor public RC5ParameterSpec(int, int, int);
    ctor public RC5ParameterSpec(int, int, int, byte[]);
    ctor public RC5ParameterSpec(int, int, int, byte[], int);
    method public byte[] getIV();
    method public int getRounds();
    method public int getVersion();
    method public int getWordSize();
  }

  public class SecretKeySpec implements java.security.spec.KeySpec javax.crypto.SecretKey {
    ctor public SecretKeySpec(byte[], String);
    ctor public SecretKeySpec(byte[], int, int, String);
    method public String getAlgorithm();
    method public byte[] getEncoded();
    method public String getFormat();
  }

}

package javax.net {

  public abstract class ServerSocketFactory {
    ctor protected ServerSocketFactory();
    method public java.net.ServerSocket createServerSocket() throws java.io.IOException;
    method public abstract java.net.ServerSocket createServerSocket(int) throws java.io.IOException;
    method public abstract java.net.ServerSocket createServerSocket(int, int) throws java.io.IOException;
    method public abstract java.net.ServerSocket createServerSocket(int, int, java.net.InetAddress) throws java.io.IOException;
    method public static javax.net.ServerSocketFactory getDefault();
  }

  public abstract class SocketFactory {
    ctor protected SocketFactory();
    method public java.net.Socket createSocket() throws java.io.IOException;
    method public abstract java.net.Socket createSocket(String, int) throws java.io.IOException, java.net.UnknownHostException;
    method public abstract java.net.Socket createSocket(String, int, java.net.InetAddress, int) throws java.io.IOException, java.net.UnknownHostException;
    method public abstract java.net.Socket createSocket(java.net.InetAddress, int) throws java.io.IOException;
    method public abstract java.net.Socket createSocket(java.net.InetAddress, int, java.net.InetAddress, int) throws java.io.IOException;
    method public static javax.net.SocketFactory getDefault();
  }

}

package javax.net.ssl {

  public class CertPathTrustManagerParameters implements javax.net.ssl.ManagerFactoryParameters {
    ctor public CertPathTrustManagerParameters(java.security.cert.CertPathParameters);
    method public java.security.cert.CertPathParameters getParameters();
  }

  public abstract class ExtendedSSLSession implements javax.net.ssl.SSLSession {
    ctor public ExtendedSSLSession();
    method public abstract String[] getLocalSupportedSignatureAlgorithms();
    method public abstract String[] getPeerSupportedSignatureAlgorithms();
    method public java.util.List<javax.net.ssl.SNIServerName> getRequestedServerNames();
  }

  public class HandshakeCompletedEvent extends java.util.EventObject {
    ctor public HandshakeCompletedEvent(javax.net.ssl.SSLSocket, javax.net.ssl.SSLSession);
    method public String getCipherSuite();
    method public java.security.cert.Certificate[] getLocalCertificates();
    method public java.security.Principal getLocalPrincipal();
    method public javax.security.cert.X509Certificate[] getPeerCertificateChain() throws javax.net.ssl.SSLPeerUnverifiedException;
    method public java.security.cert.Certificate[] getPeerCertificates() throws javax.net.ssl.SSLPeerUnverifiedException;
    method public java.security.Principal getPeerPrincipal() throws javax.net.ssl.SSLPeerUnverifiedException;
    method public javax.net.ssl.SSLSession getSession();
    method public javax.net.ssl.SSLSocket getSocket();
  }

  public interface HandshakeCompletedListener extends java.util.EventListener {
    method public void handshakeCompleted(javax.net.ssl.HandshakeCompletedEvent);
  }

  public interface HostnameVerifier {
    method public boolean verify(String, javax.net.ssl.SSLSession);
  }

  public abstract class HttpsURLConnection extends java.net.HttpURLConnection {
    ctor protected HttpsURLConnection(java.net.URL);
    method public abstract String getCipherSuite();
    method public static javax.net.ssl.HostnameVerifier getDefaultHostnameVerifier();
    method public static javax.net.ssl.SSLSocketFactory getDefaultSSLSocketFactory();
    method public javax.net.ssl.HostnameVerifier getHostnameVerifier();
    method public abstract java.security.cert.Certificate[] getLocalCertificates();
    method public java.security.Principal getLocalPrincipal();
    method public java.security.Principal getPeerPrincipal() throws javax.net.ssl.SSLPeerUnverifiedException;
    method public javax.net.ssl.SSLSocketFactory getSSLSocketFactory();
    method public abstract java.security.cert.Certificate[] getServerCertificates() throws javax.net.ssl.SSLPeerUnverifiedException;
    method public static void setDefaultHostnameVerifier(javax.net.ssl.HostnameVerifier);
    method public static void setDefaultSSLSocketFactory(javax.net.ssl.SSLSocketFactory);
    method public void setHostnameVerifier(javax.net.ssl.HostnameVerifier);
    method public void setSSLSocketFactory(javax.net.ssl.SSLSocketFactory);
    field protected javax.net.ssl.HostnameVerifier hostnameVerifier;
  }

  public interface KeyManager {
  }

  public class KeyManagerFactory {
    ctor protected KeyManagerFactory(javax.net.ssl.KeyManagerFactorySpi, java.security.Provider, String);
    method public final String getAlgorithm();
    method public static final String getDefaultAlgorithm();
    method public static final javax.net.ssl.KeyManagerFactory getInstance(String) throws java.security.NoSuchAlgorithmException;
    method public static final javax.net.ssl.KeyManagerFactory getInstance(String, String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public static final javax.net.ssl.KeyManagerFactory getInstance(String, java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method public final javax.net.ssl.KeyManager[] getKeyManagers();
    method public final java.security.Provider getProvider();
    method public final void init(java.security.KeyStore, char[]) throws java.security.KeyStoreException, java.security.NoSuchAlgorithmException, java.security.UnrecoverableKeyException;
    method public final void init(javax.net.ssl.ManagerFactoryParameters) throws java.security.InvalidAlgorithmParameterException;
  }

  public abstract class KeyManagerFactorySpi {
    ctor public KeyManagerFactorySpi();
    method protected abstract javax.net.ssl.KeyManager[] engineGetKeyManagers();
    method protected abstract void engineInit(java.security.KeyStore, char[]) throws java.security.KeyStoreException, java.security.NoSuchAlgorithmException, java.security.UnrecoverableKeyException;
    method protected abstract void engineInit(javax.net.ssl.ManagerFactoryParameters) throws java.security.InvalidAlgorithmParameterException;
  }

  public class KeyStoreBuilderParameters implements javax.net.ssl.ManagerFactoryParameters {
    ctor public KeyStoreBuilderParameters(java.security.KeyStore.Builder);
    ctor public KeyStoreBuilderParameters(java.util.List<java.security.KeyStore.Builder>);
    method public java.util.List<java.security.KeyStore.Builder> getParameters();
  }

  public interface ManagerFactoryParameters {
  }

  public final class SNIHostName extends javax.net.ssl.SNIServerName {
    ctor public SNIHostName(String);
    ctor public SNIHostName(byte[]);
    method public static javax.net.ssl.SNIMatcher createSNIMatcher(String);
    method public String getAsciiName();
  }

  public abstract class SNIMatcher {
    ctor protected SNIMatcher(int);
    method public final int getType();
    method public abstract boolean matches(javax.net.ssl.SNIServerName);
  }

  public abstract class SNIServerName {
    ctor protected SNIServerName(int, byte[]);
    method public final byte[] getEncoded();
    method public final int getType();
  }

  public class SSLContext {
    ctor protected SSLContext(javax.net.ssl.SSLContextSpi, java.security.Provider, String);
    method public final javax.net.ssl.SSLEngine createSSLEngine();
    method public final javax.net.ssl.SSLEngine createSSLEngine(String, int);
    method public final javax.net.ssl.SSLSessionContext getClientSessionContext();
    method public static javax.net.ssl.SSLContext getDefault() throws java.security.NoSuchAlgorithmException;
    method public final javax.net.ssl.SSLParameters getDefaultSSLParameters();
    method public static javax.net.ssl.SSLContext getInstance(String) throws java.security.NoSuchAlgorithmException;
    method public static javax.net.ssl.SSLContext getInstance(String, String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public static javax.net.ssl.SSLContext getInstance(String, java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method public final String getProtocol();
    method public final java.security.Provider getProvider();
    method public final javax.net.ssl.SSLSessionContext getServerSessionContext();
    method public final javax.net.ssl.SSLServerSocketFactory getServerSocketFactory();
    method public final javax.net.ssl.SSLSocketFactory getSocketFactory();
    method public final javax.net.ssl.SSLParameters getSupportedSSLParameters();
    method public final void init(javax.net.ssl.KeyManager[], javax.net.ssl.TrustManager[], java.security.SecureRandom) throws java.security.KeyManagementException;
    method public static void setDefault(javax.net.ssl.SSLContext);
  }

  public abstract class SSLContextSpi {
    ctor public SSLContextSpi();
    method protected abstract javax.net.ssl.SSLEngine engineCreateSSLEngine();
    method protected abstract javax.net.ssl.SSLEngine engineCreateSSLEngine(String, int);
    method protected abstract javax.net.ssl.SSLSessionContext engineGetClientSessionContext();
    method protected javax.net.ssl.SSLParameters engineGetDefaultSSLParameters();
    method protected abstract javax.net.ssl.SSLSessionContext engineGetServerSessionContext();
    method protected abstract javax.net.ssl.SSLServerSocketFactory engineGetServerSocketFactory();
    method protected abstract javax.net.ssl.SSLSocketFactory engineGetSocketFactory();
    method protected javax.net.ssl.SSLParameters engineGetSupportedSSLParameters();
    method protected abstract void engineInit(javax.net.ssl.KeyManager[], javax.net.ssl.TrustManager[], java.security.SecureRandom) throws java.security.KeyManagementException;
  }

  public abstract class SSLEngine {
    ctor protected SSLEngine();
    ctor protected SSLEngine(String, int);
    method public abstract void beginHandshake() throws javax.net.ssl.SSLException;
    method public abstract void closeInbound() throws javax.net.ssl.SSLException;
    method public abstract void closeOutbound();
    method public String getApplicationProtocol();
    method public abstract Runnable getDelegatedTask();
    method public abstract boolean getEnableSessionCreation();
    method public abstract String[] getEnabledCipherSuites();
    method public abstract String[] getEnabledProtocols();
    method public String getHandshakeApplicationProtocol();
    method public java.util.function.BiFunction<javax.net.ssl.SSLEngine,java.util.List<java.lang.String>,java.lang.String> getHandshakeApplicationProtocolSelector();
    method public javax.net.ssl.SSLSession getHandshakeSession();
    method public abstract javax.net.ssl.SSLEngineResult.HandshakeStatus getHandshakeStatus();
    method public abstract boolean getNeedClientAuth();
    method public String getPeerHost();
    method public int getPeerPort();
    method public javax.net.ssl.SSLParameters getSSLParameters();
    method public abstract javax.net.ssl.SSLSession getSession();
    method public abstract String[] getSupportedCipherSuites();
    method public abstract String[] getSupportedProtocols();
    method public abstract boolean getUseClientMode();
    method public abstract boolean getWantClientAuth();
    method public abstract boolean isInboundDone();
    method public abstract boolean isOutboundDone();
    method public abstract void setEnableSessionCreation(boolean);
    method public abstract void setEnabledCipherSuites(String[]);
    method public abstract void setEnabledProtocols(String[]);
    method public void setHandshakeApplicationProtocolSelector(java.util.function.BiFunction<javax.net.ssl.SSLEngine,java.util.List<java.lang.String>,java.lang.String>);
    method public abstract void setNeedClientAuth(boolean);
    method public void setSSLParameters(javax.net.ssl.SSLParameters);
    method public abstract void setUseClientMode(boolean);
    method public abstract void setWantClientAuth(boolean);
    method public javax.net.ssl.SSLEngineResult unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer) throws javax.net.ssl.SSLException;
    method public javax.net.ssl.SSLEngineResult unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[]) throws javax.net.ssl.SSLException;
    method public abstract javax.net.ssl.SSLEngineResult unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[], int, int) throws javax.net.ssl.SSLException;
    method public javax.net.ssl.SSLEngineResult wrap(java.nio.ByteBuffer, java.nio.ByteBuffer) throws javax.net.ssl.SSLException;
    method public javax.net.ssl.SSLEngineResult wrap(java.nio.ByteBuffer[], java.nio.ByteBuffer) throws javax.net.ssl.SSLException;
    method public abstract javax.net.ssl.SSLEngineResult wrap(java.nio.ByteBuffer[], int, int, java.nio.ByteBuffer) throws javax.net.ssl.SSLException;
  }

  public class SSLEngineResult {
    ctor public SSLEngineResult(javax.net.ssl.SSLEngineResult.Status, javax.net.ssl.SSLEngineResult.HandshakeStatus, int, int);
    method public final int bytesConsumed();
    method public final int bytesProduced();
    method public final javax.net.ssl.SSLEngineResult.HandshakeStatus getHandshakeStatus();
    method public final javax.net.ssl.SSLEngineResult.Status getStatus();
  }

  public enum SSLEngineResult.HandshakeStatus {
    enum_constant public static final javax.net.ssl.SSLEngineResult.HandshakeStatus FINISHED;
    enum_constant public static final javax.net.ssl.SSLEngineResult.HandshakeStatus NEED_TASK;
    enum_constant public static final javax.net.ssl.SSLEngineResult.HandshakeStatus NEED_UNWRAP;
    enum_constant public static final javax.net.ssl.SSLEngineResult.HandshakeStatus NEED_WRAP;
    enum_constant public static final javax.net.ssl.SSLEngineResult.HandshakeStatus NOT_HANDSHAKING;
  }

  public enum SSLEngineResult.Status {
    enum_constant public static final javax.net.ssl.SSLEngineResult.Status BUFFER_OVERFLOW;
    enum_constant public static final javax.net.ssl.SSLEngineResult.Status BUFFER_UNDERFLOW;
    enum_constant public static final javax.net.ssl.SSLEngineResult.Status CLOSED;
    enum_constant public static final javax.net.ssl.SSLEngineResult.Status OK;
  }

  public class SSLException extends java.io.IOException {
    ctor public SSLException(String);
    ctor public SSLException(String, Throwable);
    ctor public SSLException(Throwable);
  }

  public class SSLHandshakeException extends javax.net.ssl.SSLException {
    ctor public SSLHandshakeException(String);
  }

  public class SSLKeyException extends javax.net.ssl.SSLException {
    ctor public SSLKeyException(String);
  }

  public class SSLParameters {
    ctor public SSLParameters();
    ctor public SSLParameters(String[]);
    ctor public SSLParameters(String[], String[]);
    method public java.security.AlgorithmConstraints getAlgorithmConstraints();
    method public String[] getApplicationProtocols();
    method public String[] getCipherSuites();
    method public String getEndpointIdentificationAlgorithm();
    method public boolean getNeedClientAuth();
    method public String[] getProtocols();
    method public final java.util.Collection<javax.net.ssl.SNIMatcher> getSNIMatchers();
    method public final java.util.List<javax.net.ssl.SNIServerName> getServerNames();
    method public final boolean getUseCipherSuitesOrder();
    method public boolean getWantClientAuth();
    method public void setAlgorithmConstraints(java.security.AlgorithmConstraints);
    method public void setApplicationProtocols(String[]);
    method public void setCipherSuites(String[]);
    method public void setEndpointIdentificationAlgorithm(String);
    method public void setNeedClientAuth(boolean);
    method public void setProtocols(String[]);
    method public final void setSNIMatchers(java.util.Collection<javax.net.ssl.SNIMatcher>);
    method public final void setServerNames(java.util.List<javax.net.ssl.SNIServerName>);
    method public final void setUseCipherSuitesOrder(boolean);
    method public void setWantClientAuth(boolean);
  }

  public class SSLPeerUnverifiedException extends javax.net.ssl.SSLException {
    ctor public SSLPeerUnverifiedException(String);
  }

  public final class SSLPermission extends java.security.BasicPermission {
    ctor public SSLPermission(String);
    ctor public SSLPermission(String, String);
  }

  public class SSLProtocolException extends javax.net.ssl.SSLException {
    ctor public SSLProtocolException(String);
  }

  public abstract class SSLServerSocket extends java.net.ServerSocket {
    ctor protected SSLServerSocket() throws java.io.IOException;
    ctor protected SSLServerSocket(int) throws java.io.IOException;
    ctor protected SSLServerSocket(int, int) throws java.io.IOException;
    ctor protected SSLServerSocket(int, int, java.net.InetAddress) throws java.io.IOException;
    method public abstract boolean getEnableSessionCreation();
    method public abstract String[] getEnabledCipherSuites();
    method public abstract String[] getEnabledProtocols();
    method public abstract boolean getNeedClientAuth();
    method public javax.net.ssl.SSLParameters getSSLParameters();
    method public abstract String[] getSupportedCipherSuites();
    method public abstract String[] getSupportedProtocols();
    method public abstract boolean getUseClientMode();
    method public abstract boolean getWantClientAuth();
    method public abstract void setEnableSessionCreation(boolean);
    method public abstract void setEnabledCipherSuites(String[]);
    method public abstract void setEnabledProtocols(String[]);
    method public abstract void setNeedClientAuth(boolean);
    method public void setSSLParameters(javax.net.ssl.SSLParameters);
    method public abstract void setUseClientMode(boolean);
    method public abstract void setWantClientAuth(boolean);
  }

  public abstract class SSLServerSocketFactory extends javax.net.ServerSocketFactory {
    ctor protected SSLServerSocketFactory();
    method public static javax.net.ServerSocketFactory getDefault();
    method public abstract String[] getDefaultCipherSuites();
    method public abstract String[] getSupportedCipherSuites();
  }

  public interface SSLSession {
    method public int getApplicationBufferSize();
    method public String getCipherSuite();
    method public long getCreationTime();
    method public byte[] getId();
    method public long getLastAccessedTime();
    method public java.security.cert.Certificate[] getLocalCertificates();
    method public java.security.Principal getLocalPrincipal();
    method public int getPacketBufferSize();
    method public javax.security.cert.X509Certificate[] getPeerCertificateChain() throws javax.net.ssl.SSLPeerUnverifiedException;
    method public java.security.cert.Certificate[] getPeerCertificates() throws javax.net.ssl.SSLPeerUnverifiedException;
    method public String getPeerHost();
    method public int getPeerPort();
    method public java.security.Principal getPeerPrincipal() throws javax.net.ssl.SSLPeerUnverifiedException;
    method public String getProtocol();
    method public javax.net.ssl.SSLSessionContext getSessionContext();
    method public Object getValue(String);
    method public String[] getValueNames();
    method public void invalidate();
    method public boolean isValid();
    method public void putValue(String, Object);
    method public void removeValue(String);
  }

  public class SSLSessionBindingEvent extends java.util.EventObject {
    ctor public SSLSessionBindingEvent(javax.net.ssl.SSLSession, String);
    method public String getName();
    method public javax.net.ssl.SSLSession getSession();
  }

  public interface SSLSessionBindingListener extends java.util.EventListener {
    method public void valueBound(javax.net.ssl.SSLSessionBindingEvent);
    method public void valueUnbound(javax.net.ssl.SSLSessionBindingEvent);
  }

  public interface SSLSessionContext {
    method public java.util.Enumeration<byte[]> getIds();
    method public javax.net.ssl.SSLSession getSession(byte[]);
    method public int getSessionCacheSize();
    method public int getSessionTimeout();
    method public void setSessionCacheSize(int) throws java.lang.IllegalArgumentException;
    method public void setSessionTimeout(int) throws java.lang.IllegalArgumentException;
  }

  public abstract class SSLSocket extends java.net.Socket {
    ctor protected SSLSocket();
    ctor protected SSLSocket(String, int) throws java.io.IOException, java.net.UnknownHostException;
    ctor protected SSLSocket(java.net.InetAddress, int) throws java.io.IOException;
    ctor protected SSLSocket(String, int, java.net.InetAddress, int) throws java.io.IOException, java.net.UnknownHostException;
    ctor protected SSLSocket(java.net.InetAddress, int, java.net.InetAddress, int) throws java.io.IOException;
    method public abstract void addHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener);
    method public String getApplicationProtocol();
    method public abstract boolean getEnableSessionCreation();
    method public abstract String[] getEnabledCipherSuites();
    method public abstract String[] getEnabledProtocols();
    method public String getHandshakeApplicationProtocol();
    method public java.util.function.BiFunction<javax.net.ssl.SSLSocket,java.util.List<java.lang.String>,java.lang.String> getHandshakeApplicationProtocolSelector();
    method public javax.net.ssl.SSLSession getHandshakeSession();
    method public abstract boolean getNeedClientAuth();
    method public javax.net.ssl.SSLParameters getSSLParameters();
    method public abstract javax.net.ssl.SSLSession getSession();
    method public abstract String[] getSupportedCipherSuites();
    method public abstract String[] getSupportedProtocols();
    method public abstract boolean getUseClientMode();
    method public abstract boolean getWantClientAuth();
    method public abstract void removeHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener);
    method public abstract void setEnableSessionCreation(boolean);
    method public abstract void setEnabledCipherSuites(String[]);
    method public abstract void setEnabledProtocols(String[]);
    method public void setHandshakeApplicationProtocolSelector(java.util.function.BiFunction<javax.net.ssl.SSLSocket,java.util.List<java.lang.String>,java.lang.String>);
    method public abstract void setNeedClientAuth(boolean);
    method public void setSSLParameters(javax.net.ssl.SSLParameters);
    method public abstract void setUseClientMode(boolean);
    method public abstract void setWantClientAuth(boolean);
    method public abstract void startHandshake() throws java.io.IOException;
  }

  public abstract class SSLSocketFactory extends javax.net.SocketFactory {
    ctor public SSLSocketFactory();
    method public abstract java.net.Socket createSocket(java.net.Socket, String, int, boolean) throws java.io.IOException;
    method public static javax.net.SocketFactory getDefault();
    method public abstract String[] getDefaultCipherSuites();
    method public abstract String[] getSupportedCipherSuites();
  }

  public final class StandardConstants {
    field public static final int SNI_HOST_NAME = 0; // 0x0
  }

  public interface TrustManager {
  }

  public class TrustManagerFactory {
    ctor protected TrustManagerFactory(javax.net.ssl.TrustManagerFactorySpi, java.security.Provider, String);
    method public final String getAlgorithm();
    method public static final String getDefaultAlgorithm();
    method public static final javax.net.ssl.TrustManagerFactory getInstance(String) throws java.security.NoSuchAlgorithmException;
    method public static final javax.net.ssl.TrustManagerFactory getInstance(String, String) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException;
    method public static final javax.net.ssl.TrustManagerFactory getInstance(String, java.security.Provider) throws java.security.NoSuchAlgorithmException;
    method public final java.security.Provider getProvider();
    method public final javax.net.ssl.TrustManager[] getTrustManagers();
    method public final void init(java.security.KeyStore) throws java.security.KeyStoreException;
    method public final void init(javax.net.ssl.ManagerFactoryParameters) throws java.security.InvalidAlgorithmParameterException;
  }

  public abstract class TrustManagerFactorySpi {
    ctor public TrustManagerFactorySpi();
    method protected abstract javax.net.ssl.TrustManager[] engineGetTrustManagers();
    method protected abstract void engineInit(java.security.KeyStore) throws java.security.KeyStoreException;
    method protected abstract void engineInit(javax.net.ssl.ManagerFactoryParameters) throws java.security.InvalidAlgorithmParameterException;
  }

  public abstract class X509ExtendedKeyManager implements javax.net.ssl.X509KeyManager {
    ctor protected X509ExtendedKeyManager();
    method public String chooseEngineClientAlias(String[], java.security.Principal[], javax.net.ssl.SSLEngine);
    method public String chooseEngineServerAlias(String, java.security.Principal[], javax.net.ssl.SSLEngine);
  }

  public abstract class X509ExtendedTrustManager implements javax.net.ssl.X509TrustManager {
    ctor public X509ExtendedTrustManager();
    method public abstract void checkClientTrusted(java.security.cert.X509Certificate[], String, java.net.Socket) throws java.security.cert.CertificateException;
    method public abstract void checkClientTrusted(java.security.cert.X509Certificate[], String, javax.net.ssl.SSLEngine) throws java.security.cert.CertificateException;
    method public abstract void checkServerTrusted(java.security.cert.X509Certificate[], String, java.net.Socket) throws java.security.cert.CertificateException;
    method public abstract void checkServerTrusted(java.security.cert.X509Certificate[], String, javax.net.ssl.SSLEngine) throws java.security.cert.CertificateException;
  }

  public interface X509KeyManager extends javax.net.ssl.KeyManager {
    method public String chooseClientAlias(String[], java.security.Principal[], java.net.Socket);
    method public String chooseServerAlias(String, java.security.Principal[], java.net.Socket);
    method public java.security.cert.X509Certificate[] getCertificateChain(String);
    method public String[] getClientAliases(String, java.security.Principal[]);
    method public java.security.PrivateKey getPrivateKey(String);
    method public String[] getServerAliases(String, java.security.Principal[]);
  }

  public interface X509TrustManager extends javax.net.ssl.TrustManager {
    method public void checkClientTrusted(java.security.cert.X509Certificate[], String) throws java.security.cert.CertificateException;
    method public void checkServerTrusted(java.security.cert.X509Certificate[], String) throws java.security.cert.CertificateException;
    method public java.security.cert.X509Certificate[] getAcceptedIssuers();
  }

}

package javax.security.auth {

  public final class AuthPermission extends java.security.BasicPermission {
    ctor public AuthPermission(String);
    ctor public AuthPermission(String, String);
  }

  public class DestroyFailedException extends java.lang.Exception {
    ctor public DestroyFailedException();
    ctor public DestroyFailedException(String);
  }

  public interface Destroyable {
    method public default void destroy() throws javax.security.auth.DestroyFailedException;
    method public default boolean isDestroyed();
  }

  public final class PrivateCredentialPermission extends java.security.Permission {
    ctor public PrivateCredentialPermission(String, String);
    method public String getActions();
    method public String getCredentialClass();
    method public String[][] getPrincipals();
    method public boolean implies(java.security.Permission);
  }

  public final class Subject implements java.io.Serializable {
    ctor public Subject();
    ctor public Subject(boolean, java.util.Set<? extends java.security.Principal>, java.util.Set<?>, java.util.Set<?>);
    method public static <T> T doAs(javax.security.auth.Subject, java.security.PrivilegedAction<T>);
    method public static <T> T doAs(javax.security.auth.Subject, java.security.PrivilegedExceptionAction<T>) throws java.security.PrivilegedActionException;
    method public static <T> T doAsPrivileged(javax.security.auth.Subject, java.security.PrivilegedAction<T>, java.security.AccessControlContext);
    method public static <T> T doAsPrivileged(javax.security.auth.Subject, java.security.PrivilegedExceptionAction<T>, java.security.AccessControlContext) throws java.security.PrivilegedActionException;
    method public java.util.Set<java.security.Principal> getPrincipals();
    method public <T extends java.security.Principal> java.util.Set<T> getPrincipals(Class<T>);
    method public java.util.Set<java.lang.Object> getPrivateCredentials();
    method public <T> java.util.Set<T> getPrivateCredentials(Class<T>);
    method public java.util.Set<java.lang.Object> getPublicCredentials();
    method public <T> java.util.Set<T> getPublicCredentials(Class<T>);
    method public static javax.security.auth.Subject getSubject(java.security.AccessControlContext);
    method public boolean isReadOnly();
    method public void setReadOnly();
  }

  public class SubjectDomainCombiner implements java.security.DomainCombiner {
    ctor public SubjectDomainCombiner(javax.security.auth.Subject);
    method public java.security.ProtectionDomain[] combine(java.security.ProtectionDomain[], java.security.ProtectionDomain[]);
    method public javax.security.auth.Subject getSubject();
  }

}

package javax.security.auth.callback {

  public interface Callback {
  }

  public interface CallbackHandler {
    method public void handle(javax.security.auth.callback.Callback[]) throws java.io.IOException, javax.security.auth.callback.UnsupportedCallbackException;
  }

  public class PasswordCallback implements javax.security.auth.callback.Callback java.io.Serializable {
    ctor public PasswordCallback(String, boolean);
    method public void clearPassword();
    method public char[] getPassword();
    method public String getPrompt();
    method public boolean isEchoOn();
    method public void setPassword(char[]);
  }

  public class UnsupportedCallbackException extends java.lang.Exception {
    ctor public UnsupportedCallbackException(javax.security.auth.callback.Callback);
    ctor public UnsupportedCallbackException(javax.security.auth.callback.Callback, String);
    method public javax.security.auth.callback.Callback getCallback();
  }

}

package javax.security.auth.login {

  public class LoginException extends java.security.GeneralSecurityException {
    ctor public LoginException();
    ctor public LoginException(String);
  }

}

package javax.security.auth.x500 {

  public final class X500Principal implements java.security.Principal java.io.Serializable {
    ctor public X500Principal(String);
    ctor public X500Principal(String, java.util.Map<java.lang.String,java.lang.String>);
    ctor public X500Principal(byte[]);
    ctor public X500Principal(java.io.InputStream);
    method public boolean equals(Object);
    method public byte[] getEncoded();
    method public String getName();
    method public String getName(String);
    method public String getName(String, java.util.Map<java.lang.String,java.lang.String>);
    method public int hashCode();
    method public String toString();
    field public static final String CANONICAL = "CANONICAL";
    field public static final String RFC1779 = "RFC1779";
    field public static final String RFC2253 = "RFC2253";
  }

  @FlaggedApi("com.android.libcore.v_apis") public final class X500PrivateCredential implements javax.security.auth.Destroyable {
    ctor public X500PrivateCredential(java.security.cert.X509Certificate, java.security.PrivateKey);
    ctor public X500PrivateCredential(java.security.cert.X509Certificate, java.security.PrivateKey, String);
    method public void destroy();
    method public String getAlias();
    method public java.security.cert.X509Certificate getCertificate();
    method public java.security.PrivateKey getPrivateKey();
    method public boolean isDestroyed();
  }

}

package javax.security.cert {

  public abstract class Certificate {
    ctor public Certificate();
    method public abstract byte[] getEncoded() throws javax.security.cert.CertificateEncodingException;
    method public abstract java.security.PublicKey getPublicKey();
    method public abstract String toString();
    method public abstract void verify(java.security.PublicKey) throws javax.security.cert.CertificateException, java.security.InvalidKeyException, java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException, java.security.SignatureException;
    method public abstract void verify(java.security.PublicKey, String) throws javax.security.cert.CertificateException, java.security.InvalidKeyException, java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException, java.security.SignatureException;
  }

  public class CertificateEncodingException extends javax.security.cert.CertificateException {
    ctor public CertificateEncodingException();
    ctor public CertificateEncodingException(String);
  }

  public class CertificateException extends java.lang.Exception {
    ctor public CertificateException();
    ctor public CertificateException(String);
  }

  public class CertificateExpiredException extends javax.security.cert.CertificateException {
    ctor public CertificateExpiredException();
    ctor public CertificateExpiredException(String);
  }

  public class CertificateNotYetValidException extends javax.security.cert.CertificateException {
    ctor public CertificateNotYetValidException();
    ctor public CertificateNotYetValidException(String);
  }

  public class CertificateParsingException extends javax.security.cert.CertificateException {
    ctor public CertificateParsingException();
    ctor public CertificateParsingException(String);
  }

  public abstract class X509Certificate extends javax.security.cert.Certificate {
    ctor public X509Certificate();
    method public abstract void checkValidity() throws javax.security.cert.CertificateExpiredException, javax.security.cert.CertificateNotYetValidException;
    method public abstract void checkValidity(java.util.Date) throws javax.security.cert.CertificateExpiredException, javax.security.cert.CertificateNotYetValidException;
    method public static final javax.security.cert.X509Certificate getInstance(java.io.InputStream) throws javax.security.cert.CertificateException;
    method public static final javax.security.cert.X509Certificate getInstance(byte[]) throws javax.security.cert.CertificateException;
    method public abstract java.security.Principal getIssuerDN();
    method public abstract java.util.Date getNotAfter();
    method public abstract java.util.Date getNotBefore();
    method public abstract java.math.BigInteger getSerialNumber();
    method public abstract String getSigAlgName();
    method public abstract String getSigAlgOID();
    method public abstract byte[] getSigAlgParams();
    method public abstract java.security.Principal getSubjectDN();
    method public abstract int getVersion();
  }

}

package javax.sql {

  public interface CommonDataSource {
    method public java.io.PrintWriter getLogWriter() throws java.sql.SQLException;
    method public int getLoginTimeout() throws java.sql.SQLException;
    method public java.util.logging.Logger getParentLogger() throws java.sql.SQLFeatureNotSupportedException;
    method public void setLogWriter(java.io.PrintWriter) throws java.sql.SQLException;
    method public void setLoginTimeout(int) throws java.sql.SQLException;
  }

  public class ConnectionEvent extends java.util.EventObject {
    ctor public ConnectionEvent(javax.sql.PooledConnection);
    ctor public ConnectionEvent(javax.sql.PooledConnection, java.sql.SQLException);
    method public java.sql.SQLException getSQLException();
  }

  public interface ConnectionEventListener extends java.util.EventListener {
    method public void connectionClosed(javax.sql.ConnectionEvent);
    method public void connectionErrorOccurred(javax.sql.ConnectionEvent);
  }

  public interface ConnectionPoolDataSource extends javax.sql.CommonDataSource {
    method public javax.sql.PooledConnection getPooledConnection() throws java.sql.SQLException;
    method public javax.sql.PooledConnection getPooledConnection(String, String) throws java.sql.SQLException;
  }

  public interface DataSource extends javax.sql.CommonDataSource java.sql.Wrapper {
    method public java.sql.Connection getConnection() throws java.sql.SQLException;
    method public java.sql.Connection getConnection(String, String) throws java.sql.SQLException;
  }

  public interface PooledConnection {
    method public void addConnectionEventListener(javax.sql.ConnectionEventListener);
    method public void addStatementEventListener(javax.sql.StatementEventListener);
    method public void close() throws java.sql.SQLException;
    method public java.sql.Connection getConnection() throws java.sql.SQLException;
    method public void removeConnectionEventListener(javax.sql.ConnectionEventListener);
    method public void removeStatementEventListener(javax.sql.StatementEventListener);
  }

  public interface RowSet extends java.sql.ResultSet {
    method public void addRowSetListener(javax.sql.RowSetListener);
    method public void clearParameters() throws java.sql.SQLException;
    method public void execute() throws java.sql.SQLException;
    method public String getCommand();
    method public String getDataSourceName();
    method public boolean getEscapeProcessing() throws java.sql.SQLException;
    method public int getMaxFieldSize() throws java.sql.SQLException;
    method public int getMaxRows() throws java.sql.SQLException;
    method public String getPassword();
    method public int getQueryTimeout() throws java.sql.SQLException;
    method public int getTransactionIsolation();
    method public java.util.Map<java.lang.String,java.lang.Class<?>> getTypeMap() throws java.sql.SQLException;
    method public String getUrl() throws java.sql.SQLException;
    method public String getUsername();
    method public boolean isReadOnly();
    method public void removeRowSetListener(javax.sql.RowSetListener);
    method public void setArray(int, java.sql.Array) throws java.sql.SQLException;
    method public void setAsciiStream(int, java.io.InputStream, int) throws java.sql.SQLException;
    method public void setAsciiStream(String, java.io.InputStream, int) throws java.sql.SQLException;
    method public void setAsciiStream(int, java.io.InputStream) throws java.sql.SQLException;
    method public void setAsciiStream(String, java.io.InputStream) throws java.sql.SQLException;
    method public void setBigDecimal(int, java.math.BigDecimal) throws java.sql.SQLException;
    method public void setBigDecimal(String, java.math.BigDecimal) throws java.sql.SQLException;
    method public void setBinaryStream(int, java.io.InputStream, int) throws java.sql.SQLException;
    method public void setBinaryStream(String, java.io.InputStream, int) throws java.sql.SQLException;
    method public void setBinaryStream(int, java.io.InputStream) throws java.sql.SQLException;
    method public void setBinaryStream(String, java.io.InputStream) throws java.sql.SQLException;
    method public void setBlob(int, java.sql.Blob) throws java.sql.SQLException;
    method public void setBlob(int, java.io.InputStream, long) throws java.sql.SQLException;
    method public void setBlob(int, java.io.InputStream) throws java.sql.SQLException;
    method public void setBlob(String, java.io.InputStream, long) throws java.sql.SQLException;
    method public void setBlob(String, java.sql.Blob) throws java.sql.SQLException;
    method public void setBlob(String, java.io.InputStream) throws java.sql.SQLException;
    method public void setBoolean(int, boolean) throws java.sql.SQLException;
    method public void setBoolean(String, boolean) throws java.sql.SQLException;
    method public void setByte(int, byte) throws java.sql.SQLException;
    method public void setByte(String, byte) throws java.sql.SQLException;
    method public void setBytes(int, byte[]) throws java.sql.SQLException;
    method public void setBytes(String, byte[]) throws java.sql.SQLException;
    method public void setCharacterStream(int, java.io.Reader, int) throws java.sql.SQLException;
    method public void setCharacterStream(String, java.io.Reader, int) throws java.sql.SQLException;
    method public void setCharacterStream(int, java.io.Reader) throws java.sql.SQLException;
    method public void setCharacterStream(String, java.io.Reader) throws java.sql.SQLException;
    method public void setClob(int, java.sql.Clob) throws java.sql.SQLException;
    method public void setClob(int, java.io.Reader, long) throws java.sql.SQLException;
    method public void setClob(int, java.io.Reader) throws java.sql.SQLException;
    method public void setClob(String, java.io.Reader, long) throws java.sql.SQLException;
    method public void setClob(String, java.sql.Clob) throws java.sql.SQLException;
    method public void setClob(String, java.io.Reader) throws java.sql.SQLException;
    method public void setCommand(String) throws java.sql.SQLException;
    method public void setConcurrency(int) throws java.sql.SQLException;
    method public void setDataSourceName(String) throws java.sql.SQLException;
    method public void setDate(int, java.sql.Date) throws java.sql.SQLException;
    method public void setDate(int, java.sql.Date, java.util.Calendar) throws java.sql.SQLException;
    method public void setDate(String, java.sql.Date) throws java.sql.SQLException;
    method public void setDate(String, java.sql.Date, java.util.Calendar) throws java.sql.SQLException;
    method public void setDouble(int, double) throws java.sql.SQLException;
    method public void setDouble(String, double) throws java.sql.SQLException;
    method public void setEscapeProcessing(boolean) throws java.sql.SQLException;
    method public void setFloat(int, float) throws java.sql.SQLException;
    method public void setFloat(String, float) throws java.sql.SQLException;
    method public void setInt(int, int) throws java.sql.SQLException;
    method public void setInt(String, int) throws java.sql.SQLException;
    method public void setLong(int, long) throws java.sql.SQLException;
    method public void setLong(String, long) throws java.sql.SQLException;
    method public void setMaxFieldSize(int) throws java.sql.SQLException;
    method public void setMaxRows(int) throws java.sql.SQLException;
    method public void setNCharacterStream(int, java.io.Reader) throws java.sql.SQLException;
    method public void setNCharacterStream(int, java.io.Reader, long) throws java.sql.SQLException;
    method public void setNCharacterStream(String, java.io.Reader, long) throws java.sql.SQLException;
    method public void setNCharacterStream(String, java.io.Reader) throws java.sql.SQLException;
    method public void setNClob(String, java.sql.NClob) throws java.sql.SQLException;
    method public void setNClob(String, java.io.Reader, long) throws java.sql.SQLException;
    method public void setNClob(String, java.io.Reader) throws java.sql.SQLException;
    method public void setNClob(int, java.io.Reader, long) throws java.sql.SQLException;
    method public void setNClob(int, java.sql.NClob) throws java.sql.SQLException;
    method public void setNClob(int, java.io.Reader) throws java.sql.SQLException;
    method public void setNString(int, String) throws java.sql.SQLException;
    method public void setNString(String, String) throws java.sql.SQLException;
    method public void setNull(int, int) throws java.sql.SQLException;
    method public void setNull(String, int) throws java.sql.SQLException;
    method public void setNull(int, int, String) throws java.sql.SQLException;
    method public void setNull(String, int, String) throws java.sql.SQLException;
    method public void setObject(int, Object, int, int) throws java.sql.SQLException;
    method public void setObject(String, Object, int, int) throws java.sql.SQLException;
    method public void setObject(int, Object, int) throws java.sql.SQLException;
    method public void setObject(String, Object, int) throws java.sql.SQLException;
    method public void setObject(String, Object) throws java.sql.SQLException;
    method public void setObject(int, Object) throws java.sql.SQLException;
    method public void setPassword(String) throws java.sql.SQLException;
    method public void setQueryTimeout(int) throws java.sql.SQLException;
    method public void setReadOnly(boolean) throws java.sql.SQLException;
    method public void setRef(int, java.sql.Ref) throws java.sql.SQLException;
    method public void setRowId(int, java.sql.RowId) throws java.sql.SQLException;
    method public void setRowId(String, java.sql.RowId) throws java.sql.SQLException;
    method public void setSQLXML(int, java.sql.SQLXML) throws java.sql.SQLException;
    method public void setSQLXML(String, java.sql.SQLXML) throws java.sql.SQLException;
    method public void setShort(int, short) throws java.sql.SQLException;
    method public void setShort(String, short) throws java.sql.SQLException;
    method public void setString(int, String) throws java.sql.SQLException;
    method public void setString(String, String) throws java.sql.SQLException;
    method public void setTime(int, java.sql.Time) throws java.sql.SQLException;
    method public void setTime(int, java.sql.Time, java.util.Calendar) throws java.sql.SQLException;
    method public void setTime(String, java.sql.Time) throws java.sql.SQLException;
    method public void setTime(String, java.sql.Time, java.util.Calendar) throws java.sql.SQLException;
    method public void setTimestamp(int, java.sql.Timestamp) throws java.sql.SQLException;
    method public void setTimestamp(String, java.sql.Timestamp) throws java.sql.SQLException;
    method public void setTimestamp(int, java.sql.Timestamp, java.util.Calendar) throws java.sql.SQLException;
    method public void setTimestamp(String, java.sql.Timestamp, java.util.Calendar) throws java.sql.SQLException;
    method public void setTransactionIsolation(int) throws java.sql.SQLException;
    method public void setType(int) throws java.sql.SQLException;
    method public void setTypeMap(java.util.Map<java.lang.String,java.lang.Class<?>>) throws java.sql.SQLException;
    method public void setURL(int, java.net.URL) throws java.sql.SQLException;
    method public void setUrl(String) throws java.sql.SQLException;
    method public void setUsername(String) throws java.sql.SQLException;
  }

  public class RowSetEvent extends java.util.EventObject {
    ctor public RowSetEvent(javax.sql.RowSet);
  }

  public interface RowSetInternal {
    method public java.sql.Connection getConnection() throws java.sql.SQLException;
    method public java.sql.ResultSet getOriginal() throws java.sql.SQLException;
    method public java.sql.ResultSet getOriginalRow() throws java.sql.SQLException;
    method public Object[] getParams() throws java.sql.SQLException;
    method public void setMetaData(javax.sql.RowSetMetaData) throws java.sql.SQLException;
  }

  public interface RowSetListener extends java.util.EventListener {
    method public void cursorMoved(javax.sql.RowSetEvent);
    method public void rowChanged(javax.sql.RowSetEvent);
    method public void rowSetChanged(javax.sql.RowSetEvent);
  }

  public interface RowSetMetaData extends java.sql.ResultSetMetaData {
    method public void setAutoIncrement(int, boolean) throws java.sql.SQLException;
    method public void setCaseSensitive(int, boolean) throws java.sql.SQLException;
    method public void setCatalogName(int, String) throws java.sql.SQLException;
    method public void setColumnCount(int) throws java.sql.SQLException;
    method public void setColumnDisplaySize(int, int) throws java.sql.SQLException;
    method public void setColumnLabel(int, String) throws java.sql.SQLException;
    method public void setColumnName(int, String) throws java.sql.SQLException;
    method public void setColumnType(int, int) throws java.sql.SQLException;
    method public void setColumnTypeName(int, String) throws java.sql.SQLException;
    method public void setCurrency(int, boolean) throws java.sql.SQLException;
    method public void setNullable(int, int) throws java.sql.SQLException;
    method public void setPrecision(int, int) throws java.sql.SQLException;
    method public void setScale(int, int) throws java.sql.SQLException;
    method public void setSchemaName(int, String) throws java.sql.SQLException;
    method public void setSearchable(int, boolean) throws java.sql.SQLException;
    method public void setSigned(int, boolean) throws java.sql.SQLException;
    method public void setTableName(int, String) throws java.sql.SQLException;
  }

  public interface RowSetReader {
    method public void readData(javax.sql.RowSetInternal) throws java.sql.SQLException;
  }

  public interface RowSetWriter {
    method public boolean writeData(javax.sql.RowSetInternal) throws java.sql.SQLException;
  }

  public class StatementEvent extends java.util.EventObject {
    ctor public StatementEvent(javax.sql.PooledConnection, java.sql.PreparedStatement);
    ctor public StatementEvent(javax.sql.PooledConnection, java.sql.PreparedStatement, java.sql.SQLException);
    method public java.sql.SQLException getSQLException();
    method public java.sql.PreparedStatement getStatement();
  }

  public interface StatementEventListener extends java.util.EventListener {
    method public void statementClosed(javax.sql.StatementEvent);
    method public void statementErrorOccurred(javax.sql.StatementEvent);
  }

}

package javax.xml {

  public final class XMLConstants {
    field public static final String DEFAULT_NS_PREFIX = "";
    field public static final String FEATURE_SECURE_PROCESSING = "http://javax.xml.XMLConstants/feature/secure-processing";
    field public static final String NULL_NS_URI = "";
    field public static final String RELAXNG_NS_URI = "http://relaxng.org/ns/structure/1.0";
    field public static final String W3C_XML_SCHEMA_INSTANCE_NS_URI = "http://www.w3.org/2001/XMLSchema-instance";
    field public static final String W3C_XML_SCHEMA_NS_URI = "http://www.w3.org/2001/XMLSchema";
    field public static final String W3C_XPATH_DATATYPE_NS_URI = "http://www.w3.org/2003/11/xpath-datatypes";
    field public static final String XMLNS_ATTRIBUTE = "xmlns";
    field public static final String XMLNS_ATTRIBUTE_NS_URI = "http://www.w3.org/2000/xmlns/";
    field public static final String XML_DTD_NS_URI = "http://www.w3.org/TR/REC-xml";
    field public static final String XML_NS_PREFIX = "xml";
    field public static final String XML_NS_URI = "http://www.w3.org/XML/1998/namespace";
  }

}

package javax.xml.datatype {

  public class DatatypeConfigurationException extends java.lang.Exception {
    ctor public DatatypeConfigurationException();
    ctor public DatatypeConfigurationException(String);
    ctor public DatatypeConfigurationException(String, Throwable);
    ctor public DatatypeConfigurationException(Throwable);
  }

  public final class DatatypeConstants {
    field public static final int APRIL = 4; // 0x4
    field public static final int AUGUST = 8; // 0x8
    field public static final javax.xml.namespace.QName DATE;
    field public static final javax.xml.namespace.QName DATETIME;
    field public static final javax.xml.datatype.DatatypeConstants.Field DAYS;
    field public static final int DECEMBER = 12; // 0xc
    field public static final javax.xml.namespace.QName DURATION;
    field public static final javax.xml.namespace.QName DURATION_DAYTIME;
    field public static final javax.xml.namespace.QName DURATION_YEARMONTH;
    field public static final int EQUAL = 0; // 0x0
    field public static final int FEBRUARY = 2; // 0x2
    field public static final int FIELD_UNDEFINED = -2147483648; // 0x80000000
    field public static final javax.xml.namespace.QName GDAY;
    field public static final javax.xml.namespace.QName GMONTH;
    field public static final javax.xml.namespace.QName GMONTHDAY;
    field public static final int GREATER = 1; // 0x1
    field public static final javax.xml.namespace.QName GYEAR;
    field public static final javax.xml.namespace.QName GYEARMONTH;
    field public static final javax.xml.datatype.DatatypeConstants.Field HOURS;
    field public static final int INDETERMINATE = 2; // 0x2
    field public static final int JANUARY = 1; // 0x1
    field public static final int JULY = 7; // 0x7
    field public static final int JUNE = 6; // 0x6
    field public static final int LESSER = -1; // 0xffffffff
    field public static final int MARCH = 3; // 0x3
    field public static final int MAX_TIMEZONE_OFFSET = -840; // 0xfffffcb8
    field public static final int MAY = 5; // 0x5
    field public static final javax.xml.datatype.DatatypeConstants.Field MINUTES;
    field public static final int MIN_TIMEZONE_OFFSET = 840; // 0x348
    field public static final javax.xml.datatype.DatatypeConstants.Field MONTHS;
    field public static final int NOVEMBER = 11; // 0xb
    field public static final int OCTOBER = 10; // 0xa
    field public static final javax.xml.datatype.DatatypeConstants.Field SECONDS;
    field public static final int SEPTEMBER = 9; // 0x9
    field public static final javax.xml.namespace.QName TIME;
    field public static final javax.xml.datatype.DatatypeConstants.Field YEARS;
  }

  public static final class DatatypeConstants.Field {
    method public int getId();
  }

  public abstract class DatatypeFactory {
    ctor protected DatatypeFactory();
    method public abstract javax.xml.datatype.Duration newDuration(String);
    method public abstract javax.xml.datatype.Duration newDuration(long);
    method public abstract javax.xml.datatype.Duration newDuration(boolean, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigDecimal);
    method public javax.xml.datatype.Duration newDuration(boolean, int, int, int, int, int, int);
    method public javax.xml.datatype.Duration newDurationDayTime(String);
    method public javax.xml.datatype.Duration newDurationDayTime(long);
    method public javax.xml.datatype.Duration newDurationDayTime(boolean, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger);
    method public javax.xml.datatype.Duration newDurationDayTime(boolean, int, int, int, int);
    method public javax.xml.datatype.Duration newDurationYearMonth(String);
    method public javax.xml.datatype.Duration newDurationYearMonth(long);
    method public javax.xml.datatype.Duration newDurationYearMonth(boolean, java.math.BigInteger, java.math.BigInteger);
    method public javax.xml.datatype.Duration newDurationYearMonth(boolean, int, int);
    method public static javax.xml.datatype.DatatypeFactory newInstance() throws javax.xml.datatype.DatatypeConfigurationException;
    method public static javax.xml.datatype.DatatypeFactory newInstance(String, ClassLoader) throws javax.xml.datatype.DatatypeConfigurationException;
    method public abstract javax.xml.datatype.XMLGregorianCalendar newXMLGregorianCalendar();
    method public abstract javax.xml.datatype.XMLGregorianCalendar newXMLGregorianCalendar(String);
    method public abstract javax.xml.datatype.XMLGregorianCalendar newXMLGregorianCalendar(java.util.GregorianCalendar);
    method public abstract javax.xml.datatype.XMLGregorianCalendar newXMLGregorianCalendar(java.math.BigInteger, int, int, int, int, int, java.math.BigDecimal, int);
    method public javax.xml.datatype.XMLGregorianCalendar newXMLGregorianCalendar(int, int, int, int, int, int, int, int);
    method public javax.xml.datatype.XMLGregorianCalendar newXMLGregorianCalendarDate(int, int, int, int);
    method public javax.xml.datatype.XMLGregorianCalendar newXMLGregorianCalendarTime(int, int, int, int);
    method public javax.xml.datatype.XMLGregorianCalendar newXMLGregorianCalendarTime(int, int, int, java.math.BigDecimal, int);
    method public javax.xml.datatype.XMLGregorianCalendar newXMLGregorianCalendarTime(int, int, int, int, int);
    field public static final String DATATYPEFACTORY_IMPLEMENTATION_CLASS;
    field public static final String DATATYPEFACTORY_PROPERTY = "javax.xml.datatype.DatatypeFactory";
  }

  public abstract class Duration {
    ctor public Duration();
    method public abstract javax.xml.datatype.Duration add(javax.xml.datatype.Duration);
    method public abstract void addTo(java.util.Calendar);
    method public void addTo(java.util.Date);
    method public abstract int compare(javax.xml.datatype.Duration);
    method public int getDays();
    method public abstract Number getField(javax.xml.datatype.DatatypeConstants.Field);
    method public int getHours();
    method public int getMinutes();
    method public int getMonths();
    method public int getSeconds();
    method public abstract int getSign();
    method public long getTimeInMillis(java.util.Calendar);
    method public long getTimeInMillis(java.util.Date);
    method public javax.xml.namespace.QName getXMLSchemaType();
    method public int getYears();
    method public abstract int hashCode();
    method public boolean isLongerThan(javax.xml.datatype.Duration);
    method public abstract boolean isSet(javax.xml.datatype.DatatypeConstants.Field);
    method public boolean isShorterThan(javax.xml.datatype.Duration);
    method public javax.xml.datatype.Duration multiply(int);
    method public abstract javax.xml.datatype.Duration multiply(java.math.BigDecimal);
    method public abstract javax.xml.datatype.Duration negate();
    method public abstract javax.xml.datatype.Duration normalizeWith(java.util.Calendar);
    method public javax.xml.datatype.Duration subtract(javax.xml.datatype.Duration);
  }

  public abstract class XMLGregorianCalendar implements java.lang.Cloneable {
    ctor public XMLGregorianCalendar();
    method public abstract void add(javax.xml.datatype.Duration);
    method public abstract void clear();
    method public abstract Object clone();
    method public abstract int compare(javax.xml.datatype.XMLGregorianCalendar);
    method public abstract int getDay();
    method public abstract java.math.BigInteger getEon();
    method public abstract java.math.BigInteger getEonAndYear();
    method public abstract java.math.BigDecimal getFractionalSecond();
    method public abstract int getHour();
    method public int getMillisecond();
    method public abstract int getMinute();
    method public abstract int getMonth();
    method public abstract int getSecond();
    method public abstract java.util.TimeZone getTimeZone(int);
    method public abstract int getTimezone();
    method public abstract javax.xml.namespace.QName getXMLSchemaType();
    method public abstract int getYear();
    method public abstract boolean isValid();
    method public abstract javax.xml.datatype.XMLGregorianCalendar normalize();
    method public abstract void reset();
    method public abstract void setDay(int);
    method public abstract void setFractionalSecond(java.math.BigDecimal);
    method public abstract void setHour(int);
    method public abstract void setMillisecond(int);
    method public abstract void setMinute(int);
    method public abstract void setMonth(int);
    method public abstract void setSecond(int);
    method public void setTime(int, int, int);
    method public void setTime(int, int, int, java.math.BigDecimal);
    method public void setTime(int, int, int, int);
    method public abstract void setTimezone(int);
    method public abstract void setYear(java.math.BigInteger);
    method public abstract void setYear(int);
    method public abstract java.util.GregorianCalendar toGregorianCalendar();
    method public abstract java.util.GregorianCalendar toGregorianCalendar(java.util.TimeZone, java.util.Locale, javax.xml.datatype.XMLGregorianCalendar);
    method public abstract String toXMLFormat();
  }

}

package javax.xml.namespace {

  public interface NamespaceContext {
    method public String getNamespaceURI(String);
    method public String getPrefix(String);
    method public java.util.Iterator getPrefixes(String);
  }

  public class QName implements java.io.Serializable {
    ctor public QName(String, String);
    ctor public QName(String, String, String);
    ctor public QName(String);
    method public final boolean equals(Object);
    method public String getLocalPart();
    method public String getNamespaceURI();
    method public String getPrefix();
    method public final int hashCode();
    method public static javax.xml.namespace.QName valueOf(String);
  }

}

package javax.xml.parsers {

  public abstract class DocumentBuilder {
    ctor protected DocumentBuilder();
    method public abstract org.w3c.dom.DOMImplementation getDOMImplementation();
    method public javax.xml.validation.Schema getSchema();
    method public abstract boolean isNamespaceAware();
    method public abstract boolean isValidating();
    method public boolean isXIncludeAware();
    method public abstract org.w3c.dom.Document newDocument();
    method public org.w3c.dom.Document parse(java.io.InputStream) throws java.io.IOException, org.xml.sax.SAXException;
    method public org.w3c.dom.Document parse(java.io.InputStream, String) throws java.io.IOException, org.xml.sax.SAXException;
    method public org.w3c.dom.Document parse(String) throws java.io.IOException, org.xml.sax.SAXException;
    method public org.w3c.dom.Document parse(java.io.File) throws java.io.IOException, org.xml.sax.SAXException;
    method public abstract org.w3c.dom.Document parse(org.xml.sax.InputSource) throws java.io.IOException, org.xml.sax.SAXException;
    method public void reset();
    method public abstract void setEntityResolver(org.xml.sax.EntityResolver);
    method public abstract void setErrorHandler(org.xml.sax.ErrorHandler);
  }

  public abstract class DocumentBuilderFactory {
    ctor protected DocumentBuilderFactory();
    method public abstract Object getAttribute(String) throws java.lang.IllegalArgumentException;
    method public abstract boolean getFeature(String) throws javax.xml.parsers.ParserConfigurationException;
    method public javax.xml.validation.Schema getSchema();
    method public boolean isCoalescing();
    method public boolean isExpandEntityReferences();
    method public boolean isIgnoringComments();
    method public boolean isIgnoringElementContentWhitespace();
    method public boolean isNamespaceAware();
    method public boolean isValidating();
    method public boolean isXIncludeAware();
    method public abstract javax.xml.parsers.DocumentBuilder newDocumentBuilder() throws javax.xml.parsers.ParserConfigurationException;
    method public static javax.xml.parsers.DocumentBuilderFactory newInstance();
    method public static javax.xml.parsers.DocumentBuilderFactory newInstance(String, ClassLoader);
    method public abstract void setAttribute(String, Object) throws java.lang.IllegalArgumentException;
    method public void setCoalescing(boolean);
    method public void setExpandEntityReferences(boolean);
    method public abstract void setFeature(String, boolean) throws javax.xml.parsers.ParserConfigurationException;
    method public void setIgnoringComments(boolean);
    method public void setIgnoringElementContentWhitespace(boolean);
    method public void setNamespaceAware(boolean);
    method public void setSchema(javax.xml.validation.Schema);
    method public void setValidating(boolean);
    method public void setXIncludeAware(boolean);
  }

  public class FactoryConfigurationError extends java.lang.Error {
    ctor public FactoryConfigurationError();
    ctor public FactoryConfigurationError(String);
    ctor public FactoryConfigurationError(Exception);
    ctor public FactoryConfigurationError(Exception, String);
    method public Exception getException();
  }

  public class ParserConfigurationException extends java.lang.Exception {
    ctor public ParserConfigurationException();
    ctor public ParserConfigurationException(String);
  }

  public abstract class SAXParser {
    ctor protected SAXParser();
    method public abstract org.xml.sax.Parser getParser() throws org.xml.sax.SAXException;
    method public abstract Object getProperty(String) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public javax.xml.validation.Schema getSchema();
    method public abstract org.xml.sax.XMLReader getXMLReader() throws org.xml.sax.SAXException;
    method public abstract boolean isNamespaceAware();
    method public abstract boolean isValidating();
    method public boolean isXIncludeAware();
    method public void parse(java.io.InputStream, org.xml.sax.HandlerBase) throws java.io.IOException, org.xml.sax.SAXException;
    method public void parse(java.io.InputStream, org.xml.sax.HandlerBase, String) throws java.io.IOException, org.xml.sax.SAXException;
    method public void parse(java.io.InputStream, org.xml.sax.helpers.DefaultHandler) throws java.io.IOException, org.xml.sax.SAXException;
    method public void parse(java.io.InputStream, org.xml.sax.helpers.DefaultHandler, String) throws java.io.IOException, org.xml.sax.SAXException;
    method public void parse(String, org.xml.sax.HandlerBase) throws java.io.IOException, org.xml.sax.SAXException;
    method public void parse(String, org.xml.sax.helpers.DefaultHandler) throws java.io.IOException, org.xml.sax.SAXException;
    method public void parse(java.io.File, org.xml.sax.HandlerBase) throws java.io.IOException, org.xml.sax.SAXException;
    method public void parse(java.io.File, org.xml.sax.helpers.DefaultHandler) throws java.io.IOException, org.xml.sax.SAXException;
    method public void parse(org.xml.sax.InputSource, org.xml.sax.HandlerBase) throws java.io.IOException, org.xml.sax.SAXException;
    method public void parse(org.xml.sax.InputSource, org.xml.sax.helpers.DefaultHandler) throws java.io.IOException, org.xml.sax.SAXException;
    method public void reset();
    method public abstract void setProperty(String, Object) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
  }

  public abstract class SAXParserFactory {
    ctor protected SAXParserFactory();
    method public abstract boolean getFeature(String) throws javax.xml.parsers.ParserConfigurationException, org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public javax.xml.validation.Schema getSchema();
    method public boolean isNamespaceAware();
    method public boolean isValidating();
    method public boolean isXIncludeAware();
    method public static javax.xml.parsers.SAXParserFactory newInstance();
    method public static javax.xml.parsers.SAXParserFactory newInstance(String, ClassLoader);
    method public abstract javax.xml.parsers.SAXParser newSAXParser() throws javax.xml.parsers.ParserConfigurationException, org.xml.sax.SAXException;
    method public abstract void setFeature(String, boolean) throws javax.xml.parsers.ParserConfigurationException, org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public void setNamespaceAware(boolean);
    method public void setSchema(javax.xml.validation.Schema);
    method public void setValidating(boolean);
    method public void setXIncludeAware(boolean);
  }

}

package javax.xml.transform {

  public interface ErrorListener {
    method public void error(javax.xml.transform.TransformerException) throws javax.xml.transform.TransformerException;
    method public void fatalError(javax.xml.transform.TransformerException) throws javax.xml.transform.TransformerException;
    method public void warning(javax.xml.transform.TransformerException) throws javax.xml.transform.TransformerException;
  }

  public class OutputKeys {
    field public static final String CDATA_SECTION_ELEMENTS = "cdata-section-elements";
    field public static final String DOCTYPE_PUBLIC = "doctype-public";
    field public static final String DOCTYPE_SYSTEM = "doctype-system";
    field public static final String ENCODING = "encoding";
    field public static final String INDENT = "indent";
    field public static final String MEDIA_TYPE = "media-type";
    field public static final String METHOD = "method";
    field public static final String OMIT_XML_DECLARATION = "omit-xml-declaration";
    field public static final String STANDALONE = "standalone";
    field public static final String VERSION = "version";
  }

  public interface Result {
    method public String getSystemId();
    method public void setSystemId(String);
    field public static final String PI_DISABLE_OUTPUT_ESCAPING = "javax.xml.transform.disable-output-escaping";
    field public static final String PI_ENABLE_OUTPUT_ESCAPING = "javax.xml.transform.enable-output-escaping";
  }

  public interface Source {
    method public String getSystemId();
    method public void setSystemId(String);
  }

  public interface SourceLocator {
    method public int getColumnNumber();
    method public int getLineNumber();
    method public String getPublicId();
    method public String getSystemId();
  }

  public interface Templates {
    method public java.util.Properties getOutputProperties();
    method public javax.xml.transform.Transformer newTransformer() throws javax.xml.transform.TransformerConfigurationException;
  }

  public abstract class Transformer {
    ctor protected Transformer();
    method public abstract void clearParameters();
    method public abstract javax.xml.transform.ErrorListener getErrorListener();
    method public abstract java.util.Properties getOutputProperties();
    method public abstract String getOutputProperty(String) throws java.lang.IllegalArgumentException;
    method public abstract Object getParameter(String);
    method public abstract javax.xml.transform.URIResolver getURIResolver();
    method public void reset();
    method public abstract void setErrorListener(javax.xml.transform.ErrorListener) throws java.lang.IllegalArgumentException;
    method public abstract void setOutputProperties(java.util.Properties);
    method public abstract void setOutputProperty(String, String) throws java.lang.IllegalArgumentException;
    method public abstract void setParameter(String, Object);
    method public abstract void setURIResolver(javax.xml.transform.URIResolver);
    method public abstract void transform(javax.xml.transform.Source, javax.xml.transform.Result) throws javax.xml.transform.TransformerException;
  }

  public class TransformerConfigurationException extends javax.xml.transform.TransformerException {
    ctor public TransformerConfigurationException();
    ctor public TransformerConfigurationException(String);
    ctor public TransformerConfigurationException(Throwable);
    ctor public TransformerConfigurationException(String, Throwable);
    ctor public TransformerConfigurationException(String, javax.xml.transform.SourceLocator);
    ctor public TransformerConfigurationException(String, javax.xml.transform.SourceLocator, Throwable);
  }

  public class TransformerException extends java.lang.Exception {
    ctor public TransformerException(String);
    ctor public TransformerException(Throwable);
    ctor public TransformerException(String, Throwable);
    ctor public TransformerException(String, javax.xml.transform.SourceLocator);
    ctor public TransformerException(String, javax.xml.transform.SourceLocator, Throwable);
    method public Throwable getException();
    method public String getLocationAsString();
    method public javax.xml.transform.SourceLocator getLocator();
    method public String getMessageAndLocation();
    method public void setLocator(javax.xml.transform.SourceLocator);
  }

  public abstract class TransformerFactory {
    ctor protected TransformerFactory();
    method public abstract javax.xml.transform.Source getAssociatedStylesheet(javax.xml.transform.Source, String, String, String) throws javax.xml.transform.TransformerConfigurationException;
    method public abstract Object getAttribute(String);
    method public abstract javax.xml.transform.ErrorListener getErrorListener();
    method public abstract boolean getFeature(String);
    method public abstract javax.xml.transform.URIResolver getURIResolver();
    method public static javax.xml.transform.TransformerFactory newInstance() throws javax.xml.transform.TransformerFactoryConfigurationError;
    method public static javax.xml.transform.TransformerFactory newInstance(String, ClassLoader) throws javax.xml.transform.TransformerFactoryConfigurationError;
    method public abstract javax.xml.transform.Templates newTemplates(javax.xml.transform.Source) throws javax.xml.transform.TransformerConfigurationException;
    method public abstract javax.xml.transform.Transformer newTransformer(javax.xml.transform.Source) throws javax.xml.transform.TransformerConfigurationException;
    method public abstract javax.xml.transform.Transformer newTransformer() throws javax.xml.transform.TransformerConfigurationException;
    method public abstract void setAttribute(String, Object);
    method public abstract void setErrorListener(javax.xml.transform.ErrorListener);
    method public abstract void setFeature(String, boolean) throws javax.xml.transform.TransformerConfigurationException;
    method public abstract void setURIResolver(javax.xml.transform.URIResolver);
  }

  public class TransformerFactoryConfigurationError extends java.lang.Error {
    ctor public TransformerFactoryConfigurationError();
    ctor public TransformerFactoryConfigurationError(String);
    ctor public TransformerFactoryConfigurationError(Exception);
    ctor public TransformerFactoryConfigurationError(Exception, String);
    method public Exception getException();
  }

  public interface URIResolver {
    method public javax.xml.transform.Source resolve(String, String) throws javax.xml.transform.TransformerException;
  }

}

package javax.xml.transform.dom {

  public interface DOMLocator extends javax.xml.transform.SourceLocator {
    method public org.w3c.dom.Node getOriginatingNode();
  }

  public class DOMResult implements javax.xml.transform.Result {
    ctor public DOMResult();
    ctor public DOMResult(org.w3c.dom.Node);
    ctor public DOMResult(org.w3c.dom.Node, String);
    ctor public DOMResult(org.w3c.dom.Node, org.w3c.dom.Node);
    ctor public DOMResult(org.w3c.dom.Node, org.w3c.dom.Node, String);
    method public org.w3c.dom.Node getNextSibling();
    method public org.w3c.dom.Node getNode();
    method public String getSystemId();
    method public void setNextSibling(org.w3c.dom.Node);
    method public void setNode(org.w3c.dom.Node);
    method public void setSystemId(String);
    field public static final String FEATURE = "http://javax.xml.transform.dom.DOMResult/feature";
  }

  public class DOMSource implements javax.xml.transform.Source {
    ctor public DOMSource();
    ctor public DOMSource(org.w3c.dom.Node);
    ctor public DOMSource(org.w3c.dom.Node, String);
    method public org.w3c.dom.Node getNode();
    method public String getSystemId();
    method public void setNode(org.w3c.dom.Node);
    method public void setSystemId(String);
    field public static final String FEATURE = "http://javax.xml.transform.dom.DOMSource/feature";
  }

}

package javax.xml.transform.sax {

  public class SAXResult implements javax.xml.transform.Result {
    ctor public SAXResult();
    ctor public SAXResult(org.xml.sax.ContentHandler);
    method public org.xml.sax.ContentHandler getHandler();
    method public org.xml.sax.ext.LexicalHandler getLexicalHandler();
    method public String getSystemId();
    method public void setHandler(org.xml.sax.ContentHandler);
    method public void setLexicalHandler(org.xml.sax.ext.LexicalHandler);
    method public void setSystemId(String);
    field public static final String FEATURE = "http://javax.xml.transform.sax.SAXResult/feature";
  }

  public class SAXSource implements javax.xml.transform.Source {
    ctor public SAXSource();
    ctor public SAXSource(org.xml.sax.XMLReader, org.xml.sax.InputSource);
    ctor public SAXSource(org.xml.sax.InputSource);
    method public org.xml.sax.InputSource getInputSource();
    method public String getSystemId();
    method public org.xml.sax.XMLReader getXMLReader();
    method public void setInputSource(org.xml.sax.InputSource);
    method public void setSystemId(String);
    method public void setXMLReader(org.xml.sax.XMLReader);
    method public static org.xml.sax.InputSource sourceToInputSource(javax.xml.transform.Source);
    field public static final String FEATURE = "http://javax.xml.transform.sax.SAXSource/feature";
  }

  public abstract class SAXTransformerFactory extends javax.xml.transform.TransformerFactory {
    ctor protected SAXTransformerFactory();
    method public abstract javax.xml.transform.sax.TemplatesHandler newTemplatesHandler() throws javax.xml.transform.TransformerConfigurationException;
    method public abstract javax.xml.transform.sax.TransformerHandler newTransformerHandler(javax.xml.transform.Source) throws javax.xml.transform.TransformerConfigurationException;
    method public abstract javax.xml.transform.sax.TransformerHandler newTransformerHandler(javax.xml.transform.Templates) throws javax.xml.transform.TransformerConfigurationException;
    method public abstract javax.xml.transform.sax.TransformerHandler newTransformerHandler() throws javax.xml.transform.TransformerConfigurationException;
    method public abstract org.xml.sax.XMLFilter newXMLFilter(javax.xml.transform.Source) throws javax.xml.transform.TransformerConfigurationException;
    method public abstract org.xml.sax.XMLFilter newXMLFilter(javax.xml.transform.Templates) throws javax.xml.transform.TransformerConfigurationException;
    field public static final String FEATURE = "http://javax.xml.transform.sax.SAXTransformerFactory/feature";
    field public static final String FEATURE_XMLFILTER = "http://javax.xml.transform.sax.SAXTransformerFactory/feature/xmlfilter";
  }

  public interface TemplatesHandler extends org.xml.sax.ContentHandler {
    method public String getSystemId();
    method public javax.xml.transform.Templates getTemplates();
    method public void setSystemId(String);
  }

  public interface TransformerHandler extends org.xml.sax.ContentHandler org.xml.sax.DTDHandler org.xml.sax.ext.LexicalHandler {
    method public String getSystemId();
    method public javax.xml.transform.Transformer getTransformer();
    method public void setResult(javax.xml.transform.Result) throws java.lang.IllegalArgumentException;
    method public void setSystemId(String);
  }

}

package javax.xml.transform.stream {

  public class StreamResult implements javax.xml.transform.Result {
    ctor public StreamResult();
    ctor public StreamResult(java.io.OutputStream);
    ctor public StreamResult(java.io.Writer);
    ctor public StreamResult(String);
    ctor public StreamResult(java.io.File);
    method public java.io.OutputStream getOutputStream();
    method public String getSystemId();
    method public java.io.Writer getWriter();
    method public void setOutputStream(java.io.OutputStream);
    method public void setSystemId(String);
    method public void setSystemId(java.io.File);
    method public void setWriter(java.io.Writer);
    field public static final String FEATURE = "http://javax.xml.transform.stream.StreamResult/feature";
  }

  public class StreamSource implements javax.xml.transform.Source {
    ctor public StreamSource();
    ctor public StreamSource(java.io.InputStream);
    ctor public StreamSource(java.io.InputStream, String);
    ctor public StreamSource(java.io.Reader);
    ctor public StreamSource(java.io.Reader, String);
    ctor public StreamSource(String);
    ctor public StreamSource(java.io.File);
    method public java.io.InputStream getInputStream();
    method public String getPublicId();
    method public java.io.Reader getReader();
    method public String getSystemId();
    method public void setInputStream(java.io.InputStream);
    method public void setPublicId(String);
    method public void setReader(java.io.Reader);
    method public void setSystemId(String);
    method public void setSystemId(java.io.File);
    field public static final String FEATURE = "http://javax.xml.transform.stream.StreamSource/feature";
  }

}

package javax.xml.validation {

  public abstract class Schema {
    ctor protected Schema();
    method public abstract javax.xml.validation.Validator newValidator();
    method public abstract javax.xml.validation.ValidatorHandler newValidatorHandler();
  }

  public abstract class SchemaFactory {
    ctor protected SchemaFactory();
    method public abstract org.xml.sax.ErrorHandler getErrorHandler();
    method public boolean getFeature(String) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public Object getProperty(String) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public abstract org.w3c.dom.ls.LSResourceResolver getResourceResolver();
    method public abstract boolean isSchemaLanguageSupported(String);
    method public static javax.xml.validation.SchemaFactory newInstance(String);
    method public static javax.xml.validation.SchemaFactory newInstance(String, String, ClassLoader);
    method public javax.xml.validation.Schema newSchema(javax.xml.transform.Source) throws org.xml.sax.SAXException;
    method public javax.xml.validation.Schema newSchema(java.io.File) throws org.xml.sax.SAXException;
    method public javax.xml.validation.Schema newSchema(java.net.URL) throws org.xml.sax.SAXException;
    method public abstract javax.xml.validation.Schema newSchema(javax.xml.transform.Source[]) throws org.xml.sax.SAXException;
    method public abstract javax.xml.validation.Schema newSchema() throws org.xml.sax.SAXException;
    method public abstract void setErrorHandler(org.xml.sax.ErrorHandler);
    method public void setFeature(String, boolean) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public void setProperty(String, Object) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public abstract void setResourceResolver(org.w3c.dom.ls.LSResourceResolver);
  }

  public abstract class SchemaFactoryLoader {
    ctor protected SchemaFactoryLoader();
    method public abstract javax.xml.validation.SchemaFactory newFactory(String);
  }

  public abstract class TypeInfoProvider {
    ctor protected TypeInfoProvider();
    method public abstract org.w3c.dom.TypeInfo getAttributeTypeInfo(int);
    method public abstract org.w3c.dom.TypeInfo getElementTypeInfo();
    method public abstract boolean isIdAttribute(int);
    method public abstract boolean isSpecified(int);
  }

  public abstract class Validator {
    ctor protected Validator();
    method public abstract org.xml.sax.ErrorHandler getErrorHandler();
    method public boolean getFeature(String) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public Object getProperty(String) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public abstract org.w3c.dom.ls.LSResourceResolver getResourceResolver();
    method public abstract void reset();
    method public abstract void setErrorHandler(org.xml.sax.ErrorHandler);
    method public void setFeature(String, boolean) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public void setProperty(String, Object) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public abstract void setResourceResolver(org.w3c.dom.ls.LSResourceResolver);
    method public void validate(javax.xml.transform.Source) throws java.io.IOException, org.xml.sax.SAXException;
    method public abstract void validate(javax.xml.transform.Source, javax.xml.transform.Result) throws java.io.IOException, org.xml.sax.SAXException;
  }

  public abstract class ValidatorHandler implements org.xml.sax.ContentHandler {
    ctor protected ValidatorHandler();
    method public abstract org.xml.sax.ContentHandler getContentHandler();
    method public abstract org.xml.sax.ErrorHandler getErrorHandler();
    method public boolean getFeature(String) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public Object getProperty(String) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public abstract org.w3c.dom.ls.LSResourceResolver getResourceResolver();
    method public abstract javax.xml.validation.TypeInfoProvider getTypeInfoProvider();
    method public abstract void setContentHandler(org.xml.sax.ContentHandler);
    method public abstract void setErrorHandler(org.xml.sax.ErrorHandler);
    method public void setFeature(String, boolean) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public void setProperty(String, Object) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public abstract void setResourceResolver(org.w3c.dom.ls.LSResourceResolver);
  }

}

package javax.xml.xpath {

  public interface XPath {
    method public javax.xml.xpath.XPathExpression compile(String) throws javax.xml.xpath.XPathExpressionException;
    method public Object evaluate(String, Object, javax.xml.namespace.QName) throws javax.xml.xpath.XPathExpressionException;
    method public String evaluate(String, Object) throws javax.xml.xpath.XPathExpressionException;
    method public Object evaluate(String, org.xml.sax.InputSource, javax.xml.namespace.QName) throws javax.xml.xpath.XPathExpressionException;
    method public String evaluate(String, org.xml.sax.InputSource) throws javax.xml.xpath.XPathExpressionException;
    method public javax.xml.namespace.NamespaceContext getNamespaceContext();
    method public javax.xml.xpath.XPathFunctionResolver getXPathFunctionResolver();
    method public javax.xml.xpath.XPathVariableResolver getXPathVariableResolver();
    method public void reset();
    method public void setNamespaceContext(javax.xml.namespace.NamespaceContext);
    method public void setXPathFunctionResolver(javax.xml.xpath.XPathFunctionResolver);
    method public void setXPathVariableResolver(javax.xml.xpath.XPathVariableResolver);
  }

  public class XPathConstants {
    field public static final javax.xml.namespace.QName BOOLEAN;
    field public static final String DOM_OBJECT_MODEL = "http://java.sun.com/jaxp/xpath/dom";
    field public static final javax.xml.namespace.QName NODE;
    field public static final javax.xml.namespace.QName NODESET;
    field public static final javax.xml.namespace.QName NUMBER;
    field public static final javax.xml.namespace.QName STRING;
  }

  public class XPathException extends java.lang.Exception {
    ctor public XPathException(String);
    ctor public XPathException(Throwable);
  }

  public interface XPathExpression {
    method public Object evaluate(Object, javax.xml.namespace.QName) throws javax.xml.xpath.XPathExpressionException;
    method public String evaluate(Object) throws javax.xml.xpath.XPathExpressionException;
    method public Object evaluate(org.xml.sax.InputSource, javax.xml.namespace.QName) throws javax.xml.xpath.XPathExpressionException;
    method public String evaluate(org.xml.sax.InputSource) throws javax.xml.xpath.XPathExpressionException;
  }

  public class XPathExpressionException extends javax.xml.xpath.XPathException {
    ctor public XPathExpressionException(String);
    ctor public XPathExpressionException(Throwable);
  }

  public abstract class XPathFactory {
    ctor protected XPathFactory();
    method public abstract boolean getFeature(String) throws javax.xml.xpath.XPathFactoryConfigurationException;
    method public abstract boolean isObjectModelSupported(String);
    method public static final javax.xml.xpath.XPathFactory newInstance();
    method public static final javax.xml.xpath.XPathFactory newInstance(String) throws javax.xml.xpath.XPathFactoryConfigurationException;
    method public static javax.xml.xpath.XPathFactory newInstance(String, String, ClassLoader) throws javax.xml.xpath.XPathFactoryConfigurationException;
    method public abstract javax.xml.xpath.XPath newXPath();
    method public abstract void setFeature(String, boolean) throws javax.xml.xpath.XPathFactoryConfigurationException;
    method public abstract void setXPathFunctionResolver(javax.xml.xpath.XPathFunctionResolver);
    method public abstract void setXPathVariableResolver(javax.xml.xpath.XPathVariableResolver);
    field public static final String DEFAULT_OBJECT_MODEL_URI = "http://java.sun.com/jaxp/xpath/dom";
    field public static final String DEFAULT_PROPERTY_NAME = "javax.xml.xpath.XPathFactory";
  }

  public class XPathFactoryConfigurationException extends javax.xml.xpath.XPathException {
    ctor public XPathFactoryConfigurationException(String);
    ctor public XPathFactoryConfigurationException(Throwable);
  }

  public interface XPathFunction {
    method public Object evaluate(java.util.List) throws javax.xml.xpath.XPathFunctionException;
  }

  public class XPathFunctionException extends javax.xml.xpath.XPathExpressionException {
    ctor public XPathFunctionException(String);
    ctor public XPathFunctionException(Throwable);
  }

  public interface XPathFunctionResolver {
    method public javax.xml.xpath.XPathFunction resolveFunction(javax.xml.namespace.QName, int);
  }

  public interface XPathVariableResolver {
    method public Object resolveVariable(javax.xml.namespace.QName);
  }

}

package org.json {

  public class JSONArray {
    ctor public JSONArray();
    ctor public JSONArray(java.util.Collection);
    ctor public JSONArray(org.json.JSONTokener) throws org.json.JSONException;
    ctor public JSONArray(String) throws org.json.JSONException;
    ctor public JSONArray(Object) throws org.json.JSONException;
    method public Object get(int) throws org.json.JSONException;
    method public boolean getBoolean(int) throws org.json.JSONException;
    method public double getDouble(int) throws org.json.JSONException;
    method public int getInt(int) throws org.json.JSONException;
    method public org.json.JSONArray getJSONArray(int) throws org.json.JSONException;
    method public org.json.JSONObject getJSONObject(int) throws org.json.JSONException;
    method public long getLong(int) throws org.json.JSONException;
    method public String getString(int) throws org.json.JSONException;
    method public boolean isNull(int);
    method public String join(String) throws org.json.JSONException;
    method public int length();
    method public Object opt(int);
    method public boolean optBoolean(int);
    method public boolean optBoolean(int, boolean);
    method public double optDouble(int);
    method public double optDouble(int, double);
    method public int optInt(int);
    method public int optInt(int, int);
    method public org.json.JSONArray optJSONArray(int);
    method public org.json.JSONObject optJSONObject(int);
    method public long optLong(int);
    method public long optLong(int, long);
    method public String optString(int);
    method public String optString(int, String);
    method public org.json.JSONArray put(boolean);
    method public org.json.JSONArray put(double) throws org.json.JSONException;
    method public org.json.JSONArray put(int);
    method public org.json.JSONArray put(long);
    method public org.json.JSONArray put(Object);
    method public org.json.JSONArray put(int, boolean) throws org.json.JSONException;
    method public org.json.JSONArray put(int, double) throws org.json.JSONException;
    method public org.json.JSONArray put(int, int) throws org.json.JSONException;
    method public org.json.JSONArray put(int, long) throws org.json.JSONException;
    method public org.json.JSONArray put(int, Object) throws org.json.JSONException;
    method public Object remove(int);
    method public org.json.JSONObject toJSONObject(org.json.JSONArray) throws org.json.JSONException;
    method public String toString(int) throws org.json.JSONException;
  }

  public class JSONException extends java.lang.Exception {
    ctor public JSONException(String);
    ctor public JSONException(String, Throwable);
    ctor public JSONException(Throwable);
  }

  public class JSONObject {
    ctor public JSONObject();
    ctor public JSONObject(@NonNull java.util.Map);
    ctor public JSONObject(@NonNull org.json.JSONTokener) throws org.json.JSONException;
    ctor public JSONObject(@NonNull String) throws org.json.JSONException;
    ctor public JSONObject(@NonNull org.json.JSONObject, @NonNull String[]) throws org.json.JSONException;
    method @NonNull public org.json.JSONObject accumulate(@NonNull String, @Nullable Object) throws org.json.JSONException;
    method @NonNull public org.json.JSONObject append(@NonNull String, @Nullable Object) throws org.json.JSONException;
    method @NonNull public Object get(@NonNull String) throws org.json.JSONException;
    method public boolean getBoolean(@NonNull String) throws org.json.JSONException;
    method public double getDouble(@NonNull String) throws org.json.JSONException;
    method public int getInt(@NonNull String) throws org.json.JSONException;
    method @NonNull public org.json.JSONArray getJSONArray(@NonNull String) throws org.json.JSONException;
    method @NonNull public org.json.JSONObject getJSONObject(@NonNull String) throws org.json.JSONException;
    method public long getLong(@NonNull String) throws org.json.JSONException;
    method @NonNull public String getString(@NonNull String) throws org.json.JSONException;
    method public boolean has(@Nullable String);
    method public boolean isNull(@Nullable String);
    method @NonNull public java.util.Iterator<java.lang.String> keys();
    method public int length();
    method @Nullable public org.json.JSONArray names();
    method @NonNull public static String numberToString(@NonNull Number) throws org.json.JSONException;
    method @Nullable public Object opt(@Nullable String);
    method public boolean optBoolean(@Nullable String);
    method public boolean optBoolean(@Nullable String, boolean);
    method public double optDouble(@Nullable String);
    method public double optDouble(@Nullable String, double);
    method public int optInt(@Nullable String);
    method public int optInt(@Nullable String, int);
    method @Nullable public org.json.JSONArray optJSONArray(@Nullable String);
    method @Nullable public org.json.JSONObject optJSONObject(@Nullable String);
    method public long optLong(@Nullable String);
    method public long optLong(@Nullable String, long);
    method @NonNull public String optString(@Nullable String);
    method @NonNull public String optString(@Nullable String, @NonNull String);
    method @NonNull public org.json.JSONObject put(@NonNull String, boolean) throws org.json.JSONException;
    method @NonNull public org.json.JSONObject put(@NonNull String, double) throws org.json.JSONException;
    method @NonNull public org.json.JSONObject put(@NonNull String, int) throws org.json.JSONException;
    method @NonNull public org.json.JSONObject put(@NonNull String, long) throws org.json.JSONException;
    method @NonNull public org.json.JSONObject put(@NonNull String, @Nullable Object) throws org.json.JSONException;
    method @NonNull public org.json.JSONObject putOpt(@Nullable String, @Nullable Object) throws org.json.JSONException;
    method @NonNull public static String quote(@Nullable String);
    method @Nullable public Object remove(@Nullable String);
    method @Nullable public org.json.JSONArray toJSONArray(@Nullable org.json.JSONArray) throws org.json.JSONException;
    method @NonNull public String toString(int) throws org.json.JSONException;
    method @Nullable public static Object wrap(@Nullable Object);
    field @NonNull public static final Object NULL;
  }

  public class JSONStringer {
    ctor public JSONStringer();
    method public org.json.JSONStringer array() throws org.json.JSONException;
    method public org.json.JSONStringer endArray() throws org.json.JSONException;
    method public org.json.JSONStringer endObject() throws org.json.JSONException;
    method public org.json.JSONStringer key(String) throws org.json.JSONException;
    method public org.json.JSONStringer object() throws org.json.JSONException;
    method public org.json.JSONStringer value(Object) throws org.json.JSONException;
    method public org.json.JSONStringer value(boolean) throws org.json.JSONException;
    method public org.json.JSONStringer value(double) throws org.json.JSONException;
    method public org.json.JSONStringer value(long) throws org.json.JSONException;
  }

  public class JSONTokener {
    ctor public JSONTokener(String);
    method public void back();
    method public static int dehexchar(char);
    method public boolean more();
    method public char next();
    method public char next(char) throws org.json.JSONException;
    method public String next(int) throws org.json.JSONException;
    method public char nextClean() throws org.json.JSONException;
    method public String nextString(char) throws org.json.JSONException;
    method public String nextTo(String);
    method public String nextTo(char);
    method public Object nextValue() throws org.json.JSONException;
    method public void skipPast(String);
    method public char skipTo(char);
    method public org.json.JSONException syntaxError(String);
  }

}

package org.w3c.dom {

  public interface Attr extends org.w3c.dom.Node {
    method public String getName();
    method public org.w3c.dom.Element getOwnerElement();
    method public org.w3c.dom.TypeInfo getSchemaTypeInfo();
    method public boolean getSpecified();
    method public String getValue();
    method public boolean isId();
    method public void setValue(String) throws org.w3c.dom.DOMException;
  }

  public interface CDATASection extends org.w3c.dom.Text {
  }

  public interface CharacterData extends org.w3c.dom.Node {
    method public void appendData(String) throws org.w3c.dom.DOMException;
    method public void deleteData(int, int) throws org.w3c.dom.DOMException;
    method public String getData() throws org.w3c.dom.DOMException;
    method public int getLength();
    method public void insertData(int, String) throws org.w3c.dom.DOMException;
    method public void replaceData(int, int, String) throws org.w3c.dom.DOMException;
    method public void setData(String) throws org.w3c.dom.DOMException;
    method public String substringData(int, int) throws org.w3c.dom.DOMException;
  }

  public interface Comment extends org.w3c.dom.CharacterData {
  }

  public interface DOMConfiguration {
    method public boolean canSetParameter(String, Object);
    method public Object getParameter(String) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.DOMStringList getParameterNames();
    method public void setParameter(String, Object) throws org.w3c.dom.DOMException;
  }

  public interface DOMError {
    method public org.w3c.dom.DOMLocator getLocation();
    method public String getMessage();
    method public Object getRelatedData();
    method public Object getRelatedException();
    method public short getSeverity();
    method public String getType();
    field public static final short SEVERITY_ERROR = 2; // 0x2
    field public static final short SEVERITY_FATAL_ERROR = 3; // 0x3
    field public static final short SEVERITY_WARNING = 1; // 0x1
  }

  public interface DOMErrorHandler {
    method public boolean handleError(org.w3c.dom.DOMError);
  }

  public class DOMException extends java.lang.RuntimeException {
    ctor public DOMException(short, String);
    field public static final short DOMSTRING_SIZE_ERR = 2; // 0x2
    field public static final short HIERARCHY_REQUEST_ERR = 3; // 0x3
    field public static final short INDEX_SIZE_ERR = 1; // 0x1
    field public static final short INUSE_ATTRIBUTE_ERR = 10; // 0xa
    field public static final short INVALID_ACCESS_ERR = 15; // 0xf
    field public static final short INVALID_CHARACTER_ERR = 5; // 0x5
    field public static final short INVALID_MODIFICATION_ERR = 13; // 0xd
    field public static final short INVALID_STATE_ERR = 11; // 0xb
    field public static final short NAMESPACE_ERR = 14; // 0xe
    field public static final short NOT_FOUND_ERR = 8; // 0x8
    field public static final short NOT_SUPPORTED_ERR = 9; // 0x9
    field public static final short NO_DATA_ALLOWED_ERR = 6; // 0x6
    field public static final short NO_MODIFICATION_ALLOWED_ERR = 7; // 0x7
    field public static final short SYNTAX_ERR = 12; // 0xc
    field public static final short TYPE_MISMATCH_ERR = 17; // 0x11
    field public static final short VALIDATION_ERR = 16; // 0x10
    field public static final short WRONG_DOCUMENT_ERR = 4; // 0x4
    field public short code;
  }

  public interface DOMImplementation {
    method public org.w3c.dom.Document createDocument(String, String, org.w3c.dom.DocumentType) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.DocumentType createDocumentType(String, String, String) throws org.w3c.dom.DOMException;
    method public Object getFeature(String, String);
    method public boolean hasFeature(String, String);
  }

  public interface DOMImplementationList {
    method public int getLength();
    method public org.w3c.dom.DOMImplementation item(int);
  }

  public interface DOMImplementationSource {
    method public org.w3c.dom.DOMImplementation getDOMImplementation(String);
    method public org.w3c.dom.DOMImplementationList getDOMImplementationList(String);
  }

  public interface DOMLocator {
    method public int getByteOffset();
    method public int getColumnNumber();
    method public int getLineNumber();
    method public org.w3c.dom.Node getRelatedNode();
    method public String getUri();
    method public int getUtf16Offset();
  }

  public interface DOMStringList {
    method public boolean contains(String);
    method public int getLength();
    method public String item(int);
  }

  public interface Document extends org.w3c.dom.Node {
    method public org.w3c.dom.Node adoptNode(org.w3c.dom.Node) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.Attr createAttribute(String) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.Attr createAttributeNS(String, String) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.CDATASection createCDATASection(String) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.Comment createComment(String);
    method public org.w3c.dom.DocumentFragment createDocumentFragment();
    method public org.w3c.dom.Element createElement(String) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.Element createElementNS(String, String) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.EntityReference createEntityReference(String) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.ProcessingInstruction createProcessingInstruction(String, String) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.Text createTextNode(String);
    method public org.w3c.dom.DocumentType getDoctype();
    method public org.w3c.dom.Element getDocumentElement();
    method public String getDocumentURI();
    method public org.w3c.dom.DOMConfiguration getDomConfig();
    method public org.w3c.dom.Element getElementById(String);
    method public org.w3c.dom.NodeList getElementsByTagName(String);
    method public org.w3c.dom.NodeList getElementsByTagNameNS(String, String);
    method public org.w3c.dom.DOMImplementation getImplementation();
    method public String getInputEncoding();
    method public boolean getStrictErrorChecking();
    method public String getXmlEncoding();
    method public boolean getXmlStandalone();
    method public String getXmlVersion();
    method public org.w3c.dom.Node importNode(org.w3c.dom.Node, boolean) throws org.w3c.dom.DOMException;
    method public void normalizeDocument();
    method public org.w3c.dom.Node renameNode(org.w3c.dom.Node, String, String) throws org.w3c.dom.DOMException;
    method public void setDocumentURI(String);
    method public void setStrictErrorChecking(boolean);
    method public void setXmlStandalone(boolean) throws org.w3c.dom.DOMException;
    method public void setXmlVersion(String) throws org.w3c.dom.DOMException;
  }

  public interface DocumentFragment extends org.w3c.dom.Node {
  }

  public interface DocumentType extends org.w3c.dom.Node {
    method public org.w3c.dom.NamedNodeMap getEntities();
    method public String getInternalSubset();
    method public String getName();
    method public org.w3c.dom.NamedNodeMap getNotations();
    method public String getPublicId();
    method public String getSystemId();
  }

  public interface Element extends org.w3c.dom.Node {
    method public String getAttribute(String);
    method public String getAttributeNS(String, String) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.Attr getAttributeNode(String);
    method public org.w3c.dom.Attr getAttributeNodeNS(String, String) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.NodeList getElementsByTagName(String);
    method public org.w3c.dom.NodeList getElementsByTagNameNS(String, String) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.TypeInfo getSchemaTypeInfo();
    method public String getTagName();
    method public boolean hasAttribute(String);
    method public boolean hasAttributeNS(String, String) throws org.w3c.dom.DOMException;
    method public void removeAttribute(String) throws org.w3c.dom.DOMException;
    method public void removeAttributeNS(String, String) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.Attr removeAttributeNode(org.w3c.dom.Attr) throws org.w3c.dom.DOMException;
    method public void setAttribute(String, String) throws org.w3c.dom.DOMException;
    method public void setAttributeNS(String, String, String) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.Attr setAttributeNode(org.w3c.dom.Attr) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.Attr setAttributeNodeNS(org.w3c.dom.Attr) throws org.w3c.dom.DOMException;
    method public void setIdAttribute(String, boolean) throws org.w3c.dom.DOMException;
    method public void setIdAttributeNS(String, String, boolean) throws org.w3c.dom.DOMException;
    method public void setIdAttributeNode(org.w3c.dom.Attr, boolean) throws org.w3c.dom.DOMException;
  }

  public interface Entity extends org.w3c.dom.Node {
    method public String getInputEncoding();
    method public String getNotationName();
    method public String getPublicId();
    method public String getSystemId();
    method public String getXmlEncoding();
    method public String getXmlVersion();
  }

  public interface EntityReference extends org.w3c.dom.Node {
  }

  public interface NameList {
    method public boolean contains(String);
    method public boolean containsNS(String, String);
    method public int getLength();
    method public String getName(int);
    method public String getNamespaceURI(int);
  }

  public interface NamedNodeMap {
    method public int getLength();
    method public org.w3c.dom.Node getNamedItem(String);
    method public org.w3c.dom.Node getNamedItemNS(String, String) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.Node item(int);
    method public org.w3c.dom.Node removeNamedItem(String) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.Node removeNamedItemNS(String, String) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.Node setNamedItem(org.w3c.dom.Node) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.Node setNamedItemNS(org.w3c.dom.Node) throws org.w3c.dom.DOMException;
  }

  public interface Node {
    method public org.w3c.dom.Node appendChild(org.w3c.dom.Node) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.Node cloneNode(boolean);
    method public short compareDocumentPosition(org.w3c.dom.Node) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.NamedNodeMap getAttributes();
    method public String getBaseURI();
    method public org.w3c.dom.NodeList getChildNodes();
    method public Object getFeature(String, String);
    method public org.w3c.dom.Node getFirstChild();
    method public org.w3c.dom.Node getLastChild();
    method public String getLocalName();
    method public String getNamespaceURI();
    method public org.w3c.dom.Node getNextSibling();
    method public String getNodeName();
    method public short getNodeType();
    method public String getNodeValue() throws org.w3c.dom.DOMException;
    method public org.w3c.dom.Document getOwnerDocument();
    method public org.w3c.dom.Node getParentNode();
    method public String getPrefix();
    method public org.w3c.dom.Node getPreviousSibling();
    method public String getTextContent() throws org.w3c.dom.DOMException;
    method public Object getUserData(String);
    method public boolean hasAttributes();
    method public boolean hasChildNodes();
    method public org.w3c.dom.Node insertBefore(org.w3c.dom.Node, org.w3c.dom.Node) throws org.w3c.dom.DOMException;
    method public boolean isDefaultNamespace(String);
    method public boolean isEqualNode(org.w3c.dom.Node);
    method public boolean isSameNode(org.w3c.dom.Node);
    method public boolean isSupported(String, String);
    method public String lookupNamespaceURI(String);
    method public String lookupPrefix(String);
    method public void normalize();
    method public org.w3c.dom.Node removeChild(org.w3c.dom.Node) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.Node replaceChild(org.w3c.dom.Node, org.w3c.dom.Node) throws org.w3c.dom.DOMException;
    method public void setNodeValue(String) throws org.w3c.dom.DOMException;
    method public void setPrefix(String) throws org.w3c.dom.DOMException;
    method public void setTextContent(String) throws org.w3c.dom.DOMException;
    method public Object setUserData(String, Object, org.w3c.dom.UserDataHandler);
    field public static final short ATTRIBUTE_NODE = 2; // 0x2
    field public static final short CDATA_SECTION_NODE = 4; // 0x4
    field public static final short COMMENT_NODE = 8; // 0x8
    field public static final short DOCUMENT_FRAGMENT_NODE = 11; // 0xb
    field public static final short DOCUMENT_NODE = 9; // 0x9
    field public static final short DOCUMENT_POSITION_CONTAINED_BY = 16; // 0x10
    field public static final short DOCUMENT_POSITION_CONTAINS = 8; // 0x8
    field public static final short DOCUMENT_POSITION_DISCONNECTED = 1; // 0x1
    field public static final short DOCUMENT_POSITION_FOLLOWING = 4; // 0x4
    field public static final short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32; // 0x20
    field public static final short DOCUMENT_POSITION_PRECEDING = 2; // 0x2
    field public static final short DOCUMENT_TYPE_NODE = 10; // 0xa
    field public static final short ELEMENT_NODE = 1; // 0x1
    field public static final short ENTITY_NODE = 6; // 0x6
    field public static final short ENTITY_REFERENCE_NODE = 5; // 0x5
    field public static final short NOTATION_NODE = 12; // 0xc
    field public static final short PROCESSING_INSTRUCTION_NODE = 7; // 0x7
    field public static final short TEXT_NODE = 3; // 0x3
  }

  public interface NodeList {
    method public int getLength();
    method public org.w3c.dom.Node item(int);
  }

  public interface Notation extends org.w3c.dom.Node {
    method public String getPublicId();
    method public String getSystemId();
  }

  public interface ProcessingInstruction extends org.w3c.dom.Node {
    method public String getData();
    method public String getTarget();
    method public void setData(String) throws org.w3c.dom.DOMException;
  }

  public interface Text extends org.w3c.dom.CharacterData {
    method public String getWholeText();
    method public boolean isElementContentWhitespace();
    method public org.w3c.dom.Text replaceWholeText(String) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.Text splitText(int) throws org.w3c.dom.DOMException;
  }

  public interface TypeInfo {
    method public String getTypeName();
    method public String getTypeNamespace();
    method public boolean isDerivedFrom(String, String, int);
    field public static final int DERIVATION_EXTENSION = 2; // 0x2
    field public static final int DERIVATION_LIST = 8; // 0x8
    field public static final int DERIVATION_RESTRICTION = 1; // 0x1
    field public static final int DERIVATION_UNION = 4; // 0x4
  }

  public interface UserDataHandler {
    method public void handle(short, String, Object, org.w3c.dom.Node, org.w3c.dom.Node);
    field public static final short NODE_ADOPTED = 5; // 0x5
    field public static final short NODE_CLONED = 1; // 0x1
    field public static final short NODE_DELETED = 3; // 0x3
    field public static final short NODE_IMPORTED = 2; // 0x2
    field public static final short NODE_RENAMED = 4; // 0x4
  }

}

package org.w3c.dom.ls {

  public interface DOMImplementationLS {
    method public org.w3c.dom.ls.LSInput createLSInput();
    method public org.w3c.dom.ls.LSOutput createLSOutput();
    method public org.w3c.dom.ls.LSParser createLSParser(short, String) throws org.w3c.dom.DOMException;
    method public org.w3c.dom.ls.LSSerializer createLSSerializer();
    field public static final short MODE_ASYNCHRONOUS = 2; // 0x2
    field public static final short MODE_SYNCHRONOUS = 1; // 0x1
  }

  public class LSException extends java.lang.RuntimeException {
    ctor public LSException(short, String);
    field public static final short PARSE_ERR = 81; // 0x51
    field public static final short SERIALIZE_ERR = 82; // 0x52
    field public short code;
  }

  public interface LSInput {
    method public String getBaseURI();
    method public java.io.InputStream getByteStream();
    method public boolean getCertifiedText();
    method public java.io.Reader getCharacterStream();
    method public String getEncoding();
    method public String getPublicId();
    method public String getStringData();
    method public String getSystemId();
    method public void setBaseURI(String);
    method public void setByteStream(java.io.InputStream);
    method public void setCertifiedText(boolean);
    method public void setCharacterStream(java.io.Reader);
    method public void setEncoding(String);
    method public void setPublicId(String);
    method public void setStringData(String);
    method public void setSystemId(String);
  }

  public interface LSOutput {
    method public java.io.OutputStream getByteStream();
    method public java.io.Writer getCharacterStream();
    method public String getEncoding();
    method public String getSystemId();
    method public void setByteStream(java.io.OutputStream);
    method public void setCharacterStream(java.io.Writer);
    method public void setEncoding(String);
    method public void setSystemId(String);
  }

  public interface LSParser {
    method public void abort();
    method public boolean getAsync();
    method public boolean getBusy();
    method public org.w3c.dom.DOMConfiguration getDomConfig();
    method public org.w3c.dom.ls.LSParserFilter getFilter();
    method public org.w3c.dom.Document parse(org.w3c.dom.ls.LSInput) throws org.w3c.dom.DOMException, org.w3c.dom.ls.LSException;
    method public org.w3c.dom.Document parseURI(String) throws org.w3c.dom.DOMException, org.w3c.dom.ls.LSException;
    method public org.w3c.dom.Node parseWithContext(org.w3c.dom.ls.LSInput, org.w3c.dom.Node, short) throws org.w3c.dom.DOMException, org.w3c.dom.ls.LSException;
    method public void setFilter(org.w3c.dom.ls.LSParserFilter);
    field public static final short ACTION_APPEND_AS_CHILDREN = 1; // 0x1
    field public static final short ACTION_INSERT_AFTER = 4; // 0x4
    field public static final short ACTION_INSERT_BEFORE = 3; // 0x3
    field public static final short ACTION_REPLACE = 5; // 0x5
    field public static final short ACTION_REPLACE_CHILDREN = 2; // 0x2
  }

  public interface LSParserFilter {
    method public short acceptNode(org.w3c.dom.Node);
    method public int getWhatToShow();
    method public short startElement(org.w3c.dom.Element);
    field public static final short FILTER_ACCEPT = 1; // 0x1
    field public static final short FILTER_INTERRUPT = 4; // 0x4
    field public static final short FILTER_REJECT = 2; // 0x2
    field public static final short FILTER_SKIP = 3; // 0x3
  }

  public interface LSResourceResolver {
    method public org.w3c.dom.ls.LSInput resolveResource(String, String, String, String, String);
  }

  public interface LSSerializer {
    method public org.w3c.dom.DOMConfiguration getDomConfig();
    method public String getNewLine();
    method public void setNewLine(String);
    method public boolean write(org.w3c.dom.Node, org.w3c.dom.ls.LSOutput) throws org.w3c.dom.ls.LSException;
    method public String writeToString(org.w3c.dom.Node) throws org.w3c.dom.DOMException, org.w3c.dom.ls.LSException;
    method public boolean writeToURI(org.w3c.dom.Node, String) throws org.w3c.dom.ls.LSException;
  }

}

package org.xml.sax {

  @Deprecated public interface AttributeList {
    method @Deprecated public int getLength();
    method @Deprecated public String getName(int);
    method @Deprecated public String getType(int);
    method @Deprecated public String getType(String);
    method @Deprecated public String getValue(int);
    method @Deprecated public String getValue(String);
  }

  public interface Attributes {
    method public int getIndex(String, String);
    method public int getIndex(String);
    method public int getLength();
    method public String getLocalName(int);
    method public String getQName(int);
    method public String getType(int);
    method public String getType(String, String);
    method public String getType(String);
    method public String getURI(int);
    method public String getValue(int);
    method public String getValue(String, String);
    method public String getValue(String);
  }

  public interface ContentHandler {
    method public void characters(char[], int, int) throws org.xml.sax.SAXException;
    method public void endDocument() throws org.xml.sax.SAXException;
    method public void endElement(String, String, String) throws org.xml.sax.SAXException;
    method public void endPrefixMapping(String) throws org.xml.sax.SAXException;
    method public void ignorableWhitespace(char[], int, int) throws org.xml.sax.SAXException;
    method public void processingInstruction(String, String) throws org.xml.sax.SAXException;
    method public void setDocumentLocator(org.xml.sax.Locator);
    method public void skippedEntity(String) throws org.xml.sax.SAXException;
    method public void startDocument() throws org.xml.sax.SAXException;
    method public void startElement(String, String, String, org.xml.sax.Attributes) throws org.xml.sax.SAXException;
    method public void startPrefixMapping(String, String) throws org.xml.sax.SAXException;
  }

  public interface DTDHandler {
    method public void notationDecl(String, String, String) throws org.xml.sax.SAXException;
    method public void unparsedEntityDecl(String, String, String, String) throws org.xml.sax.SAXException;
  }

  @Deprecated public interface DocumentHandler {
    method @Deprecated public void characters(char[], int, int) throws org.xml.sax.SAXException;
    method @Deprecated public void endDocument() throws org.xml.sax.SAXException;
    method @Deprecated public void endElement(String) throws org.xml.sax.SAXException;
    method @Deprecated public void ignorableWhitespace(char[], int, int) throws org.xml.sax.SAXException;
    method @Deprecated public void processingInstruction(String, String) throws org.xml.sax.SAXException;
    method @Deprecated public void setDocumentLocator(org.xml.sax.Locator);
    method @Deprecated public void startDocument() throws org.xml.sax.SAXException;
    method @Deprecated public void startElement(String, org.xml.sax.AttributeList) throws org.xml.sax.SAXException;
  }

  public interface EntityResolver {
    method public org.xml.sax.InputSource resolveEntity(String, String) throws java.io.IOException, org.xml.sax.SAXException;
  }

  public interface ErrorHandler {
    method public void error(org.xml.sax.SAXParseException) throws org.xml.sax.SAXException;
    method public void fatalError(org.xml.sax.SAXParseException) throws org.xml.sax.SAXException;
    method public void warning(org.xml.sax.SAXParseException) throws org.xml.sax.SAXException;
  }

  @Deprecated public class HandlerBase implements org.xml.sax.DTDHandler org.xml.sax.DocumentHandler org.xml.sax.EntityResolver org.xml.sax.ErrorHandler {
    ctor @Deprecated public HandlerBase();
    method @Deprecated public void characters(char[], int, int) throws org.xml.sax.SAXException;
    method @Deprecated public void endDocument() throws org.xml.sax.SAXException;
    method @Deprecated public void endElement(String) throws org.xml.sax.SAXException;
    method @Deprecated public void error(org.xml.sax.SAXParseException) throws org.xml.sax.SAXException;
    method @Deprecated public void fatalError(org.xml.sax.SAXParseException) throws org.xml.sax.SAXException;
    method @Deprecated public void ignorableWhitespace(char[], int, int) throws org.xml.sax.SAXException;
    method @Deprecated public void notationDecl(String, String, String);
    method @Deprecated public void processingInstruction(String, String) throws org.xml.sax.SAXException;
    method @Deprecated public org.xml.sax.InputSource resolveEntity(String, String) throws org.xml.sax.SAXException;
    method @Deprecated public void setDocumentLocator(org.xml.sax.Locator);
    method @Deprecated public void startDocument() throws org.xml.sax.SAXException;
    method @Deprecated public void startElement(String, org.xml.sax.AttributeList) throws org.xml.sax.SAXException;
    method @Deprecated public void unparsedEntityDecl(String, String, String, String);
    method @Deprecated public void warning(org.xml.sax.SAXParseException) throws org.xml.sax.SAXException;
  }

  public class InputSource {
    ctor public InputSource();
    ctor public InputSource(String);
    ctor public InputSource(java.io.InputStream);
    ctor public InputSource(java.io.Reader);
    method public java.io.InputStream getByteStream();
    method public java.io.Reader getCharacterStream();
    method public String getEncoding();
    method public String getPublicId();
    method public String getSystemId();
    method public void setByteStream(java.io.InputStream);
    method public void setCharacterStream(java.io.Reader);
    method public void setEncoding(String);
    method public void setPublicId(String);
    method public void setSystemId(String);
  }

  public interface Locator {
    method public int getColumnNumber();
    method public int getLineNumber();
    method public String getPublicId();
    method public String getSystemId();
  }

  @Deprecated public interface Parser {
    method @Deprecated public void parse(org.xml.sax.InputSource) throws java.io.IOException, org.xml.sax.SAXException;
    method @Deprecated public void parse(String) throws java.io.IOException, org.xml.sax.SAXException;
    method @Deprecated public void setDTDHandler(org.xml.sax.DTDHandler);
    method @Deprecated public void setDocumentHandler(org.xml.sax.DocumentHandler);
    method @Deprecated public void setEntityResolver(org.xml.sax.EntityResolver);
    method @Deprecated public void setErrorHandler(org.xml.sax.ErrorHandler);
    method @Deprecated public void setLocale(java.util.Locale) throws org.xml.sax.SAXException;
  }

  public class SAXException extends java.lang.Exception {
    ctor public SAXException();
    ctor public SAXException(String);
    ctor public SAXException(Exception);
    ctor public SAXException(String, Exception);
    method public Exception getException();
  }

  public class SAXNotRecognizedException extends org.xml.sax.SAXException {
    ctor public SAXNotRecognizedException();
    ctor public SAXNotRecognizedException(String);
  }

  public class SAXNotSupportedException extends org.xml.sax.SAXException {
    ctor public SAXNotSupportedException();
    ctor public SAXNotSupportedException(String);
  }

  public class SAXParseException extends org.xml.sax.SAXException {
    ctor public SAXParseException(String, org.xml.sax.Locator);
    ctor public SAXParseException(String, org.xml.sax.Locator, Exception);
    ctor public SAXParseException(String, String, String, int, int);
    ctor public SAXParseException(String, String, String, int, int, Exception);
    method public int getColumnNumber();
    method public int getLineNumber();
    method public String getPublicId();
    method public String getSystemId();
  }

  public interface XMLFilter extends org.xml.sax.XMLReader {
    method public org.xml.sax.XMLReader getParent();
    method public void setParent(org.xml.sax.XMLReader);
  }

  public interface XMLReader {
    method public org.xml.sax.ContentHandler getContentHandler();
    method public org.xml.sax.DTDHandler getDTDHandler();
    method public org.xml.sax.EntityResolver getEntityResolver();
    method public org.xml.sax.ErrorHandler getErrorHandler();
    method public boolean getFeature(String) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public Object getProperty(String) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public void parse(org.xml.sax.InputSource) throws java.io.IOException, org.xml.sax.SAXException;
    method public void parse(String) throws java.io.IOException, org.xml.sax.SAXException;
    method public void setContentHandler(org.xml.sax.ContentHandler);
    method public void setDTDHandler(org.xml.sax.DTDHandler);
    method public void setEntityResolver(org.xml.sax.EntityResolver);
    method public void setErrorHandler(org.xml.sax.ErrorHandler);
    method public void setFeature(String, boolean) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public void setProperty(String, Object) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
  }

}

package org.xml.sax.ext {

  public interface Attributes2 extends org.xml.sax.Attributes {
    method public boolean isDeclared(int);
    method public boolean isDeclared(String);
    method public boolean isDeclared(String, String);
    method public boolean isSpecified(int);
    method public boolean isSpecified(String, String);
    method public boolean isSpecified(String);
  }

  public class Attributes2Impl extends org.xml.sax.helpers.AttributesImpl implements org.xml.sax.ext.Attributes2 {
    ctor public Attributes2Impl();
    ctor public Attributes2Impl(org.xml.sax.Attributes);
    method public boolean isDeclared(int);
    method public boolean isDeclared(String, String);
    method public boolean isDeclared(String);
    method public boolean isSpecified(int);
    method public boolean isSpecified(String, String);
    method public boolean isSpecified(String);
    method public void setDeclared(int, boolean);
    method public void setSpecified(int, boolean);
  }

  public interface DeclHandler {
    method public void attributeDecl(String, String, String, String, String) throws org.xml.sax.SAXException;
    method public void elementDecl(String, String) throws org.xml.sax.SAXException;
    method public void externalEntityDecl(String, String, String) throws org.xml.sax.SAXException;
    method public void internalEntityDecl(String, String) throws org.xml.sax.SAXException;
  }

  public class DefaultHandler2 extends org.xml.sax.helpers.DefaultHandler implements org.xml.sax.ext.DeclHandler org.xml.sax.ext.EntityResolver2 org.xml.sax.ext.LexicalHandler {
    ctor public DefaultHandler2();
    method public void attributeDecl(String, String, String, String, String) throws org.xml.sax.SAXException;
    method public void comment(char[], int, int) throws org.xml.sax.SAXException;
    method public void elementDecl(String, String) throws org.xml.sax.SAXException;
    method public void endCDATA() throws org.xml.sax.SAXException;
    method public void endDTD() throws org.xml.sax.SAXException;
    method public void endEntity(String) throws org.xml.sax.SAXException;
    method public void externalEntityDecl(String, String, String) throws org.xml.sax.SAXException;
    method public org.xml.sax.InputSource getExternalSubset(String, String) throws java.io.IOException, org.xml.sax.SAXException;
    method public void internalEntityDecl(String, String) throws org.xml.sax.SAXException;
    method public org.xml.sax.InputSource resolveEntity(String, String, String, String) throws java.io.IOException, org.xml.sax.SAXException;
    method public void startCDATA() throws org.xml.sax.SAXException;
    method public void startDTD(String, String, String) throws org.xml.sax.SAXException;
    method public void startEntity(String) throws org.xml.sax.SAXException;
  }

  public interface EntityResolver2 extends org.xml.sax.EntityResolver {
    method public org.xml.sax.InputSource getExternalSubset(String, String) throws java.io.IOException, org.xml.sax.SAXException;
    method public org.xml.sax.InputSource resolveEntity(String, String, String, String) throws java.io.IOException, org.xml.sax.SAXException;
  }

  public interface LexicalHandler {
    method public void comment(char[], int, int) throws org.xml.sax.SAXException;
    method public void endCDATA() throws org.xml.sax.SAXException;
    method public void endDTD() throws org.xml.sax.SAXException;
    method public void endEntity(String) throws org.xml.sax.SAXException;
    method public void startCDATA() throws org.xml.sax.SAXException;
    method public void startDTD(String, String, String) throws org.xml.sax.SAXException;
    method public void startEntity(String) throws org.xml.sax.SAXException;
  }

  public interface Locator2 extends org.xml.sax.Locator {
    method public String getEncoding();
    method public String getXMLVersion();
  }

  public class Locator2Impl extends org.xml.sax.helpers.LocatorImpl implements org.xml.sax.ext.Locator2 {
    ctor public Locator2Impl();
    ctor public Locator2Impl(org.xml.sax.Locator);
    method public String getEncoding();
    method public String getXMLVersion();
    method public void setEncoding(String);
    method public void setXMLVersion(String);
  }

}

package org.xml.sax.helpers {

  @Deprecated public class AttributeListImpl implements org.xml.sax.AttributeList {
    ctor @Deprecated public AttributeListImpl();
    ctor @Deprecated public AttributeListImpl(org.xml.sax.AttributeList);
    method @Deprecated public void addAttribute(String, String, String);
    method @Deprecated public void clear();
    method @Deprecated public int getLength();
    method @Deprecated public String getName(int);
    method @Deprecated public String getType(int);
    method @Deprecated public String getType(String);
    method @Deprecated public String getValue(int);
    method @Deprecated public String getValue(String);
    method @Deprecated public void removeAttribute(String);
    method @Deprecated public void setAttributeList(org.xml.sax.AttributeList);
  }

  public class AttributesImpl implements org.xml.sax.Attributes {
    ctor public AttributesImpl();
    ctor public AttributesImpl(org.xml.sax.Attributes);
    method public void addAttribute(String, String, String, String, String);
    method public void clear();
    method public int getIndex(String, String);
    method public int getIndex(String);
    method public int getLength();
    method public String getLocalName(int);
    method public String getQName(int);
    method public String getType(int);
    method public String getType(String, String);
    method public String getType(String);
    method public String getURI(int);
    method public String getValue(int);
    method public String getValue(String, String);
    method public String getValue(String);
    method public void removeAttribute(int);
    method public void setAttribute(int, String, String, String, String, String);
    method public void setAttributes(org.xml.sax.Attributes);
    method public void setLocalName(int, String);
    method public void setQName(int, String);
    method public void setType(int, String);
    method public void setURI(int, String);
    method public void setValue(int, String);
  }

  public class DefaultHandler implements org.xml.sax.ContentHandler org.xml.sax.DTDHandler org.xml.sax.EntityResolver org.xml.sax.ErrorHandler {
    ctor public DefaultHandler();
    method public void characters(char[], int, int) throws org.xml.sax.SAXException;
    method public void endDocument() throws org.xml.sax.SAXException;
    method public void endElement(String, String, String) throws org.xml.sax.SAXException;
    method public void endPrefixMapping(String) throws org.xml.sax.SAXException;
    method public void error(org.xml.sax.SAXParseException) throws org.xml.sax.SAXException;
    method public void fatalError(org.xml.sax.SAXParseException) throws org.xml.sax.SAXException;
    method public void ignorableWhitespace(char[], int, int) throws org.xml.sax.SAXException;
    method public void notationDecl(String, String, String) throws org.xml.sax.SAXException;
    method public void processingInstruction(String, String) throws org.xml.sax.SAXException;
    method public org.xml.sax.InputSource resolveEntity(String, String) throws java.io.IOException, org.xml.sax.SAXException;
    method public void setDocumentLocator(org.xml.sax.Locator);
    method public void skippedEntity(String) throws org.xml.sax.SAXException;
    method public void startDocument() throws org.xml.sax.SAXException;
    method public void startElement(String, String, String, org.xml.sax.Attributes) throws org.xml.sax.SAXException;
    method public void startPrefixMapping(String, String) throws org.xml.sax.SAXException;
    method public void unparsedEntityDecl(String, String, String, String) throws org.xml.sax.SAXException;
    method public void warning(org.xml.sax.SAXParseException) throws org.xml.sax.SAXException;
  }

  public class LocatorImpl implements org.xml.sax.Locator {
    ctor public LocatorImpl();
    ctor public LocatorImpl(org.xml.sax.Locator);
    method public int getColumnNumber();
    method public int getLineNumber();
    method public String getPublicId();
    method public String getSystemId();
    method public void setColumnNumber(int);
    method public void setLineNumber(int);
    method public void setPublicId(String);
    method public void setSystemId(String);
  }

  public class NamespaceSupport {
    ctor public NamespaceSupport();
    method public boolean declarePrefix(String, String);
    method public java.util.Enumeration getDeclaredPrefixes();
    method public String getPrefix(String);
    method public java.util.Enumeration getPrefixes();
    method public java.util.Enumeration getPrefixes(String);
    method public String getURI(String);
    method public boolean isNamespaceDeclUris();
    method public void popContext();
    method public String[] processName(String, String[], boolean);
    method public void pushContext();
    method public void reset();
    method public void setNamespaceDeclUris(boolean);
    field public static final String NSDECL = "http://www.w3.org/xmlns/2000/";
    field public static final String XMLNS = "http://www.w3.org/XML/1998/namespace";
  }

  public class ParserAdapter implements org.xml.sax.DocumentHandler org.xml.sax.XMLReader {
    ctor public ParserAdapter() throws org.xml.sax.SAXException;
    ctor public ParserAdapter(org.xml.sax.Parser);
    method public void characters(char[], int, int) throws org.xml.sax.SAXException;
    method public void endDocument() throws org.xml.sax.SAXException;
    method public void endElement(String) throws org.xml.sax.SAXException;
    method public org.xml.sax.ContentHandler getContentHandler();
    method public org.xml.sax.DTDHandler getDTDHandler();
    method public org.xml.sax.EntityResolver getEntityResolver();
    method public org.xml.sax.ErrorHandler getErrorHandler();
    method public boolean getFeature(String) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public Object getProperty(String) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public void ignorableWhitespace(char[], int, int) throws org.xml.sax.SAXException;
    method public void parse(String) throws java.io.IOException, org.xml.sax.SAXException;
    method public void parse(org.xml.sax.InputSource) throws java.io.IOException, org.xml.sax.SAXException;
    method public void processingInstruction(String, String) throws org.xml.sax.SAXException;
    method public void setContentHandler(org.xml.sax.ContentHandler);
    method public void setDTDHandler(org.xml.sax.DTDHandler);
    method public void setDocumentLocator(org.xml.sax.Locator);
    method public void setEntityResolver(org.xml.sax.EntityResolver);
    method public void setErrorHandler(org.xml.sax.ErrorHandler);
    method public void setFeature(String, boolean) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public void setProperty(String, Object) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public void startDocument() throws org.xml.sax.SAXException;
    method public void startElement(String, org.xml.sax.AttributeList) throws org.xml.sax.SAXException;
  }

  @Deprecated public class ParserFactory {
    method @Deprecated public static org.xml.sax.Parser makeParser() throws java.lang.ClassCastException, java.lang.ClassNotFoundException, java.lang.IllegalAccessException, java.lang.InstantiationException, java.lang.NullPointerException;
    method @Deprecated public static org.xml.sax.Parser makeParser(String) throws java.lang.ClassCastException, java.lang.ClassNotFoundException, java.lang.IllegalAccessException, java.lang.InstantiationException;
  }

  public class XMLFilterImpl implements org.xml.sax.ContentHandler org.xml.sax.DTDHandler org.xml.sax.EntityResolver org.xml.sax.ErrorHandler org.xml.sax.XMLFilter {
    ctor public XMLFilterImpl();
    ctor public XMLFilterImpl(org.xml.sax.XMLReader);
    method public void characters(char[], int, int) throws org.xml.sax.SAXException;
    method public void endDocument() throws org.xml.sax.SAXException;
    method public void endElement(String, String, String) throws org.xml.sax.SAXException;
    method public void endPrefixMapping(String) throws org.xml.sax.SAXException;
    method public void error(org.xml.sax.SAXParseException) throws org.xml.sax.SAXException;
    method public void fatalError(org.xml.sax.SAXParseException) throws org.xml.sax.SAXException;
    method public org.xml.sax.ContentHandler getContentHandler();
    method public org.xml.sax.DTDHandler getDTDHandler();
    method public org.xml.sax.EntityResolver getEntityResolver();
    method public org.xml.sax.ErrorHandler getErrorHandler();
    method public boolean getFeature(String) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public org.xml.sax.XMLReader getParent();
    method public Object getProperty(String) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public void ignorableWhitespace(char[], int, int) throws org.xml.sax.SAXException;
    method public void notationDecl(String, String, String) throws org.xml.sax.SAXException;
    method public void parse(org.xml.sax.InputSource) throws java.io.IOException, org.xml.sax.SAXException;
    method public void parse(String) throws java.io.IOException, org.xml.sax.SAXException;
    method public void processingInstruction(String, String) throws org.xml.sax.SAXException;
    method public org.xml.sax.InputSource resolveEntity(String, String) throws java.io.IOException, org.xml.sax.SAXException;
    method public void setContentHandler(org.xml.sax.ContentHandler);
    method public void setDTDHandler(org.xml.sax.DTDHandler);
    method public void setDocumentLocator(org.xml.sax.Locator);
    method public void setEntityResolver(org.xml.sax.EntityResolver);
    method public void setErrorHandler(org.xml.sax.ErrorHandler);
    method public void setFeature(String, boolean) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public void setParent(org.xml.sax.XMLReader);
    method public void setProperty(String, Object) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public void skippedEntity(String) throws org.xml.sax.SAXException;
    method public void startDocument() throws org.xml.sax.SAXException;
    method public void startElement(String, String, String, org.xml.sax.Attributes) throws org.xml.sax.SAXException;
    method public void startPrefixMapping(String, String) throws org.xml.sax.SAXException;
    method public void unparsedEntityDecl(String, String, String, String) throws org.xml.sax.SAXException;
    method public void warning(org.xml.sax.SAXParseException) throws org.xml.sax.SAXException;
  }

  public class XMLReaderAdapter implements org.xml.sax.ContentHandler org.xml.sax.Parser {
    ctor public XMLReaderAdapter() throws org.xml.sax.SAXException;
    ctor public XMLReaderAdapter(org.xml.sax.XMLReader);
    method public void characters(char[], int, int) throws org.xml.sax.SAXException;
    method public void endDocument() throws org.xml.sax.SAXException;
    method public void endElement(String, String, String) throws org.xml.sax.SAXException;
    method public void endPrefixMapping(String);
    method public void ignorableWhitespace(char[], int, int) throws org.xml.sax.SAXException;
    method public void parse(String) throws java.io.IOException, org.xml.sax.SAXException;
    method public void parse(org.xml.sax.InputSource) throws java.io.IOException, org.xml.sax.SAXException;
    method public void processingInstruction(String, String) throws org.xml.sax.SAXException;
    method public void setDTDHandler(org.xml.sax.DTDHandler);
    method public void setDocumentHandler(org.xml.sax.DocumentHandler);
    method public void setDocumentLocator(org.xml.sax.Locator);
    method public void setEntityResolver(org.xml.sax.EntityResolver);
    method public void setErrorHandler(org.xml.sax.ErrorHandler);
    method public void setLocale(java.util.Locale) throws org.xml.sax.SAXException;
    method public void skippedEntity(String) throws org.xml.sax.SAXException;
    method public void startDocument() throws org.xml.sax.SAXException;
    method public void startElement(String, String, String, org.xml.sax.Attributes) throws org.xml.sax.SAXException;
    method public void startPrefixMapping(String, String);
  }

  public final class XMLReaderFactory {
    method public static org.xml.sax.XMLReader createXMLReader() throws org.xml.sax.SAXException;
    method public static org.xml.sax.XMLReader createXMLReader(String) throws org.xml.sax.SAXException;
  }

}

package org.xmlpull.v1 {

  public interface XmlPullParser {
    method public void defineEntityReplacementText(String, String) throws org.xmlpull.v1.XmlPullParserException;
    method public int getAttributeCount();
    method public String getAttributeName(int);
    method public String getAttributeNamespace(int);
    method public String getAttributePrefix(int);
    method public String getAttributeType(int);
    method public String getAttributeValue(int);
    method public String getAttributeValue(String, String);
    method public int getColumnNumber();
    method public int getDepth();
    method public int getEventType() throws org.xmlpull.v1.XmlPullParserException;
    method public boolean getFeature(String);
    method public String getInputEncoding();
    method public int getLineNumber();
    method public String getName();
    method public String getNamespace(String);
    method public String getNamespace();
    method public int getNamespaceCount(int) throws org.xmlpull.v1.XmlPullParserException;
    method public String getNamespacePrefix(int) throws org.xmlpull.v1.XmlPullParserException;
    method public String getNamespaceUri(int) throws org.xmlpull.v1.XmlPullParserException;
    method public String getPositionDescription();
    method public String getPrefix();
    method public Object getProperty(String);
    method public String getText();
    method public char[] getTextCharacters(int[]);
    method public boolean isAttributeDefault(int);
    method public boolean isEmptyElementTag() throws org.xmlpull.v1.XmlPullParserException;
    method public boolean isWhitespace() throws org.xmlpull.v1.XmlPullParserException;
    method public int next() throws java.io.IOException, org.xmlpull.v1.XmlPullParserException;
    method public int nextTag() throws java.io.IOException, org.xmlpull.v1.XmlPullParserException;
    method public String nextText() throws java.io.IOException, org.xmlpull.v1.XmlPullParserException;
    method public int nextToken() throws java.io.IOException, org.xmlpull.v1.XmlPullParserException;
    method public void require(int, String, String) throws java.io.IOException, org.xmlpull.v1.XmlPullParserException;
    method public void setFeature(String, boolean) throws org.xmlpull.v1.XmlPullParserException;
    method public void setInput(java.io.Reader) throws org.xmlpull.v1.XmlPullParserException;
    method public void setInput(java.io.InputStream, String) throws org.xmlpull.v1.XmlPullParserException;
    method public void setProperty(String, Object) throws org.xmlpull.v1.XmlPullParserException;
    field public static final int CDSECT = 5; // 0x5
    field public static final int COMMENT = 9; // 0x9
    field public static final int DOCDECL = 10; // 0xa
    field public static final int END_DOCUMENT = 1; // 0x1
    field public static final int END_TAG = 3; // 0x3
    field public static final int ENTITY_REF = 6; // 0x6
    field public static final String FEATURE_PROCESS_DOCDECL = "http://xmlpull.org/v1/doc/features.html#process-docdecl";
    field public static final String FEATURE_PROCESS_NAMESPACES = "http://xmlpull.org/v1/doc/features.html#process-namespaces";
    field public static final String FEATURE_REPORT_NAMESPACE_ATTRIBUTES = "http://xmlpull.org/v1/doc/features.html#report-namespace-prefixes";
    field public static final String FEATURE_VALIDATION = "http://xmlpull.org/v1/doc/features.html#validation";
    field public static final int IGNORABLE_WHITESPACE = 7; // 0x7
    field public static final String NO_NAMESPACE = "";
    field public static final int PROCESSING_INSTRUCTION = 8; // 0x8
    field public static final int START_DOCUMENT = 0; // 0x0
    field public static final int START_TAG = 2; // 0x2
    field public static final int TEXT = 4; // 0x4
    field public static final String[] TYPES;
  }

  public class XmlPullParserException extends java.lang.Exception {
    ctor public XmlPullParserException(String);
    ctor public XmlPullParserException(String, org.xmlpull.v1.XmlPullParser, Throwable);
    method public int getColumnNumber();
    method public Throwable getDetail();
    method public int getLineNumber();
    field protected int column;
    field protected Throwable detail;
    field protected int row;
  }

  public class XmlPullParserFactory {
    ctor protected XmlPullParserFactory();
    method public boolean getFeature(String);
    method public boolean isNamespaceAware();
    method public boolean isValidating();
    method public static org.xmlpull.v1.XmlPullParserFactory newInstance() throws org.xmlpull.v1.XmlPullParserException;
    method public static org.xmlpull.v1.XmlPullParserFactory newInstance(String, Class) throws org.xmlpull.v1.XmlPullParserException;
    method public org.xmlpull.v1.XmlPullParser newPullParser() throws org.xmlpull.v1.XmlPullParserException;
    method public org.xmlpull.v1.XmlSerializer newSerializer() throws org.xmlpull.v1.XmlPullParserException;
    method public void setFeature(String, boolean) throws org.xmlpull.v1.XmlPullParserException;
    method public void setNamespaceAware(boolean);
    method public void setValidating(boolean);
    field public static final String PROPERTY_NAME = "org.xmlpull.v1.XmlPullParserFactory";
    field protected String classNamesLocation;
    field protected java.util.HashMap<java.lang.String,java.lang.Boolean> features;
    field protected java.util.ArrayList parserClasses;
    field protected java.util.ArrayList serializerClasses;
  }

  public interface XmlSerializer {
    method public org.xmlpull.v1.XmlSerializer attribute(String, String, String) throws java.io.IOException, java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public void cdsect(String) throws java.io.IOException, java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public void comment(String) throws java.io.IOException, java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public void docdecl(String) throws java.io.IOException, java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public void endDocument() throws java.io.IOException, java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public org.xmlpull.v1.XmlSerializer endTag(String, String) throws java.io.IOException, java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public void entityRef(String) throws java.io.IOException, java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public void flush() throws java.io.IOException;
    method public int getDepth();
    method public boolean getFeature(String);
    method public String getName();
    method public String getNamespace();
    method public String getPrefix(String, boolean) throws java.lang.IllegalArgumentException;
    method public Object getProperty(String);
    method public void ignorableWhitespace(String) throws java.io.IOException, java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public void processingInstruction(String) throws java.io.IOException, java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public void setFeature(String, boolean) throws java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public void setOutput(java.io.OutputStream, String) throws java.io.IOException, java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public void setOutput(java.io.Writer) throws java.io.IOException, java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public void setPrefix(String, String) throws java.io.IOException, java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public void setProperty(String, Object) throws java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public void startDocument(String, Boolean) throws java.io.IOException, java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public org.xmlpull.v1.XmlSerializer startTag(String, String) throws java.io.IOException, java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public org.xmlpull.v1.XmlSerializer text(String) throws java.io.IOException, java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public org.xmlpull.v1.XmlSerializer text(char[], int, int) throws java.io.IOException, java.lang.IllegalArgumentException, java.lang.IllegalStateException;
  }

}

package org.xmlpull.v1.sax2 {

  public class Driver implements org.xml.sax.Attributes org.xml.sax.Locator org.xml.sax.XMLReader {
    ctor public Driver() throws org.xmlpull.v1.XmlPullParserException;
    ctor public Driver(org.xmlpull.v1.XmlPullParser) throws org.xmlpull.v1.XmlPullParserException;
    method public int getColumnNumber();
    method public org.xml.sax.ContentHandler getContentHandler();
    method public org.xml.sax.DTDHandler getDTDHandler();
    method public org.xml.sax.EntityResolver getEntityResolver();
    method public org.xml.sax.ErrorHandler getErrorHandler();
    method public boolean getFeature(String) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public int getIndex(String, String);
    method public int getIndex(String);
    method public int getLength();
    method public int getLineNumber();
    method public String getLocalName(int);
    method public Object getProperty(String) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public String getPublicId();
    method public String getQName(int);
    method public String getSystemId();
    method public String getType(int);
    method public String getType(String, String);
    method public String getType(String);
    method public String getURI(int);
    method public String getValue(int);
    method public String getValue(String, String);
    method public String getValue(String);
    method public void parse(org.xml.sax.InputSource) throws java.io.IOException, org.xml.sax.SAXException;
    method public void parse(String) throws java.io.IOException, org.xml.sax.SAXException;
    method public void parseSubTree(org.xmlpull.v1.XmlPullParser) throws java.io.IOException, org.xml.sax.SAXException;
    method public void setContentHandler(org.xml.sax.ContentHandler);
    method public void setDTDHandler(org.xml.sax.DTDHandler);
    method public void setEntityResolver(org.xml.sax.EntityResolver);
    method public void setErrorHandler(org.xml.sax.ErrorHandler);
    method public void setFeature(String, boolean) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method public void setProperty(String, Object) throws org.xml.sax.SAXNotRecognizedException, org.xml.sax.SAXNotSupportedException;
    method protected void startElement(String, String, String) throws org.xml.sax.SAXException;
    field protected static final String APACHE_DYNAMIC_VALIDATION_FEATURE = "http://apache.org/xml/features/validation/dynamic";
    field protected static final String APACHE_SCHEMA_VALIDATION_FEATURE = "http://apache.org/xml/features/validation/schema";
    field protected static final String DECLARATION_HANDLER_PROPERTY = "http://xml.org/sax/properties/declaration-handler";
    field protected static final String LEXICAL_HANDLER_PROPERTY = "http://xml.org/sax/properties/lexical-handler";
    field protected static final String NAMESPACES_FEATURE = "http://xml.org/sax/features/namespaces";
    field protected static final String NAMESPACE_PREFIXES_FEATURE = "http://xml.org/sax/features/namespace-prefixes";
    field protected static final String VALIDATION_FEATURE = "http://xml.org/sax/features/validation";
    field protected org.xml.sax.ContentHandler contentHandler;
    field protected org.xml.sax.ErrorHandler errorHandler;
    field protected org.xmlpull.v1.XmlPullParser pp;
    field protected String systemId;
  }

}

